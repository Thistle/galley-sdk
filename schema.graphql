# DEPRECATED.  Mutation will be replaced in a short time
input _BulkUpsertMenuInput {
  id: String

  # 'name' is required for new menus. If not provided, the menu will be ignored.
  name: String

  # ISO Date Format only, YYYY-MM-DD
  date: String
  conceptId: String
  conceptName: String
  locationId: String
  locationExternalId: String
  locationName: String
  categoryValueNamesByCategoryName: ImportCategoryValuesType
  menuItems: [_BulkUpsertMenuItemInput!]
  isPerHead: Boolean
  headCount: Int
  manualTotalSalesValueCents: Float
}

# DEPRECATED.  Mutation will be replaced in a short time
input _BulkUpsertMenuItemInput {
  id: String
  recipeId: String
  recipeName: String
  recipeShortCode: String
  isPerHead: Boolean
  perHeadFactor: Float
  volume: Float
  volumeSold: Float
  unit: UnitInput
  position: Int
  categoryValueNamesByCategoryName: ImportCategoryValuesType
  salesPriceCents: Int
}

# DEPRECATED.  Mutation will be replaced in a short time
input _BulkUpsertMenusInput {
  menus: [_BulkUpsertMenuInput!]!
  async: Boolean
}

# DEPRECATED.  Mutation will be replaced in a short time
type _BulkUpsertMenusPayload {
  error: Error
  menus: [Menu]
  jobId: String
}

input AddCategoryValueItemInput {
  itemId: String!
  categoryValueId: String!
}

type AddCategoryValueItemPayload {
  categoryValueItem: CategoryValueItem
  error: Error
}

# This is extra data that is not found inside Galley but should still be included on your label(s)
input AdditionalPrintLabelDataType {
  producedDate: DateOnly
}

input AddMenuToEventInput {
  menuId: String!
  eventId: String!
}

type AddMenuToEventPayload {
  event: Event
  error: Error
}

input AddOrderCategoryValueItemsInput {
  orderId: String!
  categoryValueId: String!
}

# Input type for approving an invoice. Contains a field id for the invoice to be approved.
input ApproveInvoiceInput {
  id: String!
}

#  ApproveMenuPlanEventInput represents the parameters required to approve a MenuPlan.
input ApproveMenuPlanEventInput {
  id: ID!
}

# Input type for archiving an invoice. Contains a field id for the invoice to be archived.
input ArchiveInvoiceInput {
  id: String!
}

input AssignLocationsToUsersInput {
  userIds: [String!]!
  locationIds: [String!]!
}

type AssignLocationsToUsersPayload {
  users: [User!]!
}

input AssignPoliciesInput {
  email: String!
  policies: [String!]!
}

type AssignPoliciesPayload {
  policies: [String!]
}

input AssignPolicyDefinitionInput {
  policyIds: [String!]!
  userId: String!
}

type AssignPolicyDefinitionResponse {
  policies: [Policy!]!
}

input AssignRolesInput {
  email: String!
  roles: [String!]!
}

type AssignRolesPayload {
  roles: [String!]
}

input AvailablePoliciesFilter {
  type: PolicyType
  id: String
  query: String
}

type BreadcrumbRecipe {
  id: ID!
  recipeId: String!
  name: String!
  quantity: Float
  unit: Unit
}

input BulkAddCategoryValueItemsInput {
  itemIds: [String!]!
  categoryValueId: String
  categoryValueIds: [String!]
  itemType: CategoryItemTypeEnum!
}

type BulkAddCategoryValueItemsPayload {
  categoryValueItems: [CategoryValueItem!]
  error: Error
}

input BulkAddOrderCategoryValueItemsInput {
  orderIds: [String!]!
  categoryValueId: String!
}

input BulkAssignPermissionsInput {
  users: [BulkPermissionsUserInput!]!
  permissions: BulkPermissionsInput!
}

type BulkAssignPermissionsPayload {
  users: [User!]!
}

input BulkAssignPolicyDefinitionInput {
  policyIds: [String!]!
  userIds: [String!]!
}

type BulkAssignPolicyDefinitionResponse {
  policies: [Policy!]!
  userIds: [String!]!
}

#  BulkClearMenuCycleEventsInput represents the parameters required to clear MenuCycleEvents data.
input BulkClearMenuCycleEventsInput {
  ids: [ID!]
}

#  BulkClearMenuPlanEventsInput represents the parameters required to clear all items from MenuPlanEvents.
input BulkClearMenuPlanEventsInput {
  ids: [ID!]
}

input BulkCopyIngredientsVendorItemsInput {
  sourceLocationId: String!
  destinationLocationIds: [String!]!
}

type BulkCopyIngredientsVendorItemsPayload {
  ingredients: [Ingredient!]
  error: Error
}

type BulkCreateCatalogDestinationLocationPayload {
  error: Error
  catalogDestinationLocations: [TransfersCatalogDestinationLocation]
}

input BulkCreateCategoryValueItemsInput {
  categoryValueItems: [BulkCreateCategoryValueItemsInputCategoryValueItemInput!]!
  itemType: CategoryItemTypeEnum!
}

input BulkCreateCategoryValueItemsInputCategoryValueItemInput {
  itemId: String!
  categoryValueIds: [String!]!
}

type BulkCreateCategoryValueItemsPayload {
  categoryValueItems: [CategoryValueItem!]
  error: Error
}

input BulkCreateIngredientsVendorItemsIngredientVendorItemInput {
  # The ID of the ingredient.
  # Required if `ingredientName` is not provided.
  ingredientId: String

  # The name of the ingredient.
  # Required if `ingredientId` is not provided.
  ingredientName: String

  # The ID of the vendor item.
  # Required if `vendorItemName` is not provided.
  vendorItemId: String

  # The name of the vendor item.
  # Required if `vendorItemId` is not provided.
  vendorItemName: String

  # The ID of the vendor.
  # Required if `vendorItemId` is not provided and `vendorItemName` is not provided.
  vendorId: String

  # The name of the vendor.
  # Required if `vendorItemId` is not provided and `vendorItemId` is not provided.
  vendorName: String
}

input BulkCreateIngredientsVendorItemsInput {
  # A mapping of ingredient to vendor item, allowing for using names instead of IDs.
  # To add multiple vendor items for the same ingredient, provide multiple objects
  # with the same `ingredient*` identifiers.
  # Required if `ingredientIdsVendorItemIds` is not provided.
  ingredientVendorItems: [BulkCreateIngredientsVendorItemsIngredientVendorItemInput!]

  # A mapping of ingredientId to the vendorItemIds to association.
  # If provided, `ingredientVendorItems` will be ignored.
  ingredientIdsVendorItemIds: [IngredientIdVendorItemIds!]

  # The `priority` of the newly created `ingredientVendorItems`.
  # If multiple `vendorItemIds` are provided, the `priority` field will be
  # use for the first `vendorItemId` and the following `vendorItemIds` will be
  # added after it.
  # Existing `ingredientVendorItems` with be incremented accordingly.
  # If omitted, the `priority` field will be set to the max priority of
  # existing `ingredientVendorItems` + 1. This is the same as setting the
  # `priority` field to `-1`.
  # Set to `0` to add the newly created `ingredientVendorItems` to the
  # beginning of the existing `ingredientVendorItems'.
  priority: Int
  locationIds: [String!]
  companyId: String
}

type BulkCreateIngredientsVendorItemsInvalidIngredientVendorItem {
  ingredientId: String
  ingredientName: String
  vendorItemId: String
  vendorItemName: String
  vendorId: String
  vendorName: String
}

type BulkCreateIngredientsVendorItemsInvalidIngredientVendorItemWithErrorMessages {
  inputIndex: Int!
  inputIngredientVendorItem: BulkCreateIngredientsVendorItemsInvalidIngredientVendorItem!
  errorMessage: String!
}

type BulkCreateIngredientsVendorItemsPayload {
  ingredients: [Ingredient!]
  invalidIngredientVendorItems: [BulkCreateIngredientsVendorItemsInvalidIngredientVendorItemWithErrorMessages!]
  error: Error
}

input BulkCreateMenuPlanPOCTemplateItemsInput {
  menuTemplateIds: [String!]!
  menuPlanId: String!
}

type BulkCreateMenuPlanPOCTemplateItemsPayload {
  error: Error
  menuPlanTemplateItems: [MenuPlanPOCTemplateItem!]
}

input BulkCreateMenuTemplateItemsInput {
  menuTemplateItems: [MenuTemplateItemInput!]!
}

type BulkCreateMenuTemplateItemsPayload {
  error: Error
  menuTemplateItems: [MenuTemplateItem]
}

input BulkCreateMenuTemplatesInput {
  menuTemplates: [MenuTemplateInput!]!
}

type BulkCreateMenuTemplatesPayload {
  error: Error
  menuTemplates: [MenuTemplate!]
}

input BulkCreateSubLocationItemsInput {
  subLocationItems: [SubLocationItemInput!]!
}

type BulkCreateSubLocationItemsPayload {
  subLocationItems: [SubLocationItem]
  error: Error
}

type BulkCreateTransferOrderItemPayload {
  error: Error
  transferOrderItems: [TransferOrderItem]
}

type BulkCreateTransfersCatalogItemPayload {
  error: Error
  transfersCatalogItems: [TransfersCatalogItemType]
}

type BulkCreateTransfersCatalogPayload {
  error: Error
  transfersCatalogItems: [TransfersCatalogItemType]
  transfersCatalogs: [TransfersCatalogType]
}

type BulkDeleteCatalogDestinationLocationPayload {
  error: Error
  catalogDestinationLocations: [TransfersCatalogDestinationLocation]
}

# A bulk delete collection item input contains the ids of the collection components to be deleted.
input BulkDeleteCollectionItemsInput {
  ids: [String!]
}

# A bulk delete collection item payload is the result of a collection component bulk delete, with an error or the collection components deleted.
type BulkDeleteCollectionItemsPayload {
  error: Error
  items: [CollectionItem!]
}

# A bulk delete collections input contains a set of ids of collections to be deleted.
input BulkDeleteCollectionsInput {
  ids: [String!]!
}

# A bulk delete collections payload is the result of a collection bulk delete, with an error or the collections deleted.
type BulkDeleteCollectionsPayload {
  error: Error
  collections: [Collection!]
}

input BulkDeleteIngredientsInput {
  ids: [String!]!
}

type BulkDeleteIngredientsPayload {
  ingredients: [Ingredient!]!
}

input BulkDeleteIngredientsVendorItemsInput {
  ingredientIdsVendorItemIds: [IngredientIdVendorItemIds!]!
  locationIds: [String!]
}

type BulkDeleteIngredientsVendorItemsPayload {
  ingredients: [Ingredient!]
  error: Error
}

#  BulkDeleteMenuCycleEventGroupsInput represents the parameters required to delete MenuCycleEventGroups.
input BulkDeleteMenuCycleEventGroupsInput {
  ids: [ID!]
}

#  BulkDeleteMenuCycleEventItemsInput represents the parameters required to delete MenuCycleEventItems.
input BulkDeleteMenuCycleEventItemsInput {
  ids: [ID!]
}

#  BulkDeleteMenuCycleEventsInput represents the parameters required to delete MenuCycleEvents.
input BulkDeleteMenuCycleEventsInput {
  ids: [ID!]
}

#  BulkDeleteMenuCycleProductGroupsInput represents the parameters required to delete MenuCycleProductGroups.
input BulkDeleteMenuCycleProductGroupsInput {
  ids: [ID!]
}

#  BulkDeleteMenuCyclesInput represents the parameters required to delete MenuCycles.
input BulkDeleteMenuCyclesInput {
  ids: [ID!]
}

#  BulkDeleteMenuPlanEventGroupsInput represents the parameters required to delete MenuPlanEventGroup.
input BulkDeleteMenuPlanEventGroupsInput {
  ids: [ID!]
}

#  BulkDeleteMenuPlanEventInput represents the parameters required to delete MenuPlanEvent.
input BulkDeleteMenuPlanEventInput {
  ids: [ID!]
}

#  BulkDeleteMenuPlanEventItemsInput represents the parameters required to delete MenuPlanEventItem.
input BulkDeleteMenuPlanEventItemsInput {
  ids: [ID!]
}

input BulkDeleteMenuPlanPOCTemplateItemsInput {
  ids: [String!]!
}

type BulkDeleteMenuPlanPOCTemplateItemsPayload {
  error: Error
  menuPlanTemplateItems: [MenuPlanPOCTemplateItem!]
}

#  BulkDeleteMenuPlanProductGroupsInput represents the parameters required to delete MenuPlanProductGroup.
input BulkDeleteMenuPlanProductGroupsInput {
  ids: [ID!]
}

#  BulkDeleteMenuPlansInput represents the parameters required to delete MenuPlans.
input BulkDeleteMenuPlansInput {
  ids: [ID!]
}

input BulkDeleteMenusInput {
  ids: [String!]
  locationGroupIds: [String!]
  locationIds: [String!]
  from: DateOnly
  until: DateOnly
  dates: [DateOnly!]
}

type BulkDeleteMenusPayload {
  error: Error
  numDeletedMenus: Int
}

input BulkDeleteMenuTemplateItemsInput {
  ids: [String!]!
}

type BulkDeleteMenuTemplateItemsPayload {
  error: Error
  menuTemplateItems: [MenuTemplateItem]
}

input BulkDeleteMenuTemplatesInput {
  ids: [String!]!
}

type BulkDeleteMenuTemplatesPayload {
  error: Error
  menuTemplates: [MenuTemplate!]
}

input BulkDeleteRecipesInput {
  recipeIds: [String!]!
}

type BulkDeleteRecipesPayload {
  recipes: [Recipe!]!
  error: Error
}

input BulkDeleteSubLocationItemsInput {
  ids: [String!]!
}

type BulkDeleteSubLocationItemsPayload {
  subLocationItems: [SubLocationItem!]
  error: Error
}

type BulkDeleteTransfersCatalogItemPayload {
  error: Error
  transfersCatalogItems: [TransfersCatalogItemType]
}

type BulkDeleteTransfersCatalogPayload {
  error: Error
  transfersCatalogs: [TransfersCatalogType]
}

input BulkPermissionsInput {
  roles: [String!]!
  policies: [String!]!
}

input BulkPermissionsUserInput {
  id: String!
  email: String!
}

input BulkRemoveCategoryValueItemsInput {
  itemIds: [String!]!
  categoryValueId: String
  categoryValueIds: [String!]
  itemType: CategoryItemTypeEnum!
}

type BulkRemoveCategoryValueItemsPayload {
  categoryValueItems: [CategoryValueItem!]
  error: Error
}

input BulkRemoveOrderCategoryValueItemsInput {
  orderIds: [String!]!
  categoryValueId: String!
}

input BulkReorderIngredientVendorItemsIngredientGroupedLocationVendorItems {
  ingredientId: String!
  vendorItemIds: [String!]!
  allLocations: Boolean
  locationIds: [String!]
}

input BulkReorderIngredientVendorItemsInput {
  ingredientGroupedLocationVendorItems: [BulkReorderIngredientVendorItemsIngredientGroupedLocationVendorItems!]!
}

type BulkReorderIngredientVendorItemsPayload {
  ingredients: [Ingredient!]
  error: Error
}

# Bulk assing location to printer result
type BulkSetLocationToPrinterResult {
  locationID: ID!
  printerIDs: [ID!]!
}

input BulkSetPermissionsInput {
  users: [BulkPermissionsUserInput!]!
  permissions: BulkPermissionsInput!
}

type BulkSetPermissionsPayload {
  users: [User!]!
}

input BulkSetPriorityVendorsInput {
  # The IDs of the vendors whose vendor items should be reordered.
  # If an ingredient is associated with multiple vendors at the same location,
  # the priority of the vendor items will be determined by the order of the
  # provided vendor IDs.
  vendorIds: [String!]!

  # Set to `true` to reorder the vendor items for all locations.
  # Should not be used when `locationIds` are provided.
  # Must be set to true if `locationIds` are not provided.
  allLocations: Boolean

  # The IDs of the locations whose vendor items should be reordered.
  # Should not be used when `allLocations` is `true`.
  # Must be set to true if `allLocations` is false or not provided.
  locationIds: [String!]
}

type BulkSetPriorityVendorsPayload {
  error: Error
  vendors: [Vendor!]
}

input BulkTransitionPurchaseOrderInput {
  ids: [String!]!
  targetStatus: String!
}

type BulkTransitionPurchaseOrderPayload {
  error: Error
  purchaseOrders: [PurchaseOrder!]
}

input BulkUnassignPermissionsInput {
  users: [BulkPermissionsUserInput!]!
  permissions: BulkPermissionsInput!
}

type BulkUnassignPermissionsPayload {
  users: [User!]!
}

input BulkUnassignPolicyDefinitionInput {
  policyIds: [String!]!
  userIds: [String!]!
}

type BulkUnassignPolicyDefinitionResponse {
  policies: [Policy!]!
  userIds: [String!]!
}

# Input type for bulk updating the status of multiple invoices. Contains fields ids (an array of invoice IDs) and status (new status to apply).
input BulkUpdateInvoiceStatusInput {
  ids: [String!]!
  status: StatusEnum!
}

# Payload type for the BulkUpdateInvoiceStatus mutation. Contains a field invoices which is an array of updated Invoice objects.
type BulkUpdateInvoiceStatusPayload {
  invoices: [Invoice!]!
}

input BulkUpdateMenuTemplatesInput {
  menuTemplates: [UpdateMenuTemplateInput!]!
}

type BulkUpdateMenuTemplatesPayload {
  error: Error
  menuTemplates: [MenuTemplate!]
}

input BulkUpdateRecipeItemsInput {
  ids: [String!]!
  attrs: RecipeItemInput!
}

type BulkUpdateRecipeItemsPayload {
  error: Error
  recipeItems: [RecipeItem]
}

type BulkUpdateTransfersCatalogItemsPayload {
  error: Error
  transfersCatalogItems: [TransfersCatalogItemType]
}

type BulkUpdateTransfersCatalogPayload {
  error: Error
  transfersCatalogs: [TransfersCatalogType]
}

input BulkUpdateVendorItemsCategoryValuesInput {
  categoryName: String!
  categoryValues: [String]!
}

input BulkUpdateVendorItemsInput {
  vendorItems: [BulkUpdateVendorItemsVendorItemInput!]!
  companyId: String
  shouldBiasCreate: Boolean
  isEdiRequest: Boolean
}

type BulkUpdateVendorItemsPayload {
  jobId: String!
}

input BulkUpdateVendorItemsVendorItemInput {
  id: String
  name: String
  externalId: String
  sku: String
  glCode: String
  vendorName: String
  vendorId: String
  ingredientListStr: String
  brandName: String
  barcode: String
  notes: String
  date: String
  effectiveDate: Date
  costCents: Float
  canonicalIngredientId: String
  canonicalIngredientName: String
  costUnit: UnitInput
  inventoryUnit: UnitInput
  purchasingUnit: UnitInput
  unitConversions: [CreateUnitConversionUnitConversionInput!]
  categoryNamesWithValues: [BulkUpdateVendorItemsCategoryValuesInput!]
  nutritionalsQuantity: Float
  nutritionalsUnit: UnitInput
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  dietaryFlagNames: [String!]
}

input BulkUploadCategoriesCategoryInput {
  # Use `id` to identify an existing category by ID for update. If provided and
  # not matching category is found, an error will be returned.
  id: String

  # If `name` is provided and `id` is not, you must also provide an `itemType`.
  # If an existing category is found with the provided `name` and `itemType`,
  # it's category values will be updated if provided.
  name: String

  # If a category already exists with the provided `id`, the `itemType` must match
  # the existing category's `itemType`. Otherwise, an error will be returned.
  # If creating a new category with the provided `name`, `itemType` must be provided.
  # If providing an `id`, `itemType` is not required.
  itemType: CategoryItemTypeEnum

  # If `categoryValues` is provided, the input will be used to create new values
  # with the given name or update existing values matching by id.
  # If `deleteMissingCategoryValues` and `categoryValues` are provided, the
  # input will be used to delete existing values that don't match the provided objects
  # a.k.a a "set" operation.
  # For example, if `deleteMissingCategoryValues` is true and
  # `categoryValues` is passed as [], all existing category values will be deleted.
  categoryValues: [BulkUploadCategoriesCategoryValueInput!]
}

input BulkUploadCategoriesCategoryValueInput {
  id: String
  name: String
}

input BulkUploadCategoriesInput {
  categories: [BulkUploadCategoriesCategoryInput!]!

  # Optionally set `deleteMissingCategoryValues` to `true` to delete any existing
  # that are not represented in the provided `categoryValues` for each category.
  # For example, if you want to only add category values to a category without deleting
  # any that are not provided, the desired value for `deleteMissingCategoryValues` should be `false`.
  # If you want to treat the `categoryValues` as a "set" operation, set `deleteMissingCategoryValues`
  # to `true`.
  # Default value is `false`.
  deleteMissingCategoryValues: Boolean
  companyId: String
}

type BulkUploadCategoriesInvalidCategory {
  id: String
  name: String
  itemType: CategoryItemTypeEnum
  categoryValues: [BulkUploadCategoriesInvalidCategoryValue!]
}

type BulkUploadCategoriesInvalidCategoryValue {
  id: String
  name: String
}

type BulkUploadCategoriesInvalidCategoryWithErrorMessages {
  inputIndex: Int!
  inputCategory: BulkUploadCategoriesInvalidCategory!
  errorMessage: String!
}

type BulkUploadCategoriesPayload {
  # The array of successfully processed categories.
  categories: [Category!]

  # Any input category with an error will not be processed and will appear in the
  # `invalidCategoriesWithErrorMessages` array.
  # If all categories are valid, the `invalidCategoriesWithErrorMessages` array will be empty.
  invalidCategoriesWithErrorMessages: [BulkUploadCategoriesInvalidCategoryWithErrorMessages!]
}

input BulkUploadDietaryFlagsDietaryFlagInput {
  id: String
  name: String
  shouldShowOnNutritionLabel: Boolean
}

input BulkUploadDietaryFlagsInput {
  dietaryFlags: [BulkUploadDietaryFlagsDietaryFlagInput!]
}

type BulkUploadDietaryFlagsInvalidDietaryFlag {
  id: String
  name: String
  shouldShowOnNutritionLabel: Boolean
}

type BulkUploadDietaryFlagsInvalidDietaryFlagWithErrorMessages {
  inputIndex: Int!
  inputDietaryFlag: BulkUploadDietaryFlagsInvalidDietaryFlag!
  errorMessage: String!
}

type BulkUploadDietaryFlagsPayload {
  dietaryFlags: [DietaryFlag!]
  invalidDietaryFlagsWithErrorMessages: [BulkUploadDietaryFlagsInvalidDietaryFlagWithErrorMessages!]
}

scalar BulkUploadIngredientsCategoryValuesType

input BulkUploadIngredientsInput {
  ingredients: [BulkUploadIngredientsInputIngredient!]!
  companyId: String
}

input BulkUploadIngredientsInputIngredient {
  id: String
  name: String
  categoryValueNamesByCategoryName: BulkUploadIngredientsCategoryValuesType
  costUnit: UnitInput
  costCents: Float
  notes: String
  trimYieldPercent: Float
  unitConversions: [UnitConversionInput!]
  externalId: String
  externalName: String
  canonicalIngredientId: String
  canonicalIngredientName: String
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  dietaryFlagNames: [String!]
  nutritionalsQuantity: Float
  nutritionalsUnit: UnitInput
  shelfLifeDays: Float
}

type BulkUploadIngredientsPayload {
  ingredients: [Ingredient!]!
}

input BulkUploadMenusInput {
  menus: [InputMenuInput!]!
}

type BulkUploadMenusPayload {
  error: Error
  menus: [Menu]
}

input BulkUploadRecipeItemInput {
  recipeId: String!
  ingredientId: String
  subRecipeId: String
  quantity: Float
  unit: BulkUploadRecipeItemUnitInputType
  preparationNames: [String!]
}

input BulkUploadRecipeItemsInput {
  recipeItems: [BulkUploadRecipeItemInput!]!
  companyId: String
}

type BulkUploadRecipeItemsPayload {
  error: Error
  recipeItems: [RecipeItem!]
}

input BulkUploadRecipeItemUnitInputType {
  name: String!
}

input BulkUploadRecipesInput {
  recipes: [BulkUploadRecipesRecipeInput!]!
  companyId: String
}

type BulkUploadRecipesPayload {
  recipes: [Recipe!]!
  error: Error
}

input BulkUploadRecipesRecipeInput {
  id: String
  name: String
  description: String
  externalName: String
  isDish: Boolean
  totalYield: Float
  yieldUnit: UnitInput
  inventoryUnit: UnitInput
  priceCents: Float
  notes: String
  shortCode: String
  prepTime: Int
  conceptNames: [String!]
  recipeItems: [BulkUploadRecipesRecipeItemInput!]
  recipeInstructions: [RecipeInstructionInput!]
  categoryValueNamesByCategoryNameJSON: String
  unitConversions: [UnitConversionInput!]
  nutritionalsQuantity: Float
  nutritionalsUnit: UnitInput
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  pdcaas: Float
  shelfLifeDays: Float
  nutritionalsServingsPerContainer: Float
}

input BulkUploadRecipesRecipeItemInput {
  id: String
  position: Int
  quantity: Float
  unit: UnitInput
  quantityUnitStr: String
  ingredientId: String
  subRecipeId: String
  itemName: String
  itemType: BulkUploadRecipesRecipeItemItemTypeEnum
  preparationNames: [String]
}

enum BulkUploadRecipesRecipeItemItemTypeEnum {
  RECIPE
  INGREDIENT
}

input BulkUploadVendorItemIngredientsInput {
  vendorItemIngredientsJSON: String!
  companyId: String!
  locationId: String
}

type BulkUploadVendorItemIngredientsPayload {
  error: Error
  ingredients: [Ingredient!]
}

input BulkUploadVendorItemsInput {
  vendorItemsJSON: String!

  # DEPRECATED.  Mutation will act on company of authenticated user
  companyId: String
  shouldBiasCreate: Boolean
  isEdiRequest: Boolean
}

# DEPRECATED.  Please use BulkUpdateVendorItems instead
type BulkUploadVendorItemsPayload {
  numVendorItemsCreated: Int
  numVendorItemsUpdated: Int
  error: Error
  vendorItems: [VendorItem!]
    @deprecated(
      reason: "BulkUploadVendorItems mutation is being replaced by BulkUpdateVendorItems."
    )
  invalidItems: [InvalidItem!]
}

input BulkUpsertMenuInput {
  id: String

  # 'name' is required for new menus. If not provided, the menu will be ignored.
  name: String

  # ISO Date Format only, YYYY-MM-DD
  date: String
  conceptId: String
  conceptName: String
  locationId: String
  locationExternalId: String
  locationName: String
  categoryValueNamesByCategoryName: ImportCategoryValuesType
  menuItems: [BulkUpsertMenuItemInput!]
  isPerHead: Boolean
  headCount: Int
  manualTotalSalesValueCents: Float
}

input BulkUpsertMenuItemInput {
  id: String
  recipeId: String
  recipeName: String
  recipeShortCode: String
  isPerHead: Boolean
  perHeadFactor: Float
  volume: Float
  volumeSold: Float
  unit: UnitInput
  position: Int
  categoryValueNamesByCategoryName: ImportCategoryValuesType
  salesPriceCents: Int
}

input BulkUpsertMenusInput {
  menus: [BulkUpsertMenuInput!]!
  async: Boolean
}

type BulkUpsertMenusPayload {
  error: Error
  menus: [Menu]
  jobId: String
}

input BulkUpsertTransfersCatalogItemsInput {
  locationId: String!
  items: [UpsertTransfersCatalogItemInput!]!
}

type BulkUpsertTransfersCatalogItemsPayload {
  error: Error
  jobId: String
}

input BulkUpsertTransfersDestinationLocationsInput {
  locationId: String!
  destinations: [UpsertTransfersDestinationLocationInput!]!
}

type BulkUpsertTransfersDestinationLocationsPayload {
  error: Error
  jobId: String
}

# CalculatedNutritionals are computed nutritional values, prior to reconciliation with a manually set value. To find the value as it appears in the UI, use reconciledNutritionals.
type CalculatedNutritionals implements HasNutritionalFields {
  # The manually set amount of caloriesKCal. To find the quantity as it appears in the UI, use reconciledNutritionals.
  caloriesKCal: Float

  # The manually set amount of totalFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  totalFatG: Float

  # The manually set amount of saturatedFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  saturatedFatG: Float

  # The manually set amount of transFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  transFatG: Float

  # The manually set amount of cholesterolMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholesterolMg: Float

  # The manually set amount of sodiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sodiumMg: Float

  # The manually set amount of carbsG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  carbsG: Float

  # The manually set amount of fiberG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  fiberG: Float

  # The manually set amount of sugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sugarG: Float

  # The manually set amount of addedSugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  addedSugarG: Float

  # The manually set amount of proteinG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  proteinG: Float

  # The manually set amount of vitaminAMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminAMcg: Float

  # The manually set amount of vitaminB6Mg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB6Mg: Float

  # The manually set amount of vitaminB12Mcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB12Mcg: Float

  # The manually set amount of vitaminCMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminCMg: Float

  # The manually set amount of vitaminDMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminDMcg: Float

  # The manually set amount of vitaminEMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminEMg: Float

  # The manually set amount of vitaminKMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminKMcg: Float

  # The manually set amount of calciumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  calciumMg: Float

  # The manually set amount of ironMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  ironMg: Float

  # The manually set amount of thiaminMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  thiaminMg: Float

  # The manually set amount of riboflavinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  riboflavinMg: Float

  # The manually set amount of niacinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  niacinMg: Float

  # The manually set amount of folateMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  folateMcg: Float

  # The manually set amount of biotinMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  biotinMcg: Float

  # The manually set amount of pantothenicAcidMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  pantothenicAcidMg: Float

  # The manually set amount of phosphorusMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  phosphorusMg: Float

  # The manually set amount of iodineMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  iodineMcg: Float

  # The manually set amount of magnesiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  magnesiumMg: Float

  # The manually set amount of zincMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  zincMg: Float

  # The manually set amount of seleniumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  seleniumMcg: Float

  # The manually set amount of copperMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  copperMg: Float

  # The manually set amount of manganeseMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  manganeseMg: Float

  # The manually set amount of chromiumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chromiumMcg: Float

  # The manually set amount of molybdenumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  molybdenumMcg: Float

  # The manually set amount of chlorideMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chlorideMg: Float

  # The manually set amount of potassiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  potassiumMg: Float

  # The manually set amount of cholineMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholineMg: Float
  caloriesPercentDRV: Float
  totalFatPercentDRV: Float
  saturatedFatPercentDRV: Float

  # This field will always return null as there is no recommendation for daily intake
  transFatPercentDRV: Float
  cholesterolPercentDRV: Float
  sodiumPercentDRV: Float
  carbsPercentDRV: Float
  fiberPercentDRV: Float

  # This field will always return null as there is no recommendation for daily intake
  sugarPercentDRV: Float
  addedSugarPercentDRV: Float
  proteinPercentRDI: Float
  vitaminAPercentRDI: Float
  vitaminB6PercentRDI: Float
  vitaminB12PercentRDI: Float
  vitaminCPercentRDI: Float
  vitaminDPercentRDI: Float
  vitaminEPercentRDI: Float
  vitaminKPercentRDI: Float
  calciumPercentRDI: Float
  ironPercentRDI: Float
  thiaminPercentRDI: Float
  riboflavinPercentRDI: Float
  niacinPercentRDI: Float
  folatePercentRDI: Float
  biotinPercentRDI: Float
  pantothenicAcidPercentRDI: Float
  phosphorusPercentRDI: Float
  iodinePercentRDI: Float
  magnesiumPercentRDI: Float
  zincPercentRDI: Float
  seleniumPercentRDI: Float
  copperPercentRDI: Float
  manganesePercentRDI: Float
  chromiumPercentRDI: Float
  molybdenumPercentRDI: Float
  chloridePercentRDI: Float
  potassiumPercentRDI: Float
  cholinePercentRDI: Float
  itemWithErrors: [ItemWithErrors!]

  # A timestamp of when a change was last made to a recipe tree that could have effected the reconciledNutritionals cache. If the values returned by reconciledNutritionals are not from the cache, the result will be null.
  lastChangedAt: Date

  # A timestamp of when a change was last made to a recipe tree that could have effected the reconciledNutritionals cache. If the values returned by reconciledNutritionals are not from the cache, the result will be null.
  lastSyncedAt: Date
}

# The input required to make a cancelItem mutation
input CancelItemInput {
  eventDate: Date
  receivingItemId: String!
  expectedExpiresAt: Date
  quantity: Float!
  unitId: String!

  # If provided, must be a valid UUID.
  idempotenceKey: String
  reason: ReceivingItemCancelledReason!

  # Provide details about your reason.
  description: String
  invoiceNumber: String
}

input CandidateTransferOrderItemFilter {
  name: String
}

type CanonicalIngredient implements HasNutritionalFieldsAndQuantity {
  # The ID of an object
  id: ID!
  usdaId: Int
  name: String!
  brand: String
  groupName: String
  weightGrams: Float
  volumeQuantity: Float
  volumeUnit: String
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  createdAt: Date!
  updatedAt: Date!
  nutritionalsQuantity: Float
  nutritionalsUnit: Unit
  unitConversion: UnitConversion
}

type CanonicalUnit {
  id: String!
  name: String!
  aliases: [String!]!
  kind: CanonicalUnitKindEnum!
  system: CanonicalUnitSystemEnum!
}

enum CanonicalUnitKindEnum {
  VOLUME
  WEIGHT
  MISCELLANEOUS
}

enum CanonicalUnitSystemEnum {
  IMPERIAL
  METRIC
  MISCELLANEOUS
}

# A certain set of products
type Catalog {
  id: String!
  name: String!
  companyId: String!
  isGlobal: Boolean!
  autoAssignProducts: Boolean!
  catalogItemConnection(
    filters: CatalogItemConnectionFilters
    paginationOptions: CatalogItemPaginationOptions!
  ): CatalogItemConnection
  createdAt: String!
  updatedAt: String
  deletedAt: String
}

# A connectionType whos nodes are of type Catalog
type CatalogConnection {
  edges: [CatalogConnectionEdge!]!
  pageInfo: PageInfoType!
  totalCount: Int!
}

# An edge whos node is of type Catalog
type CatalogConnectionEdge {
  index: Int!
  node: Catalog!
}

# Filters for catalogs
input CatalogConnectionFilters {
  ids: [String!]
  name: String
}

# An item that belongs to a Catalog
type CatalogItem {
  id: String!
  companyId: String!
  catalogId: String!
  product: Product!
  costCents: Float
  createdAt: String!
  updatedAt: String
  deletedAt: String
}

# A connectionType whos nodes are of type CatalogItemConnection
type CatalogItemConnection {
  edges: [CatalogItemConnectionEdge!]!
  pageInfo: PageInfoType!
  totalCount: Int!
}

# An edge whos node is of type CatalogItem
type CatalogItemConnectionEdge {
  node: CatalogItem!
  index: Int!
}

# Filters for catalogItems
input CatalogItemConnectionFilters {
  ids: [String!]
  productName: String
  catalogIds: [String!]
  categoryValues: CategoriesFilter
}

# Options for paginating a CatalogItemConnection's edges
input CatalogItemPaginationOptions {
  first: Int!
  orderBy: SortFieldCatalogItemEnum!
  sortDirection: SortDirectionEnum!
  startIndex: Int!
}

# Options for paginating a CatalogConnection's edges
input CatalogPaginationOptions {
  first: Int!
  orderBy: SortFieldCatalogEnum!
  sortDirection: SortDirectionEnum!
  startIndex: Int!
}

# The filters for categories that will be part of the CatalogItemConnectionFilters.
# includeCategoryValueIds and excludeCategoryValueIds accept lists of Ids that will be considered and avoided respectivelly.
input CategoriesFilter {
  operator: CategoryFilterOperatorEnum!
  includeCategoryValueIds: [String!]
  excludeCategoryValueIds: [String!]
}

type Category {
  id: ID!
  companyId: String!
  hasPolicyAssociated: Boolean!
  itemType: CategoryItemTypeEnum!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  categoryValues: [CategoryValue!]!
}

# The operator that CategoriesFilter can be filtered by
enum CategoryFilterOperatorEnum {
  OR
  AND
}

input CategoryInput {
  id: String
  itemType: CategoryItemTypeEnum!
  name: String!
  companyId: String
  categoryValues: [CategoryValueInput]
}

enum CategoryItemTypeEnum {
  menuItem
  ingredient
  recipe
  menu
  vendorItem
  purchaseOrder
  order
  collection
}

type CategoryValue {
  id: ID!
  companyId: String!
  hasPolicyAssociated: Boolean!
  hasConstraintAssociated: Boolean!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  categoryId: String!
  category: Category!
  sortOrder: Int!
    @deprecated(reason: "no longer available, will always return 0")
  categoryValueItems: [CategoryValueItem!]!
    @deprecated(reason: "will be replaced with Connections")
}

# The CategoryValueConstraintItemInput contains the category value ID to be added to the constraint with the include flag.
input CategoryValueConstraintItemInput {
  categoryValueId: ID!
  include: Boolean!
}

# A stringified JSON object of type
# <categoryValueId> ::= String
# <expression>      ::=
#     { and: [<expression> | <categoryValueId>] }
#   | { or: [<expression> | <categoryValueId>] }
#   | { not: [<expression> | <categoryValueId>] }
#
# Examples of valid expressions:
# { and: [ "A", "B" ] } => A && B
# { and: [ "A", { or: [ "B", "C" ] } } => A && (B || C)
# { or: [ not: [ "A" ], "B" ] } => !A || B
# { not: [ { and: [ "A", "B" ] } ] } => !(A && B)
scalar CategoryValueIdFilterBooleanExpressionType

input CategoryValueInput {
  id: String
  name: String!
  categoryId: String
  companyId: String
}

type CategoryValueItem {
  # The ID of an object
  id: ID!
  itemId: String!
  itemType: CategoryItemTypeEnum!
  categoryValueId: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  categoryValue: CategoryValue
}

# A CategoryValuePredicate contains a list of category values defined in a category value constraint.
type CategoryValuePredicate {
  categoryValueItems: [CategoryValuePredicateItem!]!
}

# A CategoryValuePredicateItem represents the category value ID in the constraint with the include flag.
type CategoryValuePredicateItem {
  categoryValue: CategoryValue!
  include: Boolean!
}

type ClaimPolicyMapping {
  claimCode: String!
  policyId: String!
}

input ClaimPolicyMappingInput {
  claimCode: String!
  policyId: String!
}

type ClaimPolicyMappingPayload {
  claimCode: String!
  policyId: String!
}

# A collection is a set of products and/or sub-collections.
type Collection {
  id: String!
  name: String!
  externalName: String
  description: String
  headCount: Int!
  instructions: [CollectionInstruction!]
  categoryValues: [CategoryValue!]
  collectionItems: [CollectionItem!]
  isDish: Boolean!
  priceCents: Int
  costCents(locationId: String): Float
  costUnit: Unit!
  dietaryFlags(locationId: String): [DietaryFlag!]
  companyId: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

# A collection connection is a response from the collection connection viewer with information on the number of total items with the provided filter,
# the pagination applied and the listed collections on the page inside the edges.
type CollectionConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [CollectionConnectionEdge!]!
}

# A collection connection edge is an item inside an array from the collection connection edges, with an index and a specific collection inside the node.
type CollectionConnectionEdge {
  index: Int!
  node: Collection!
}

# A collection filter is a set of rules that can be applied to list collections based on a term on their ids, names or categories included or excluded.
input CollectionFilter {
  ids: [String!]
  name: String
  categoryValueIdsBooleanExpressionFilterJSON: CategoryValueIdFilterBooleanExpressionType
}

# A collection instruction is a set of instructions inside a collection.
type CollectionInstruction {
  id: String!
  text: String!
  position: Int!
  collectionId: String!
  companyId: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

# A collection item belongs to a collection and represents a relationship with a product or another collection as a component.
type CollectionItem {
  id: String!
  parentCollectionId: String!
  parentCollection: Collection!
  position: Int!
  unitId: String
  unit: Unit
  quantity: Float
  productId: String
  product: Product
  constraintId: String
  constraint: CollectionItemConstraint
  costCents(locationId: String): Float
  dietaryFlags(locationId: String): [DietaryFlag!]
  companyId: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

# A CollectionItemConstraint contains information about a constraint related to a collection item.
type CollectionItemConstraint {
  id: ID!
  name: String
  collectionItem: CollectionItem
  predicates: [CollectionItemPredicate!]
  companyId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

#  CollectionItemConstraintSolutionProducts.
type CollectionItemConstraintSolutionProducts {
  constraint: CollectionItemConstraint!
  solutionProducts: [Product!]
}

# A collection item optional list input is a set of information required to create a collection item with optional list input.
input CollectionItemOptionalListInput {
  name: String
  quantity: Int!
  products: [ID!]!
}

# A CollectionItemPredicate is a representation of a ProductPredicate.
union CollectionItemPredicate = ProductPredicate

# A collection item type can be a product or a collection.
enum CollectionItemType {
  product
}

# The collection order by enum lists the options available to order the collection list
enum CollectionOrderByEnum {
  id
  name
  createdAt
  updatedAt
}

# The collection pagination options are a set of parameters to define collection list pagination
input CollectionPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: CollectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type Company {
  id: ID!
  policies: [Policy!]!
  availablePolicies(filters: AvailablePoliciesFilter): [Policy!]!
  availablePoliciesConnection(
    paginationOptions: PoliciesPaginationOptionsInput
    filters: AvailablePoliciesFilter
  ): PolicyConnection!
  hasPolicyAssociatedToCategory(filter: PolicyAssociationFilter): Boolean!
  securityMappings: SecurityMappings
  invoiceApprovalRules: [InvoiceApprovalRule!]
  invoiceRules: [InvoiceRule!]
  job(id: String!): Job
  jobConnection(
    paginationOptions: JobPaginationOptions
    filters: JobFilter
  ): JobConnection!
  name: String!
  apiToken: String
  createdAt: Date!
  updatedAt: Date!
  locationConnection(
    filters: LocationConnectionFilter
    paginationOptions: PaginationOptions
  ): LocationConnection!
  hasProduction: Boolean
  hasReporting: Boolean
  hasCatereaseImporter: Boolean
  hasEvents: Boolean
  hasExternalRecipeName: Boolean
  hasConcepts: Boolean
  hasHACCP: Boolean
  hasMenuImporting: Boolean
  hasPerHeadMenus: Boolean
  hasRecipeShareableView: Boolean
  hasShelfLife: Boolean
  hasShortCode: Boolean
  hasMarketProIntegration: Boolean
  hasLocationGroups: Boolean
  hasMenuPricing: Boolean
  hasMenuSalesData: Boolean
  hasRecipePrices: Boolean
  hasVendorGroups: Boolean
  hasVendorItemImport: Boolean
  hasVendors: Boolean
  hasDietaryFlags: Boolean
  hasNutritionals: Boolean
  hasAdvancedInventory: Boolean
  hasInventory: Boolean
  hasPurchasing: Boolean
  hasOktaAuthN: Boolean
  hasTemplateExport: Boolean
  hasTemplateExportNew: Boolean
  hasTemplateExportDocx: Boolean
  hasCredits: Boolean
  hasInvoices: Boolean
  hasInvoicesDataMatching: Boolean
  hasMenuPlan: Boolean
  hasCollections: Boolean
  hasPolicies: Boolean
  hasProductionSchedule: Boolean
  hasAdvancedProductionSchedule: Boolean
  hasBasicProductionSchedule: Boolean
  hasBasicProductionExecution: Boolean
  hasTransferOrders: Boolean
  hasFilesManagement: Boolean
  hasNutritionalsVisualizations: Boolean
  hasTheoreticalConsumption: Boolean
  hasDietaryFlagLiveData: Boolean
  hasUsagesLiveData: Boolean
  hasLotTracking: Boolean
  hasPrintingService: Boolean
  hasSubLocations: Boolean
  hasMenuPlanner: Boolean
  hasRecipeVariations: Boolean
  tier: CompanyTierEnum
  status: CompanyStatusEnum
  marketSegment: CompanyMarketSegmentEnum
  usage: CompanyUsageEnum
  users: [User!]! @deprecated(reason: "will be replaced with Connections")
  user(userId: String!): User
  apiUsers: [User!]!
  ingredients: [Ingredient!]!
  recipes(
    limit: Int
    order: String

    # A JSON object conforming the the shape specified in http://docs.sequelizejs.com/en/latest/docs/querying/
    where: SequelizeJSON
    offset: Int
  ): [Recipe!]!
  locations: [Location!]!
  concepts: [Concept!]!
  categories(
    limit: Int
    order: String

    # A JSON object conforming the the shape specified in http://docs.sequelizejs.com/en/latest/docs/querying/
    where: SequelizeJSON
    offset: Int
  ): [Category!]!
  vendors: [Vendor!]!
  settings: CompanySettings!
  userConnection(
    paginationOptions: UserConnectionPaginationOptions
    filters: UserConnectionFilter
  ): UserConnection!
}

type CompanyErrorReportingSettings {
  showCostErrors: Boolean!
  showShortCodeErrors: Boolean!
  showExternalIdErrors: Boolean!
}

input CompanyInput {
  id: String
  name: String
  apiToken: String
  tier: CompanyTierEnum
  status: CompanyStatusEnum
  marketSegment: CompanyMarketSegmentEnum
  usage: CompanyUsageEnum
  hasInvoices: Boolean
  hasOktaAuthN: Boolean
  hasConcepts: Boolean
  hasPurchasing: Boolean
  hasVendors: Boolean
  hasMenuPricing: Boolean
  hasEvents: Boolean
  hasMenuImporting: Boolean
  hasMenuSalesData: Boolean
  hasInventory: Boolean
  hasShortCode: Boolean
  hasShelfLife: Boolean
  hasNutritionals: Boolean
  hasVendorGroups: Boolean
  hasRecipeVariations: Boolean
  hasRecipeShareableView: Boolean
  hasRecipePrices: Boolean
  hasPerHeadMenus: Boolean
  hasProduction: Boolean
  hasLocationGroups: Boolean
  hasDietaryFlags: Boolean
  hasTheoreticalConsumption: Boolean
  hasCatereaseImporter: Boolean
  hasHACCP: Boolean
  hasExternalRecipeName: Boolean
  hasAdvancedInventory: Boolean
  hasVendorItemImport: Boolean
  hasTemplateExport: Boolean
  hasTemplateExportNew: Boolean
  hasTemplateExportDocx: Boolean
  hasNutritionalsVisualizations: Boolean
  hasFilesManagement: Boolean
  hasCredits: Boolean
  hasTransferOrders: Boolean
  hasReporting: Boolean
  hasPolicies: Boolean
  hasProductionSchedule: Boolean
  hasMenuPlan: Boolean
  hasDietaryFlagLiveData: Boolean
  hasUsagesLiveData: Boolean
  hasCollections: Boolean
  hasLotTracking: Boolean
  hasPrintingService: Boolean
  hasInvoicesDataMatching: Boolean
  hasAdvancedProductionSchedule: Boolean
  hasBasicProductionSchedule: Boolean
  hasBasicProductionExecution: Boolean
  hasSubLocations: Boolean
  hasMenuPlanner: Boolean
  hasMarketProIntegration: Boolean
}

enum CompanyMarketSegmentEnum {
  CATERING
  EMERGING
  NON_COMMERCIAL
  NON_CORE
}

type CompanyMenuPlanSettings {
  menuPrimaryTagCategoryIds: [String]
  menuMealTypeCategoryId: String
  menuMealTypeCategoryValueIds: [String]
  recipeThemeCategoryIds: [String]
  recipeMealTypeCategoryIds: [String]
  recipeFoodTypeCategoryIds: [String]
}

type CompanyNutritionalLabelSettings {
  # PDCAAS (Protein Digestibility Corrected Amino Acid Score) is used to adjust the Protein DV% of a recipe to account for the quality of the protein
  pdcaas: Boolean!
  ingredientsList: Boolean!
  allergensList: Boolean!
  proteinDV: Boolean!
  horizontalNutritionLabel: Boolean!
}

type CompanySettings {
  exportPagePerRecipe: Boolean!
  horizontalNutritionLabel: Boolean!
  hasIngredientExternalName: Boolean!
  hasIngredientExternalId: Boolean!
  hasRecipeYieldPercent: Boolean!
  enabledNutrients: EnabledNutrients!
  enabledBulkUploadVendorItemUnitConversions: Boolean!
  enabledBulkUploadVendorItemUnitConversionsForEdi: Boolean!
  hasCompoundRecipeLabel: Boolean!
  hasCompoundIngredientLabel: Boolean!
  hasPreparations: Boolean!
  errorReporting: CompanyErrorReportingSettings!
  menuPlan: CompanyMenuPlanSettings!
    @deprecated(
      reason: "This is a temporary field and should not be relied upon for future use"
    )
  nutritionalLabel: CompanyNutritionalLabelSettings!
  glCode: Boolean!
}

enum CompanyStatusEnum {
  ACTIVE
  CANCELLED
}

enum CompanyTierEnum {
  SMB
  MID_MARKET
  ENTERPRISE
}

enum CompanyUsageEnum {
  DEMO
  TRIAL
  FREEMIUM
  PRODUCTION
  AMBASSADOR
  SUPPORT
  RESEARCH
}

# Input type for marking an invoice as completed. Contains a field id for the invoice to be marked as completed.
input CompleteInvoiceInput {
  id: String!
}

type Concept {
  id: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
}

input ConceptInput {
  id: String
  name: String!
  companyId: String
}

# A Constraint contains information about a constraint.
type Constraint {
  id: ID!
  resourceId: ID!
  resourceType: ConstraintResourceType!
  predicate: ConstraintPredicate!
  companyId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# The ConstraintConnection contains the result of the constraintConnection query.
type ConstraintConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ConstraintConnectionEdge!]!
}

# The ConstraintEdge contains the index and a node with the constraint in a constraintConnection query.
type ConstraintConnectionEdge {
  index: Int!
  node: Constraint!
}

# The ConstraintConnectionFilter contains the fields to filter the constraintConnection query.
input ConstraintConnectionFilters {
  ids: [ID!]
  resourceIds: [ID!]
}

# The ConstraintConnectionOrderByEnum contains the fields available to order the constraintConnection query.
enum ConstraintConnectionOrderByEnum {
  id
}

# The ConstraintPaginationOptions contains the fields to paginate the constraintConnection query.
input ConstraintPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: ConstraintConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

# A ConstraintPredicate is a representation of a constraint predicate.
union ConstraintPredicate =
    DietaryFlagPredicate
  | ProductPredicate
  | CategoryValuePredicate

# A ConstraintResourceType is an enum that represents the type of resource that a constraint is related to.
enum ConstraintResourceType {
  MenuCycle
  MenuPlan
  CollectionItem
}

enum CopyableEntitiesEnum {
  ingredients
  recipes
  vendors
}

input CopyEntitiesInput {
  sourceCompanyId: String!
  destinationCompanyId: String!
  entities: [CopyableEntitiesEnum!]!
  pageNumber: Int!
  pageSize: Int!
  prefix: String
  suffix: String
  addAffix: Boolean
}

type CopyEntitiesPayload {
  ingredients: CopyResult!
  recipes: CopyResult!
  vendors: CopyResult!
}

type CopyError {
  id: Int!
  name: String!
  message: String!
  entity: CopyableEntitiesEnum!
}

input CopyMenuInput {
  menuId: String
}

type CopyMenuPayload {
  menu: Menu
}

input CopyRecipeInput {
  id: String!
  versionId: String
}

type CopyRecipePayload {
  error: Error
  recipe: Recipe
}

type CopyResult {
  copied: Int!
  totalCount: Int!
  errors: [CopyError!]!
}

enum CostTypeEnum {
  expected
  actual
}

input CreateCatalogDestinationLocationInput {
  transfersCatalogId: String!
  locationId: String
  locationGroupId: String
}

type CreateCatalogDestinationLocationPayload {
  error: Error
  catalogDestinationLocation: TransfersCatalogDestinationLocation
}

# The CreateCategoryValueConstraintInput is a group of parameters required to create a constraint for category values through the createCategoryValueConstraint mutation.
input CreateCategoryValueConstraintInput {
  resourceId: ID!
  resourceType: ConstraintResourceType!
  categoryValueItems: [CategoryValueConstraintItemInput!]!
}

input CreateCategoryValueInput {
  categoryValue: CategoryValueInput
}

type CreateCategoryValuePayload {
  error: Error
  categoryValue: CategoryValue
}

input CreateChouxboxUserInput {
  id: String!
  companyId: String!
}

type CreateChouxboxUserPayload {
  user: User
  error: Error
}

# A create collection input is a set of information available to be defined on a collection creation.
input CreateCollectionInput {
  name: String!
  externalName: String
  description: String
  isDish: Boolean
  priceCents: Int
}

# A create collection instruction input is a set of information available to be defined on a collection instruction creation.
input CreateCollectionInstructionInput {
  collectionId: String!
  text: String!
  position: Int
}

# A create collection instruction payload is the result of a collection instruction creation, with an error or the collection instruction created.
type CreateCollectionInstructionPayload {
  error: Error
  instruction: CollectionInstruction
}

# A create collection item input is a set of information available to be defined on a collection component creation.
input CreateCollectionItemInput {
  collectionId: String!
  position: Int
  unitId: String
  quantity: Float
  itemId: String!
  itemType: CollectionItemType!
}

# A create collection item payload is the result of a collection component creation, with an error or the collection component created.
type CreateCollectionItemPayload {
  error: Error
  item: CollectionItem
}

# The CreateCollectionItemProductConstraintInput is a group of parameters required to create a constraint for a collection item through the createCollectionItemProductConstraint mutation.
input CreateCollectionItemProductConstraintInput {
  name: String
  collectionItemId: ID!
  quantity: Int!
  productIds: [ID!]!
}

# A create collection item with optional list input is a set of information available to be defined on a collection component with optional list creation.
input CreateCollectionItemWithOptionalListInput {
  collectionId: String!
  position: Int
  unitId: String
  quantity: Float
  constraint: CollectionItemOptionalListInput!
}

# A create collection payload is the result of a collection creation, with an error or the collection created.
type CreateCollectionPayload {
  error: Error
  collection: Collection
}

input CreateConceptInput {
  concept: ConceptInput!
}

type CreateConceptPayload {
  error: Error
  concept: Concept
}

input CreateCreditInput {
  vendorItemId: String!
  quantity: Float!
  unitId: String!
  locationId: String!
  costUnitId: String!
  costCents: Float!
  notes: String
  date: DateOnly
}

type CreateCreditPayload {
  error: Error
  credit: Credit
}

#  Input data about the cycleCount to be created.
input CreateCycleCountCycleCountInput {
  id: String
  companyId: String
  locationId: String!
  cycleCountTemplateId: String
  creatorId: String
  date: DateOnly
  ingredientIds: [String!]
  vendorIds: [String!]
  subLocationIds: [String!]
}

#  The cycleCount to be created.
input CreateCycleCountInput {
  cycleCount: CreateCycleCountCycleCountInput!
}

#  The cycleCountItem to be created.
input CreateCycleCountItemInput {
  cycleCountItem: CreateCycleCountItemItemInput!
}

#  Input data about the cycleCountItem to be created.
input CreateCycleCountItemItemInput {
  id: String
  cycleCountId: String
  recipeId: String
  ingredientId: String
  vendorItemId: String
  companyId: String
}

#  The created cycleCountItem or the error that occured when trying to create.
type CreateCycleCountItemPayload {
  error: Error
  cycleCountItems: [CycleCountItem]
}

#  The created cycleCount or the error that occured when trying to create.
type CreateCycleCountPayload {
  error: Error
  cycleCount: CycleCount
}

#  Input data about the cycleCountTemplate to be created.
input CreateCycleCountTemplateCycleCountTemplateInput {
  name: String!
  categoryValueIdBooleanExpression: CategoryValueIdFilterBooleanExpressionType
}

#  The cycleCountTemplate to be created.
input CreateCycleCountTemplateInput {
  cycleCountTemplate: CreateCycleCountTemplateCycleCountTemplateInput!
}

#  Input for create a new CycleCountTemplateItem.
input CreateCycleCountTemplateItemInput {
  cycleCountTemplateItem: CycleCountTemplateItemInput!
}

#  Contains the created CycleCountTemplateItem and an error field with any business logic errors.
type CreateCycleCountTemplateItemPayload {
  error: Error
  cycleCountTemplateItem: CycleCountTemplateItem
}

#  The created cycleCountTemplate or the error that occured when trying to create.
type CreateCycleCountTemplatePayload {
  error: Error
  cycleCountTemplate: CycleCountTemplate
}

input CreatedAtFilterInput {
  to: DateOnly
  from: DateOnly
}

# The CreateDietaryFlagConstraintInput is a group of parameters required to create a constraint for dietary flags through the createDietaryFlagConstraint mutation.
input CreateDietaryFlagConstraintInput {
  resourceId: ID!
  resourceType: ConstraintResourceType!
  dietaryFlagIds: [ID!]!
}

input CreateDietaryFlagDietaryFlagInput {
  name: String!
  shouldShowOnNutritionLabel: Boolean
}

input CreateDietaryFlagInput {
  dietaryFlag: CreateDietaryFlagDietaryFlagInput!
}

input CreateDietaryFlagItemInput {
  ingredientId: String
  vendorItemId: String
  dietaryFlagId: String!
}

type CreateDietaryFlagItemPayload {
  error: Error
  dietaryFlagItem: DietaryFlagItem
}

type CreateDietaryFlagPayload {
  error: Error
  dietaryFlag: DietaryFlag
}

# Returns the url to download the provided entity medias
type CreateDownloadUrlEntityMediasPayload {
  url: String
}

# Input to create multiple medias for an entity
input CreateEntityMediasInput {
  entityId: String!
  entityType: MediaEntityType!
  medias: [MediaInput!]!
}

# Returns the entity or an error object with message, but not both
type CreateEntityMediasPayload {
  entity: MediaEntity
  recipe: Recipe
  error: Error
}

input CreateEventEventInput {
  name: String!
}

input CreateEventInput {
  event: CreateEventEventInput!
}

type CreateEventPayload {
  event: Event
  error: Error
}

input CreateHaccpRuleInput {
  haccpRule: HaccpRuleInput!
}

type CreateHaccpRulePayload {
  error: Error
  haccpRule: HaccpRule
}

input CreateIngredientPreparationInput {
  ingredientPreparation: IngredientPreparationInput!
}

type CreateIngredientPreparationPayload {
  error: Error
  ingredientPreparation: IngredientPreparation
}

input CreateIngredientVendorItemInput {
  ingredientId: String!
  vendorItemId: String!
  locationId: String
}

# DEPRECATED. Will be replaced with bulkCreateIngredientsVendorItems
type CreateIngredientVendorItemPayload {
  error: Error
  ingredient: Ingredient
}

# Input type for creating an invoice approval rule. Contains fields like vendorID, locationID, and autoApprove.
input CreateInvoiceApprovalRuleInput {
  vendorId: String
  locationId: String
  autoApprove: Boolean!
}

# Payload type for the CreateInvoiceApprovalRule mutation. Contains a field invoiceApprovalRule which is of type InvoiceApprovalRule representing the newly created invoice approval rule.
type CreateInvoiceApprovalRulePayload {
  invoiceApprovalRule: InvoiceApprovalRule!
}

# Input type for creating a new invoice. Contains fields like invoiceNumber, invoiceDate, correlationID, shippingAddress, city, state, zipCode, companyID, vendorID, tax, locationID, extLocationId, currentStatus, notes, and source.
input CreateInvoiceInput {
  invoiceNumber: String!
  invoiceDate: String!
  correlationID: String
  shippingAddress: String
  city: String
  state: String
  zipCode: String
  companyID: String
  vendorID: String!
  tax: String
  locationID: String!
  extLocationId: String
  currentStatus: String
  notes: String
  source: String
}

# Input type for creating a new invoice item. Contains fields like invoiceId, quantityOrdered, purchasingUnit, sku, priceUnit, unitCostCents, name, description, vendorItemId, unitId, and ignored.
input CreateInvoiceItemInput {
  invoiceId: String!
  quantityOrdered: Float
  purchasingUnit: String
  sku: String
  priceUnit: String
  unitCostCents: Float
  name: String!
  description: String
  vendorItemId: String
  unitId: String
  ignored: Boolean
  glCode: String
}

# Payload type for the CreateInvoiceItem mutation. Contains a field item which is of type InvoiceItem representing the newly created invoice item.
type CreateInvoiceItemPayload {
  item: InvoiceItem!
}

# Payload type for the CreateInvoice mutation. Contains a field invoice which is of type Invoice representing the newly created invoice.
type CreateInvoicePayload {
  invoice: Invoice!
}

# The CreateInvoiceRuleInput is a set of information available to be defined on a invoice rule creation.
input CreateInvoiceRuleInput {
  action: InvoiceRuleActionEnum!
  locationId: String
  vendorId: String
}

# The CreateInvoiceRulePayload is the result of a invoice rule creation, with an error or the invoice rule created.
type CreateInvoiceRulePayload implements InvoiceRulePayload {
  error: Error
  invoiceRule: InvoiceRule
}

input CreateItemPurchaseOrderInput {
  purchaseOrderId: String!
  menuId: String
  recipeId: String
}

type CreateItemPurchaseOrderPayload {
  error: Error
  purchaseOrder: PurchaseOrder
}

# Returns the created labelToPrinter
type CreateLabelPrinterResult {
  printerId: ID
  labelIds: [ID]
  companyId: ID
  createdAt: String
  updatedAt: String
}

input CreateLocationGroupInput {
  locationGroup: LocationGroupInput!
}

input CreateLocationGroupLocationInput {
  locationGroupLocation: LocationGroupLocationInput!
}

type CreateLocationGroupLocationPayload {
  error: Error
  locationGroupLocation: LocationGroupLocation
}

type CreateLocationGroupPayload {
  error: Error
  locationGroup: LocationGroup
}

input CreateLocationGroupVendorGroupInput {
  locationGroupId: String!
  vendorGroupId: String!
}

type CreateLocationGroupVendorGroupPayload {
  locationGroupVendorGroup: LocationGroupVendorGroup
  error: Error
}

input CreateLocationInput {
  location: CreateLocationLocationInput!
}

input CreateLocationLocationInput {
  name: String!
  streetAddress: String
  city: String
  state: String
  zipCode: String
  type: String
  externalId: String
}

type CreateLocationPayload {
  error: Error
  location: Location
}

input CreateLocationVendorGroupInput {
  locationVendorGroup: LocationVendorGroupInput!
}

type CreateLocationVendorGroupPayload {
  locationVendorGroup: LocationVendorGroup
}

input CreateLocationVendorInput {
  locationVendor: LocationVendorInput!
}

type CreateLocationVendorPayload {
  locationVendor: LocationVendor
}

#  CreateMenuCycleEventGroupInput represents the parameters required to create a MenuCycleEventGroup.
input CreateMenuCycleEventGroupInput {
  menuCycleId: ID!
  name: String!
  position: PositiveInt
}

#  CreateMenuCycleEventInput represents the parameters required to create a MenuCycleEvent.
input CreateMenuCycleEventInput {
  menuCycleDayId: ID!
  menuCycleEventGroupId: ID
  headCount: PositiveInt!
  position: PositiveInt
}

#  CreateMenuCycleEventItemInput represents the parameters required to create a MenuCycleEventItem.
input CreateMenuCycleEventItemInput {
  menuCycleEventId: ID!
  menuCycleProductGroupId: ID
  productId: ID!
  unitId: ID
  quantity: PositiveDecimal
  isPerHead: Boolean
  position: PositiveInt
}

#  CreateMenuCycleInput represents the parameters required to create a MenuCycle.
input CreateMenuCycleInput {
  name: String!
  isPerHead: Boolean!
  lengthDays: PositiveInt!
  dailyHeadcount: PositiveInt!
  budgetCents: PositiveDecimal
}

#  CreateMenuCycleProductGroupInput represents the parameters required to create a MenuCycleProductGroup.
input CreateMenuCycleProductGroupInput {
  menuCycleEventGroupId: ID!
  name: String!
  position: PositiveInt
}

input CreateMenuItemInput {
  menuItem: MenuItemInput!
}

type CreateMenuItemPayload {
  error: Error
  menuItem: MenuItem
}

#  CreateMenuPlanEventGroupInput represents the parameters required to create a MenuPlanEventGroup.
input CreateMenuPlanEventGroupInput {
  menuPlanId: ID!
  name: String!
}

#  CreateMenuPlanEventInput represents the parameters required to update a MenuPlan.
input CreateMenuPlanEventInput {
  name: String
  notes: String
  conceptId: ID
  menuPlanDayId: ID!
  menuPlanEventGroupId: ID
  status: MenuPlanEventStatusEnum!
  headCount: PositiveInt!
}

#  CreateMenuPlanEventItemInput represents the parameters required to create a MenuPlanEventItem.
input CreateMenuPlanEventItemInput {
  quantity: PositiveDecimal!
  isPerHead: Boolean!
  menuPlanEventId: ID!
  menuPlanProductGroupId: ID
  productId: ID!
  unitId: ID
}

input CreateMenuPlanPOCInput {
  menuPlan: MenuPlanPOCInput!
}

type CreateMenuPlanPOCPayload {
  error: Error
  menuPlan: MenuPlanPOC
}

input CreateMenuPlanPOCTemplateItemInput {
  menuTemplateId: String!
  menuPlanId: String!
}

type CreateMenuPlanPOCTemplateItemPayload {
  error: Error
  menuPlanTemplateItem: MenuPlanPOCTemplateItem
}

#  CreateMenuPlanProductGroupInput represents the parameters required to create a MenuPlanProductGroup.
input CreateMenuPlanProductGroupInput {
  menuPlanEventGroupId: ID!
  name: String!
}

input CreateMenuTemplateInput {
  menuTemplate: MenuTemplateInput!
}

input CreateMenuTemplateItemInput {
  menuTemplateItem: MenuTemplateItemInput!
}

type CreateMenuTemplateItemPayload {
  error: Error
  menuTemplateItem: MenuTemplateItem
}

type CreateMenuTemplatePayload {
  error: Error
  menuTemplate: MenuTemplate
}

input CreateOrderCategoryInput {
  name: String!
  categoryValues: [CreateOrderCategoryValueCreateOrderCategoryInput!]
}

input CreateOrderCategoryValueCreateOrderCategoryInput {
  name: String!
}

input CreateOrderCategoryValueInput {
  categoryId: String!
  name: String!
}

input CreatePolicyDefinitionInput {
  policy: PolicyDefinitionInput!
}

type CreatePolicyDefinitionResponse {
  policy: Policy
  error: PolicyDefinitionError
}

input CreatePolicyInput {
  name: String!
  companyId: String!
  precedence: Int
  description: String
  statements: [StatementInput!]!
}

type CreatePolicyPayload {
  policy: Policy
}

input CreatePurchaseOrderItemInput {
  purchaseOrderId: String!
  purchaseOrderItem: CreatePurchaseOrderItemPurchaseOrderItemInput!
}

type CreatePurchaseOrderItemPayload {
  error: Error
  purchaseOrderItem: PurchaseOrderItem
}

input CreatePurchaseOrderItemPurchaseOrderItemInput {
  ingredientId: String
  vendorItemId: String
  quantity: Int
  unitId: String
  notes: String
}

input CreateReceivedItemAttributes {
  vendorItemId: String!
  quantity: Float!
  unitId: String!
  locationId: String!
  costUnitId: String
  costCents: Float
  purchaseOrderItemId: String
  receivedAt: Date
}

input CreateReceivedItemInput {
  item: CreateReceivedItemAttributes!
}

type CreateReceivedItemPayload {
  error: Error
  receivedItem: ReceivingItem
}

input CreateRecipeInstructionInput {
  recipeId: String
  recipeInstruction: RecipeInstructionInput
}

type CreateRecipeInstructionPayload {
  error: Error
  recipeInstruction: RecipeInstruction
}

input CreateRecipeItemInput {
  recipeId: String
  recipeItem: RecipeItemInput
}

type CreateRecipeItemPayload {
  error: Error
  originalRecipeItem: RecipeItem
}

input CreateRecipeItemPreparationInput {
  recipeItemPreparation: RecipeItemPreparationInput!
}

type CreateRecipeItemPreparationPayload {
  error: Error
  recipeItem: RecipeItem
}

# Returns the created recipeToLabel
type CreateRecipePrintLabelResult {
  recipeId: ID
  labelId: ID
  companyId: ID
  createdAt: String
  updatedAt: String
}

input CreateRecipesConceptsInput {
  recipeIds: [String!]!
  conceptIds: [String!]!
}

type CreateRecipesConceptsPayload {
  recipes: [Recipe!]!
}

input CreateRecipeShareableViewInput {
  recipeId: String!
  recipeView: CreateRecipeViewInput!
}

type CreateRecipeShareableViewPayload {
  recipe: Recipe
  error: Error
}

input CreateRecipeVariationInput {
  recipeVariation: RecipeInput!
}

type CreateRecipeVariationPayload {
  error: Error
  recipeVariation: Recipe
}

input CreateRecipeVariationRemovalInput {
  recipeVariationRemoval: RecipeVariationRemovalInput!
}

type CreateRecipeVariationRemovalPayload {
  recipeVariationRemoval: RecipeVariationRemoval
}

input CreateRecipeViewInput {
  name: String!
  settings: SequelizeJSON!
}

input CreateSendOrderInput {
  orderId: String!
  orderType: OrderTypeEnum!
  locationId: String!
  locationName: String!
  vendorId: String!
}

type CreateSendOrderPayload {
  error: Error
  id: String
}

input CreateSubLocationInput {
  name: String!
  locationId: String!
}

type CreateSubLocationPayload {
  subLocation: SubLocation
  error: Error
}

input CreateTransferOrderInput {
  transferOrder: CreateTransferOrderTransferOrderInput!
}

input CreateTransferOrderItemInput {
  transferOrderId: String!
  transferOrderItem: CreateTransferOrderItemTransferOrderItemInput!
}

type CreateTransferOrderItemPayload {
  error: Error
  transferOrderItem: TransferOrderItem
}

input CreateTransferOrderItemTransferOrderItemInput {
  ingredientId: String
  recipeId: String
  quantity: Float
  unitId: String
  notes: String
}

type CreateTransferOrderPayload {
  error: Error
  transferOrder: TransferOrder
}

input CreateTransferOrderTransferOrderInput {
  creatorId: String
  name: String
  destinationLocationId: String!
  conceptId: String
  sourceLocationId: String!
  menuIds: [String!]
  transferOrderItems: [TransferOrderItemInput!]
  deliveryDate: DateOnly
  notes: String
}

input CreateTransfersCatalogInput {
  name: String
  sourceLocationId: String!
  leadTimeDays: Int
  externalId: String
  deliveryDows: DeliveryDowInput
}

input CreateTransfersCatalogItemInput {
  name: String
  transfersCatalogId: String!
  recipeId: String
  ingredientId: String
  leadTimeDays: Int
  priceCents: Float
  externalId: String
  primaryUnitId: String
  barcode: String
  sku: String
}

type CreateTransfersCatalogItemPayload {
  error: Error
  transfersCatalogItem: TransfersCatalogItemType
}

type CreateTransfersCatalogPayload {
  error: Error
  transfersCatalog: TransfersCatalogType
}

input CreateUnitConversionInput {
  unitConversion: CreateUnitConversionUnitConversionInput!
}

type CreateUnitConversionPayload {
  error: Error
  unitConversion: UnitConversion
}

input CreateUnitConversionUnitConversionInput {
  fromQuantity: Float!
  toQuantity: Float!
  ingredientId: String
  recipeId: String
  vendorItemId: String
  fromUnit: UnitInput
  fromUnitId: String
  toUnit: UnitInput
  toUnitId: String
}

input CreateVendorGroupInput {
  vendorGroup: VendorGroupInput!
}

type CreateVendorGroupPayload {
  error: Error
  vendorGroup: VendorGroup
}

input CreateVendorGroupVendorInput {
  vendorGroupVendor: VendorGroupVendorInput!
}

type CreateVendorGroupVendorPayload {
  error: Error
  vendorGroupVendor: VendorGroupVendor
}

input CreateViewStateInput {
  viewState: ViewStateInput!
}

type CreateViewStatePayload {
  error: Error
  viewState: ViewState
}

type Credit {
  id: String!
  vendorItem: VendorItem!
  costCents: Float
  quantity: Float
  unit: Unit
  costUnit: Unit
  notes: String
  createdAt: Date
  date: DateOnly
}

type Credits {
  location: Location!
  vendors: [Vendor!]!
  items: [Credit!]!
}

#  A manual count of the items that are on-hand in your inventory
type CycleCount {
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  locationId: String!
  location: Location!
  date: DateOnly
  status: CycleCountStatusEnumType!
  cycleCountTemplateId: String
  cycleCountTemplate: CycleCountTemplate
  name: String!
  creatorId: String
  creator: User!
  submitter: User
  submittedAt: Date
  vendors: [Vendor!]!
  subLocations: [SubLocation!]!
  cycleCountItems: [CycleCountItem!]!
    @deprecated(reason: "will be replaced with Connections")

  # Returns they cycle count items for the cycle count, sorted by position.
  cycleCountItemConnection(
    paginationOptions: CycleCountItemConnectionPaginationOptions
  ): CycleCountItemConnection!
}

# Filter for CycleCount date
input CycleCountDateFilterInput {
  to: DateOnly
  from: DateOnly
}

#  CycleCountItem represents the data related to a item during a CycleCount process.
type CycleCountItem {
  id: ID!
  primaryQuantity: Float
  primaryUnit: Unit
  secondaryQuantity: Float
  secondaryUnit: Unit
  position: Int
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  cycleCountId: ID
  recipeId: ID
  ingredientId: ID
  vendorItemId: ID
  companyId: ID!
  ingredient: Ingredient
  vendorItem: VendorItem
  recipe: Recipe
  totalCostCents: Float
  costCents: Float
  costUnit: Unit
  subLocation: SubLocation
  primaryQuantityUnitValues(includeAll: Boolean): [UnitValue!]!
  units: [Unit!]!
}

# Information on the total number of items with the provided filter,
# the pagination applied,
# and the listed cycleCountItems on the page inside the edges.
type CycleCountItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [CycleCountItemConnectionEdge!]!
}

#  The cycleCountItem and its index
type CycleCountItemConnectionEdge {
  index: Int!
  node: CycleCountItem!
}

#  Pagination options.
input CycleCountItemConnectionPaginationOptions {
  startIndex: Int
  first: Int
}

#  CycleCounts don't affect your inventory on-hand levels until they are submitted.
enum CycleCountStatusEnumType {
  IN_PROGRESS
  SUBMITTED
}

# A template that can be re-used many times to create multiple cycleCounts.
# CycleCountTemplateItems can be automatically added to a CycleCountTemplate by using the categoryValueIdBooleanExpression field.
type CycleCountTemplate {
  id: ID!
  name: String!

  # If categoryValueIdBooleanExpression is not null, a cycleCountTemplateItem will be automatically added
  # for any ingredient or recipe matching the categoryValueIdBooleanExpression
  categoryValueIdBooleanExpression: CategoryValueIdFilterBooleanExpressionType
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  cycleCountTemplateItems: [CycleCountTemplateItem!]!
}

# Items on a CycleCountTemplate that will be used to create CycleCountItems when a CycleCount is created using the CycleCountTemplateId.
type CycleCountTemplateItem {
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  cycleCountTemplateId: ID!
  position: Int!
  ingredient: Ingredient
  ingredientId: String
  recipe: Recipe
  recipeId: String
}

#  Input data for create a new CycleCountTemplateItem.
input CycleCountTemplateItemInput {
  id: String
  cycleCountTemplateId: String
  recipeId: String
  ingredientId: String
}

# A Date is a type that represents a datetime
scalar Date

#  DateFilter.
input DateFilter {
  from: Date
  to: Date
}

#  A Date without timestamp with the format 'YYYY-MM-DD'
scalar DateOnly

# A DateTime is a type that represents a datetime
scalar DateTime

#  Decimal.
scalar Decimal

input DeleteAllRecipeInstructionsInput {
  recipeId: String!
}

type DeleteAllRecipeInstructionsPayload {
  recipe: Recipe
  error: Error
}

input DeleteCatalogDestinationLocationInput {
  id: String!
}

type DeleteCatalogDestinationLocationPayload {
  error: Error
  catalogDestinationLocation: TransfersCatalogDestinationLocation
}

input DeleteCategoryInput {
  id: String
}

type DeleteCategoryPayload {
  error: Error
  category: Category
}

# The DeleteCategoryValueConstraintInput contains the constraint ID required to delete a constraint for a category value through the deleteCategoryValueConstraint mutation.
input DeleteCategoryValueConstraintInput {
  constraintId: ID!
}

input DeleteCategoryValueInput {
  id: String!
}

type DeleteCategoryValuePayload {
  error: Error
  categoryValue: CategoryValue
}

# A delete collection input contains the id of the collection to be deleted.
input DeleteCollectionInput {
  id: String!
}

# A delete collection instruction input is a set of information required to delete a collection instruction.
input DeleteCollectionInstructionInput {
  id: String!
}

# A delete collection instruction payload is the result of a collection instruction delete, with an error or the collection instruction deleted.
type DeleteCollectionInstructionPayload {
  error: Error
  instruction: CollectionInstruction
}

# A delete collection item input contains the id of the collection component to be deleted.
input DeleteCollectionItemInput {
  id: String!
}

# A delete collection component payload is the result of a collection component delete, with an error or the collection component deleted.
type DeleteCollectionItemPayload {
  error: Error
  item: CollectionItem
}

# The DeleteCollectionItemProductConstraintInput contains the constraint ID required to delete a constraint for a collection item through the deleteCollectionItemProductConstraint mutation.
input DeleteCollectionItemProductConstraintInput {
  constraintId: ID!
}

# A delete collection payload is the result of a collection delete, with an error or the collection deleted.
type DeleteCollectionPayload {
  error: Error
  collection: Collection
}

input DeleteConceptInput {
  id: String!
}

type DeleteConceptPayload {
  error: Error
  concept: Concept
}

#  The id of the cycleCount to be deleted.
input DeleteCycleCountInput {
  id: String!
}

#  The id of the cycleCountItem to be deleted.
input DeleteCycleCountItemInput {
  id: String!
}

#  The deleted cycleCountItem or the error that occured when trying to delete.
type DeleteCycleCountItemPayload {
  error: Error
  cycleCountItem: CycleCountItem
}

#  The deleted cycleCount or the error that occured when trying to delete.
type DeleteCycleCountPayload {
  error: Error
  cycleCount: CycleCount
}

#  The id of the cycleCountTemplate to be deleted.
input DeleteCycleCountTemplateInput {
  id: String!
}

#  Input for delete a CycleCountTemplateItem.
input DeleteCycleCountTemplateItemInput {
  id: String!
}

#  Contains the deleted CycleCountTemplateItem and an error field with any business logic errors.
type DeleteCycleCountTemplateItemPayload {
  error: Error
  cycleCountTemplateItem: CycleCountTemplateItem
}

#  The deleted cycleCountTemplate or the error that occured when trying to delete.
type DeleteCycleCountTemplatePayload {
  error: Error
  cycleCountTemplate: CycleCountTemplate
}

# The DeleteDietaryFlagConstraintInput contains the constraint ID required to delete a constraint for a dietary flag through the deleteDietaryFlagConstraint mutation.
input DeleteDietaryFlagConstraintInput {
  constraintId: ID!
}

input DeleteDietaryFlagInput {
  id: String!
}

input DeleteDietaryFlagItemInput {
  dietaryFlagId: String!
  ingredientId: String
  vendorItemId: String
}

type DeleteDietaryFlagItemPayload {
  error: Error
  dietaryFlagItem: DietaryFlagItem
}

type DeleteDietaryFlagPayload {
  error: Error
  dietaryFlag: DietaryFlag
}

# The DeletedInvoiceRulePayload is the result of a invoice rule deleted, with an error.
type DeletedInvoiceRulePayload {
  error: Error
}

# Input to delete multiple medias for an entity
input DeleteEntityMediasInput {
  entityId: String!
  entityMediasIds: [ID!]!
  entityType: MediaEntityType!
}

# Returns the entity or an error object with message, but not both
type DeleteEntityMediasPayload {
  entity: MediaEntity
  recipe: Recipe
  error: Error
}

input DeleteEventInput {
  id: String!
}

type DeleteEventPayload {
  error: Error
  event: Event
}

input DeleteHaccpRuleInput {
  id: String!
}

type DeleteHaccpRulePayload {
  error: Error
  haccpRule: HaccpRule
}

input DeleteIngredientInput {
  id: String
}

type DeleteIngredientPayload {
  error: Error
  ingredient: Ingredient
}

input DeleteIngredientVendorItemInput {
  ingredientId: String!
  vendorItemId: String!
  locationId: String
}

# DEPRECATED. Will be replaced with bulkDeleteIngredientsVendorItems
type DeleteIngredientVendorItemPayload {
  error: Error
  ingredient: Ingredient
}

# Input type for deleting an invoice approval rule. Contains a field id for the invoice approval rule to be deleted.
input DeleteInvoiceApprovalRuleInput {
  id: String!
}

# Input type for deleting an invoice item. Contains a field id for the invoice item to be deleted.
input DeleteInvoiceItemInput {
  id: String!
}

# The DeleteInvoiceRuleInput is a set of information available to be defined on a invoice rule deletion.
input DeleteInvoiceRuleInput {
  id: ID!
}

input DeleteItemPurchaseOrderInput {
  purchaseOrderId: String!
  menuId: String
  recipeId: String
}

type DeleteItemPurchaseOrderPayload {
  error: Error
  purchaseOrder: PurchaseOrder
}

# Returns the deleted labelToPrinter
type DeleteLabelPrinterResult {
  printerId: ID
  labelIds: [ID]
}

input DeleteLocationGroupInput {
  id: String!
}

input DeleteLocationGroupLocationInput {
  locationGroupLocation: LocationGroupLocationInput
}

type DeleteLocationGroupLocationPayload {
  error: Error
  locationGroupLocation: LocationGroupLocation
}

type DeleteLocationGroupPayload {
  error: Error
  locationGroup: LocationGroup
}

input DeleteLocationGroupVendorGroupInput {
  locationGroupId: String!
  vendorGroupId: String!
}

type DeleteLocationGroupVendorGroupPayload {
  locationGroupVendorGroup: LocationGroupVendorGroup
  error: Error
}

input DeleteLocationInput {
  id: String!
}

type DeleteLocationPayload {
  error: Error
  location: Location
}

input DeleteLocationVendorGroupInput {
  locationVendorGroup: LocationVendorGroupInput!
}

type DeleteLocationVendorGroupPayload {
  error: Error
  locationVendorGroup: LocationVendorGroup
}

input DeleteLocationVendorInput {
  locationVendor: LocationVendorInput!
}

type DeleteLocationVendorPayload {
  error: Error
  locationVendor: LocationVendor
}

input DeleteMenuInput {
  id: String
}

input DeleteMenuItemInput {
  id: String!
}

type DeleteMenuItemPayload {
  error: Error
  menuItem: MenuItem
}

type DeleteMenuPayload {
  error: Error
  menu: Menu
}

input DeleteMenuPlanPOCInput {
  id: String!
}

type DeleteMenuPlanPOCPayload {
  error: Error
  menuTemplate: MenuPlanPOC
}

input DeleteMenuPlanPOCTemplateItemInput {
  id: String!
}

type DeleteMenuPlanPOCTemplateItemPayload {
  error: Error
  menuPlanTemplateItem: MenuPlanPOCTemplateItem
}

input DeleteMenuTemplateInput {
  id: String!
}

input DeleteMenuTemplateItemInput {
  id: String!
}

type DeleteMenuTemplateItemPayload {
  error: Error
  menuTemplateItem: MenuTemplateItem
}

type DeleteMenuTemplatePayload {
  error: Error
  menuTemplate: MenuTemplate
}

input DeleteOrderCategoryInput {
  id: String!
}

input DeleteOrderCategoryValueInput {
  id: String!
}

input DeletePolicyDefinitionInput {
  id: String!
}

type DeletePolicyDefinitionResponse {
  error: PolicyDefinitionError
  policy: Policy
}

input DeletePolicyInput {
  id: String!
}

type DeletePolicyPayload {
  policy: Policy
}

input DeletePreparationInput {
  id: String
}

type DeletePreparationPayload {
  error: Error
  preparation: Preparation
}

input DeletePurchaseOrderInput {
  id: String
}

input DeletePurchaseOrderItemInput {
  id: String!
}

type DeletePurchaseOrderItemPayload {
  error: Error
  purchaseOrderItem: PurchaseOrderItem
}

type DeletePurchaseOrderPayload {
  error: Error
  purchaseOrder: PurchaseOrder
}

input DeleteRecipeInput {
  id: String
}

input DeleteRecipeInstructionInput {
  recipeInstructionId: String
}

type DeleteRecipeInstructionPayload {
  error: Error
  recipeInstruction: RecipeInstruction
}

input DeleteRecipeItemInput {
  recipeItemId: String!
}

type DeleteRecipeItemPayload {
  error: Error
  originalRecipeItem: RecipeItem
}

input DeleteRecipeItemPreparationInput {
  recipeItemPreparationId: String!
}

type DeleteRecipeItemPreparationPayload {
  error: Error
  recipeItem: RecipeItem
}

type DeleteRecipePayload {
  error: Error
  recipe: Recipe
}

# Returns the deleted recipeToLabel
type DeleteRecipePrintLabelResult {
  recipeId: ID
  labelIds: [ID]
}

input DeleteRecipesConceptsInput {
  recipeIds: [String]!
  deleteAll: Boolean
  conceptIds: [String]
}

type DeleteRecipesConceptsPayload {
  recipes: [Recipe]!
}

input DeleteRecipeShareableViewInput {
  recipeId: String!
  recipeViewId: String!
}

type DeleteRecipeShareableViewPayload {
  recipe: Recipe
  error: Error
}

input DeleteRecipeVariationInput {
  recipeVariationId: String!
}

type DeleteRecipeVariationPayload {
  error: Error
  recipeVariation: Recipe
}

input DeleteRecipeVariationRemovalInput {
  recipeVariationRemovalId: String!
}

type DeleteRecipeVariationRemovalPayload {
  recipeVariationRemoval: RecipeVariationRemoval
}

input DeleteRecipeVariationRuleInput {
  recipeVariationRuleId: String!
}

type DeleteRecipeVariationRulePayload {
  error: Error
  recipeVariationRule: RecipeVariationRule
}

input DeleteSubLocationInput {
  id: String!
}

type DeleteSubLocationPayload {
  subLocation: SubLocation
  error: Error
}

input DeleteTransferOrderInput {
  id: String!
}

input DeleteTransferOrderItemInput {
  id: String!
}

type DeleteTransferOrderItemPayload {
  error: Error
  transferOrderItem: TransferOrderItem
}

type DeleteTransferOrderPayload {
  error: Error
  transferOrder: TransferOrder
}

input DeleteTransfersCatalogInput {
  id: String!
}

input DeleteTransfersCatalogItemInput {
  id: String!
}

type DeleteTransfersCatalogItemPayload {
  error: Error
  transfersCatalogItem: TransfersCatalogItemType
}

type DeleteTransfersCatalogPayload {
  error: Error
  transfersCatalog: TransfersCatalogType
}

input DeleteUnitConversionInput {
  id: String!
}

type DeleteUnitConversionPayload {
  error: Error
  unitConversion: UnitConversion
}

input DeleteUnitInput {
  id: String!
}

type DeleteUnitPayload {
  error: Error
  unit: Unit
}

input DeleteUserInput {
  id: String
}

type DeleteUserPayload {
  error: Error
  user: User
}

input DeleteVendorGroupInput {
  id: String!
}

type DeleteVendorGroupPayload {
  error: Error
  vendorGroup: VendorGroup
}

input DeleteVendorGroupVendorInput {
  vendorGroupVendor: VendorGroupVendorInput
}

type DeleteVendorGroupVendorPayload {
  error: Error
  vendorGroupVendor: VendorGroupVendor
}

input DeleteVendorInput {
  id: String
}

input DeleteVendorItemsInput {
  ids: [String!]!
}

type DeleteVendorItemsPayload {
  vendorItems: [VendorItem!]!
}

type DeleteVendorPayload {
  error: Error
  vendor: Vendor
}

input DeleteViewStateInput {
  id: String!
}

type DeleteViewStatePayload {
  error: Error
  viewState: ViewState
}

input DeliveryDateFilterInput {
  to: DateOnly
  from: DateOnly
  includeEmpty: Boolean
}

input DeliveryDowInput {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
}

type DeliveryDowType {
  monday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
  thursday: Boolean!
  friday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
}

type DietaryFlag {
  # The ID of an object
  id: ID!
  hasConstraintAssociated: Boolean!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  dietaryFlagItems: [DietaryFlagItem!]!
    @deprecated(reason: "will be replaced with Connections")
  isCanonical: Boolean! @deprecated(reason: "will be removed")
  shouldShowOnNutritionLabel: Boolean!
}

type DietaryFlagItem {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  dietaryFlagId: String!
  ingredientId: String
  ingredient: Ingredient
  vendorItemId: String
  vendorItem: VendorItem
  dietaryFlag: DietaryFlag!
}

# A DietaryFlagPredicate contains a list of dietary flags defined in a dietary flag constraint.
type DietaryFlagPredicate {
  dietaryFlags: [DietaryFlag!]!
}

# A stringified JSON object of type
# <dietaryFlagsValueId> ::= String
# <expression>      ::=
#     { and: [<expression> | <dietaryFlagsValueId>] }
#   | { or: [<expression> | <dietaryFlagsValueId>] }
#   | { not: [<expression> | <dietaryFlagsValueId>] }
#
# Examples of valid expressions:
# { and: [ "A", "B" ] } => A && B
# { and: [ "A", { or: [ "B", "C" ] } } => A && (B || C)
# { or: [ not: [ "A" ], "B" ] } => !A || B
# { not: [ { and: [ "A", "B" ] } ] } => !(A && B)
scalar DietaryFlagsIdFilterBooleanExpressionType

type DietaryFlagWithUsage {
  # A timestamp of when a change was last made to a recipe tree that could have effected the dietaryFlagsWithUsages cache. If the values returned by dietaryFlagsWithUsages are not from the cache, the result will be null.
  lastChangedAt: Date

  # A timestamp of when the cache of dietaryFlagsWithUsages was last updated. If the values returned by dietaryFlagsWithUsages are not from the cache, the result will be null.
  lastSyncedAt: Date
  dietaryFlag: DietaryFlag!
  usages: [IngredientWithUsages!]!
    @deprecated(reason: "Use ingredientsWithUsages instead")
  ingredientsWithUsages: [IngredientWithUsages!]!
}

# Input type for marking an invoice as a draft. Contains a field id for the invoice to be marked as draft.
input DraftInvoiceInput {
  id: String!
}

type DraftOrder {
  id: ID!
  menus: [Menu!]!
  menuLocation: Location
  menuPlans: [MenuPlan!]!
  menuPlanLocation: Location
  vendor: Vendor
  concept: Concept
  destinationLocation: Location!
  deliveryDate: DateOnly
  draftOrderItems: [DraftOrderItem!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
}

type DraftOrderItem {
  id: ID!
  draftOrder: DraftOrder!
  draftOrderId: String!
  ingredient: Ingredient
  vendorItem: VendorItem
  requiredQuantity: Float
  requiredUnit: Unit
  requiredPurchaseableQuantity: Float
  requiredPurchaseableUnit: Unit
  calculatedOrderQuantity: Float
  calculatedOrderUnit: Unit
  usages: [DraftOrderItemUsage!]!
  canAllUsagesBeScaled: Boolean!
}

type DraftOrderItemUsage {
  id: ID!
  menuItemId: String
  eventItemId: String
  untrimmedQuantity: Float
  untrimmedUnit: Unit
  quantity: Float
  unit: Unit
  breadcrumbRecipes: [BreadcrumbRecipe!]!
  conversionError: String
}

type DraftOrdersConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [DraftOrdersConnectionEdge!]!
}

type DraftOrdersConnectionEdge {
  index: Int!
  node: DraftOrder!
}

input DraftOrdersConnectionFilters {
  createdBy: String
  ids: [String!]
}

enum DraftOrdersConnectionOrderBy {
  Id
  CreatedAt
}

input DraftOrdersConnectionPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: DraftOrdersConnectionOrderBy
}

type EnabledNutrients {
  caloriesKCal: Boolean!
  totalFatG: Boolean!
  saturatedFatG: Boolean!
  transFatG: Boolean!
  cholesterolMg: Boolean!
  sodiumMg: Boolean!
  carbsG: Boolean!
  fiberG: Boolean!
  sugarG: Boolean!
  addedSugarG: Boolean!
  proteinG: Boolean!
  vitaminAMcg: Boolean!
  vitaminB6Mg: Boolean!
  vitaminB12Mcg: Boolean!
  vitaminCMg: Boolean!
  vitaminDMcg: Boolean!
  vitaminEMg: Boolean!
  vitaminKMcg: Boolean!
  calciumMg: Boolean!
  ironMg: Boolean!
  thiaminMg: Boolean!
  riboflavinMg: Boolean!
  niacinMg: Boolean!
  folateMcg: Boolean!
  biotinMcg: Boolean!
  pantothenicAcidMg: Boolean!
  phosphorusMg: Boolean!
  iodineMcg: Boolean!
  magnesiumMg: Boolean!
  zincMg: Boolean!
  seleniumMcg: Boolean!
  copperMg: Boolean!
  manganeseMg: Boolean!
  chromiumMcg: Boolean!
  molybdenumMcg: Boolean!
  chlorideMg: Boolean!
  potassiumMg: Boolean!
  cholineMg: Boolean!
}

# The attributes of media associated with an entity
type EntityMedia {
  id: ID!
  mediaId: ID!
  altText: String
  caption: String
  company: Company!
  createdAt: Date!
  createdBy: String!
  deletedAt: Date
  deletedBy: String
  description: String
  position: Int!
  sourceUrl: String
  storageKey: String
  title: String
  type: String!
  updatedAt: Date!
  updatedBy: String!
}

# An Error is a type that represents an error message
type Error {
  message: String
}

type Event {
  id: String!
  name: String!
  description: String
  locationName: String
  locationStreetAddress: String
  locationCity: String
  locationState: String
  locationZip: String
  startDate: Date
  endDate: Date
  headCount: Int
  menus: [Menu]
  deletedAt: String
  candidateMenus(nameQuery: String): [Menu!]!
}

input ExportTransfersCatalogItemsInput {
  locationId: String!
}

type ExportTransfersCatalogItemsPayload {
  error: Error
  jobId: String
}

# FieldParsingPossibilityInput represents field parsing input from user.
input FieldParsingPossibilityInput {
  # field is related to some column name from the original file
  field: String!

  # if ignore is true, the code will discard this column from the final file
  ignore: Boolean!

  # target is how the code will map the field from original file to the final file
  target: String

  # multipleTargets allow user to set some entities as example for the algorithm
  multipleTargets: [MultipleTargetInput!]
}

# FieldParsingPossibilityResponse represents the reponse for set fields.
type FieldParsingPossibilityResponse {
  jobId: String!
  numberFieldsSet: Int!
}

# Files include all the media separated by type for an entity
type Files {
  documents: [EntityMedia!]!
  photos: [EntityMedia!]!
  videos: [EntityMedia!]!
}

# The outcome when a FinishedGood is created
type FinishedGood {
  id: String!
  name: String!
  recipeId: String!
  recipeName: String!
  productionExecutionId: String!
  productionScheduleId: String!
  productionTaskId: String!
  companyId: String!
  location: Location!
  expectedProductionDate: String!
  productionDate: String!
  taskFinishedDate: String!
  unit: Unit!
  quantityProduced: Float!
  internalLotId: String
  barCode: String
  expirationDate: String
  onHand: FinishedGoodOnHand
  picklist: [ProductionPickListType]
  isRoot: Boolean!
  nutritionalInfo: NutritionalInfo
}

input FinishedGoodId {
  id: String!
}

# OnHand Unit/Quantity/Cost of a FinishedGood
type FinishedGoodOnHand {
  onHandUnitId: String!
  onHandUnitName: String!
  onHandUnitQuantity: Float!
  onHandUnitCost: Float!
}

# The finished goods order by enum lists the options available to order the finished goods list
enum FinishedGoodOrderByEnum {
  id
  productionScheduleId
}

# A finished goods connection is a response from the finished goods connection viewer with information on the number of total items with the provided filter,
# the pagination applied and the listed finished goods on the page inside the edges.
type FinishedGoods {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [FinishedGoodsEdge!]!
}

# A FinishedGoods connection edge is an item inside an array from the FinishedGoods connection edges, with an index and a specific FinishedGood inside the node.
type FinishedGoodsEdge {
  index: Int!
  node: FinishedGood!
}

# A FinishedGoods Filter is a set of rules that can be applied to list FinishedGoods.
input FinishedGoodsFilter {
  ids: [String!]

  # Task ids created inside of a plan
  productionExecutionTaskIds: [String!]

  # Plan id
  productionExecutionIds: [String!]

  # Schedule id that originally generated the plan
  productionScheduleIds: [String!]
  recipeIds: [String!]
}

# The finished goods order by enum lists the options available to order the finished goods list
enum FinishedGoodsOrderByEnum {
  id
}

# The finished goods pagination options are a set of parameters to define FinishedGoods list pagination
input FinishedGoodsPaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: FinishedGoodOrderByEnum!
  sortDirection: SortDirectionEnum!
}

union FoodCostCentsError =
    FoodCostCentsMissingUnitConversionError
  | FoodCostCentsMissingCostError
  | FoodCostCentsMissingQuantityError

type FoodCostCentsMissingCostError {
  ingredient: Ingredient
  recipe: Recipe
}

type FoodCostCentsMissingQuantityError {
  unit: Unit
  quantity: Float
}

type FoodCostCentsMissingUnitConversionError {
  fromUnit: Unit
  toUnit: Unit
}

input ForcePendingInventoryTasksProcessInput {
  locationId: String!
}

type ForcePendingInventoryTasksProcessPayload {
  error: Error
}

input GenerateShortCodeForRecipeInput {
  id: String!
}

type GenerateShortCodeForRecipePayload {
  recipe: Recipe
}

input GrantApiAccessMutationInput {
  companyId: String!
}

type GrantApiAccessMutationPayload {
  company: Company
}

type HaccpRule {
  # The ID of an object
  id: ID!
  name: String!
  description: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
}

input HaccpRuleInput {
  id: String
  name: String!
  description: String!
  companyId: String
}

interface HasNutritionalFields {
  # The manually set amount of caloriesKCal. To find the quantity as it appears in the UI, use reconciledNutritionals.
  caloriesKCal: Float

  # The manually set amount of totalFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  totalFatG: Float

  # The manually set amount of saturatedFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  saturatedFatG: Float

  # The manually set amount of transFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  transFatG: Float

  # The manually set amount of cholesterolMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholesterolMg: Float

  # The manually set amount of sodiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sodiumMg: Float

  # The manually set amount of carbsG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  carbsG: Float

  # The manually set amount of fiberG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  fiberG: Float

  # The manually set amount of sugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sugarG: Float

  # The manually set amount of addedSugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  addedSugarG: Float

  # The manually set amount of proteinG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  proteinG: Float

  # The manually set amount of vitaminAMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminAMcg: Float

  # The manually set amount of vitaminB6Mg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB6Mg: Float

  # The manually set amount of vitaminB12Mcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB12Mcg: Float

  # The manually set amount of vitaminCMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminCMg: Float

  # The manually set amount of vitaminDMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminDMcg: Float

  # The manually set amount of vitaminEMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminEMg: Float

  # The manually set amount of vitaminKMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminKMcg: Float

  # The manually set amount of calciumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  calciumMg: Float

  # The manually set amount of ironMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  ironMg: Float

  # The manually set amount of thiaminMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  thiaminMg: Float

  # The manually set amount of riboflavinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  riboflavinMg: Float

  # The manually set amount of niacinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  niacinMg: Float

  # The manually set amount of folateMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  folateMcg: Float

  # The manually set amount of biotinMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  biotinMcg: Float

  # The manually set amount of pantothenicAcidMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  pantothenicAcidMg: Float

  # The manually set amount of phosphorusMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  phosphorusMg: Float

  # The manually set amount of iodineMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  iodineMcg: Float

  # The manually set amount of magnesiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  magnesiumMg: Float

  # The manually set amount of zincMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  zincMg: Float

  # The manually set amount of seleniumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  seleniumMcg: Float

  # The manually set amount of copperMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  copperMg: Float

  # The manually set amount of manganeseMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  manganeseMg: Float

  # The manually set amount of chromiumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chromiumMcg: Float

  # The manually set amount of molybdenumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  molybdenumMcg: Float

  # The manually set amount of chlorideMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chlorideMg: Float

  # The manually set amount of potassiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  potassiumMg: Float

  # The manually set amount of cholineMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholineMg: Float
}

interface HasNutritionalFieldsAndQuantity {
  # The manually set amount of caloriesKCal. To find the quantity as it appears in the UI, use reconciledNutritionals.
  caloriesKCal: Float

  # The manually set amount of totalFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  totalFatG: Float

  # The manually set amount of saturatedFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  saturatedFatG: Float

  # The manually set amount of transFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  transFatG: Float

  # The manually set amount of cholesterolMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholesterolMg: Float

  # The manually set amount of sodiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sodiumMg: Float

  # The manually set amount of carbsG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  carbsG: Float

  # The manually set amount of fiberG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  fiberG: Float

  # The manually set amount of sugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sugarG: Float

  # The manually set amount of addedSugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  addedSugarG: Float

  # The manually set amount of proteinG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  proteinG: Float

  # The manually set amount of vitaminAMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminAMcg: Float

  # The manually set amount of vitaminB6Mg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB6Mg: Float

  # The manually set amount of vitaminB12Mcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB12Mcg: Float

  # The manually set amount of vitaminCMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminCMg: Float

  # The manually set amount of vitaminDMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminDMcg: Float

  # The manually set amount of vitaminEMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminEMg: Float

  # The manually set amount of vitaminKMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminKMcg: Float

  # The manually set amount of calciumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  calciumMg: Float

  # The manually set amount of ironMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  ironMg: Float

  # The manually set amount of thiaminMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  thiaminMg: Float

  # The manually set amount of riboflavinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  riboflavinMg: Float

  # The manually set amount of niacinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  niacinMg: Float

  # The manually set amount of folateMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  folateMcg: Float

  # The manually set amount of biotinMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  biotinMcg: Float

  # The manually set amount of pantothenicAcidMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  pantothenicAcidMg: Float

  # The manually set amount of phosphorusMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  phosphorusMg: Float

  # The manually set amount of iodineMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  iodineMcg: Float

  # The manually set amount of magnesiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  magnesiumMg: Float

  # The manually set amount of zincMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  zincMg: Float

  # The manually set amount of seleniumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  seleniumMcg: Float

  # The manually set amount of copperMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  copperMg: Float

  # The manually set amount of manganeseMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  manganeseMg: Float

  # The manually set amount of chromiumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chromiumMcg: Float

  # The manually set amount of molybdenumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  molybdenumMcg: Float

  # The manually set amount of chlorideMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chlorideMg: Float

  # The manually set amount of potassiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  potassiumMg: Float

  # The manually set amount of cholineMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholineMg: Float
  nutritionalsQuantity: Float
  nutritionalsUnit: Unit
}

#  HighlightMenuCycleEventItemsDay.
type HighlightMenuCycleEventItemsDay {
  dayId: ID!
  ingredients: [HighlightMenuCycleEventItemsIngredient!]!
}

#  HighlightMenuCycleEventItemsIngredient.
type HighlightMenuCycleEventItemsIngredient {
  ingredient: Ingredient!
  menuCycleEventItemIds: [ID!]!
}

#  HighlightMenuCycleEventItemsWeek.
type HighlightMenuCycleEventItemsWeek {
  week: Int!
  days: [HighlightMenuCycleEventItemsDay!]!
}

#  HighlightMenuPlanEventItemsDay.
type HighlightMenuPlanEventItemsDay {
  dayId: ID!
  ingredients: [HighlightMenuPlanEventItemsIngredient!]!
}

#  HighlightMenuPlanEventItemsIngredient.
type HighlightMenuPlanEventItemsIngredient {
  ingredient: Ingredient!
  menuPlanEventItemIds: [ID!]!
}

#  HighlightMenuPlanEventItemsWeek.
type HighlightMenuPlanEventItemsWeek {
  week: Int!
  days: [HighlightMenuPlanEventItemsDay!]!
}

# A stringified JSON object of type
# <globalId> ::= String
# <expression>      ::=
#     { and: [<expression> | <globalId>] }
#   | { or: [<expression> | <globalId>] }
#   | { not: [<expression> | <globalId>] }
#
# Examples of valid expressions:
# { and: [ "A", "B" ] } => A && B
# { and: [ "A", { or: [ "B", "C" ] } } => A && (B || C)
# { or: [ not: [ "A" ], "B" ] } => !A || B
# { not: [ { and: [ "A", "B" ] } ] } => !(A && B)
scalar IdsFilterBooleanExpressionType

# Arrays of categoryValue names keyed by their category name
scalar ImportCategoryValuesType

type Ingredient implements MediaEntity & HasNutritionalFieldsAndQuantity {
  id: ID!
  files: Files!
  name: String!
  externalId: String
  costCents(locationId: String): Float
  notes: String
  costUnitDeprecated: String
  allowedUnits: [String]
  trimYieldPercent: Float
  shelfLifeDays: Float
  nutritionalsQuantity: Float
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  externalName: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  canonicalIngredientId: String
  companyId: String
  creatorId: String
  costUnit(locationId: String): Unit
  nutritionalsUnit: Unit
  inventoryUnit: Unit
  costSourceVendorItem(locationId: String): VendorItem
  unitConversions: [UnitConversion!]!
  derivedUnitConversions(locationId: String): [UnitConversion!]!
  recipeItems: [RecipeItem!]!
  dietaryFlags: [DietaryFlag!]!
  usagesCount: Int!
  units: [Unit!]!
  ingredientPreparations: [IngredientPreparation!]!
    @deprecated(reason: "will be replaced with Connections")
  categoryValues: [CategoryValue!]!
  canonicalIngredient: CanonicalIngredient
  vendorItems(
    limit: Int
    order: String
    offset: Int
    locationId: String
    vendorId: String
    vendorIds: [String]
  ): [VendorItem!]!
  label: String!
  preparationsWithUsages: [PreparationWithUsages!]!
  locationVendorItems(locationIds: [String!]): [VendorItemLocation!]!
  costCentsUnitValues(includeAll: Boolean, locationId: String): [UnitValue!]!
  caloriesPercentDRV: Float
  totalFatPercentDRV: Float
  saturatedFatPercentDRV: Float
  transFatPercentDRV: Float
  cholesterolPercentDRV: Float
  sodiumPercentDRV: Float
  carbsPercentDRV: Float
  fiberPercentDRV: Float
  sugarPercentDRV: Float
  addedSugarPercentDRV: Float
  proteinPercentRDI: Float
  vitaminAPercentRDI: Float
  vitaminB6PercentRDI: Float
  vitaminB12PercentRDI: Float
  vitaminCPercentRDI: Float
  vitaminDPercentRDI: Float
  vitaminEPercentRDI: Float
  vitaminKPercentRDI: Float
  calciumPercentRDI: Float
  ironPercentRDI: Float
  thiaminPercentRDI: Float
  riboflavinPercentRDI: Float
  niacinPercentRDI: Float
  folatePercentRDI: Float
  biotinPercentRDI: Float
  pantothenicAcidPercentRDI: Float
  phosphorusPercentRDI: Float
  iodinePercentRDI: Float
  magnesiumPercentRDI: Float
  zincPercentRDI: Float
  seleniumPercentRDI: Float
  copperPercentRDI: Float
  manganesePercentRDI: Float
  chromiumPercentRDI: Float
  molybdenumPercentRDI: Float
  chloridePercentRDI: Float
  potassiumPercentRDI: Float
  cholinePercentRDI: Float

  # An ingredient's reconciled nutritional value will be equal to the highest priority vendor item's reconciled nutritional value, if the vendor item has at least one non-null nutritional value. If it does not, the ingredient's manually set nutritional value will be used. If that does not not exist, the associated canonical ingredient's nutritional value will be used. If that does not exist, the value will be null.
  #
  # IF(vendor item has >= 1 non-null reconciled nutritional value) THEN {vendor item reconciled nutritional value}
  #
  # ELSE IF({manually set nutritional value}!=0) THEN {manually set nutritional value}
  #
  # ELSE IF({canonical ingredient nutritional value}!=0) THEN {canonical ingredient nutritional value}
  #
  # ELSE null
  reconciledNutritionals(locationId: String): ReconciledNutritionValues!
  reconciledDietaryFlags(locationId: String): [ReconciledDietaryFlag!]!
}

type IngredientConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [IngredientConnectionEdge!]!
}

type IngredientConnectionEdge {
  index: Int!
  node: Ingredient!
}

input IngredientConnectionFilter {
  id: [String!]
  isUnused: Boolean
  isMissingCost: Boolean
  isMissingCanonicalIngredient: Boolean
  missingCostAt: MissingCostEnum
  categoryValueIdsBooleanExpressionFilterJSON: CategoryValueIdFilterBooleanExpressionType
  dietaryFlagIdsBooleanExpressionFilter: IdsFilterBooleanExpressionType
  reconciledDietaryFlagIdsBooleanExpressionFilter: IdsFilterBooleanExpressionType
  name: String
}

input IngredientIdVendorItemIds {
  ingredientId: String!
  vendorItemIds: [String!]!
}

input IngredientInput {
  id: String
  name: String
  externalId: String
  costCents: Float
  notes: String
  costUnitDeprecated: String
  allowedUnits: [String!]
  trimYieldPercent: Float
  shelfLifeDays: Float
  vendorItemIds: [String!]
  nutritionalsQuantity: Float
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  externalName: String
  canonicalIngredientId: String
  companyId: String
  creatorId: String
  costUnit: UnitInput
  inventoryUnit: UnitInput
  nutritionalsUnit: UnitInput
  ingredientPreparations: [IngredientPreparationInput!]
}

type IngredientLocation {
  ingredient: Ingredient!
  locations: [Location!]!
}

type IngredientPreparation {
  # The ID of an object
  id: ID!
  trimYieldPercent: Float
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  ingredientId: String
  preparationId: String
  ingredient: Ingredient!
  preparation: Preparation!
}

input IngredientPreparationInput {
  trimYieldPercent: Float
  deletedAt: Date
  id: String
  preparationId: String
  ingredientId: String
}

type IngredientUsageWarning {
  type: UsageWarning!
  usages: [RecipeUsage!]!
}

type IngredientWithUsages {
  # A timestamp of when a change was last made to a recipe tree that could have effected the ingredientWithUsages cache. If the values returned by ingredientWithUsages are not from the cache, the result will be null.
  lastChangedAt: Date

  # A timestamp of when the cache of ingredientWithUsages was last updated. If the values returned by ingredientWithUsages are not from the cache, the result will be null.
  lastSyncedAt: Date
  ingredient: Ingredient!
  usages: [RecipeUsage!]!
  unit: Unit
  costCents: Float
  costCentsUnitValues(includeAll: Boolean): [UnitValue!]!
  totalUntrimmedQuantity: Float
  totalUntrimmedQuantityUnitValues(includeAll: Boolean): [UnitValue!]!
  totalCostCents: Float
  totalQuantity: Float
  totalQuantityUnitValues(includeAll: Boolean): [UnitValue!]!
  warnings: [IngredientUsageWarning!]!
}

input InputMenuInput {
  id: String

  # `name` is required for new menus. If not provided, the menu will be ignored.
  name: String

  # ISO Date Format only, YYYY-MM-DD
  date: String
  conceptId: String
  locationId: String
  locationName: String
  locationExternalId: String
  categoryValueNamesByCategoryName: ImportCategoryValuesType
  menuItems: [InputMenuItemInput!]
  isPerHead: Boolean
  headCount: Int
  manualTotalSalesValueCents: Float
}

input InputMenuItemInput {
  id: String
  recipeId: String
  recipeName: String
  recipeShortCode: String
  isPerHead: Boolean
  perHeadFactor: Float

  # This field should not be used for new implementations, please use `volumeFloat` instead.
  # It has the wrong type (should be Float) and will be removed and then re-added with the correct type in the future.
  volume: String

  # This field is a correction to the wrong-typed field `volume`.
  # Please use this field for new implementations while we migrate the incorrect field to this type.
  volumeFloat: Float
  volumeSold: Float
  unit: UnitInput

  # This field should not be used for new implementations, please use `positionInt` instead.
  # It has the wrong type (should be Int) and will be removed and then re-added with the correct type in the future.
  position: String

  # This field is a correction to the wrong-typed field `position`.
  # Please use this field for new implementations while we migrate the incorrect field to this type.
  positionInt: Int
  categoryValueNamesByCategoryName: ImportCategoryValuesType

  # This field should not be used for new implementations, please use `salesPriceCentsInt` instead.
  # It has the wrong type (should be Int) and will be removed and then re-added with the correct type in the future.
  salesPriceCents: String

  # This field is a correction to the wrong-typed field `salesPriceCents`.
  # Please use this field for new implementations while we migrate the incorrect field to this type.
  salesPriceCentsInt: Int
}

type InvalidItem {
  name: String
  sku: String
  costUnit: InvalidItemUnit
  reasonInvalid: String!
}

type InvalidItemUnit {
  name: String!
}

type InventoryItem {
  id: String!
  location: Location!
  entity: VendorItem!
  onHand: InventoryItemOnHand!
  suspensionInfo: InventoryItemSuspensionInfo
  activity(
    paginationOptions: PaginationOptions!
  ): InventoryItemActivityConnection!
}

type InventoryItemActivity {
  id: String!
  type: InventoryItemActivityType!
  source: InventoryItemActivitySource
  change: InventoryItemActivityChange!
  occurredAt: Date!
}

type InventoryItemActivityChange {
  quantity: Float!
  type: InventoryItemActivityChangeType!
  unit: Unit!
}

enum InventoryItemActivityChangeType {
  Increase
  Decrease
}

type InventoryItemActivityConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [InventoryItemActivityConnectionEdge!]!
}

type InventoryItemActivityConnectionEdge {
  index: Int!
  node: InventoryItemActivity!
}

union InventoryItemActivitySource =
    PurchaseOrder
  | CycleCount
  | SubLocationItem
  | SubLocation

enum InventoryItemActivityType {
  Receiving
  CycleCount
  Sales
  Other
  Migration
  SubLocationItemDeletion
  SubLocationDeletion
}

input InventoryItemIdParts {
  entityType: String!
  entityId: String!
  locationId: String!
}

type InventoryItemOnHand {
  unit: Unit
  quantity: Float!
  costCents: Float
}

type InventoryItemSuspensionInfo {
  taskId: String!
  suspendedAt: Date!
  unitConversion: InventoryItemSuspensionUnitConversion!
}

type InventoryItemSuspensionUnitConversion {
  fromUnit: Unit!
  toUnit: Unit!
}

# Represents an invoice and its details, including relationships with Vendor, and InvoiceAction.
type Invoice {
  id: String!
  invoiceDate: String!
  invoiceNumber: String!
  locationId: String!
  extLocationId: String!
  shippingAddress: String!
  city: String!
  state: String!
  zipCode: String!
  vendorId: String
  companyId: String!
  totalCostCents: Float!
  tax: String!
  totalItems: Int!
  notes: String
  currentStatus: String!
  createdAt: String!
  updatedAt: String
  approvedAt: String
  source: String!
  extVendorName: String
  vendorSuggestions: [InvoiceSuggestion]!
  vendor: Vendor
  actions: [InvoiceAction]!
  original: OriginalInvoice
}

# Represents an invoice action with fields like id, name, startedAt, finishedAt, and successful.
type InvoiceAction {
  id: String!
  name: InvoiceActionName!
  startedAt: String!
  finishedAt: String
  successful: Boolean
}

# Enum representing different invoice action names.
enum InvoiceActionName {
  UpdateVendorItemsCosts
  AdhocReceiving
}

# Represents an invoice approval rule with fields like id, companyId, vendorId, locationId, autoApprove, createdAt, and updatedAt.
type InvoiceApprovalRule {
  id: String!
  companyId: String!
  vendorId: String
  vendor: Vendor
  locationId: String
  location: Location
  autoApprove: Boolean!
  createdAt: String!
  updatedAt: String!
  deletedAt: String
}

# Input for filtering invoice change connections
input InvoiceChangeConnectionFilter {
  invoiceId: String!
}

# Input for invoice changes pagination options
input InvoiceChangePaginationOptions {
  startIndex: Int
  first: Int
}

# Represents a paginated list of invoices, including totalCount, pageInfo, and a list of invoice edges.
type InvoiceConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [InvoiceConnectionEdge!]!
}

# Represents an edge in the invoice connection, containing an index and a node (Invoice).
type InvoiceConnectionEdge {
  index: Int!
  node: Invoice!
}

# Input for filtering invoice connections based on criteria like createdAt, currentStatus, invoiceNumber, etc.
input InvoiceConnectionFilter {
  createdAtFrom: String
  createdAtUntil: String
  currentStatus: [StatusEnum!]
  invoiceNumber: String
  issueDateFrom: String
  issueDateUntil: String
  locationId: [String!]
  modifiedAtFrom: String
  modifiedAtUntil: String
  vendorId: [String!]
}

# Represents a change in an invoice or in any of its items
type InvoiceDataChange {
  id: String!
  entity: InvoiceDataChangeEntity!
  entityId: String!
  field: String!
  previousValue: String
  newValue: String!
  author: User!
  createdAt: String!
}

# Represents the entity associated with an invoice change: the invoice itself or one of its items
union InvoiceDataChangeEntity = Invoice | InvoiceItem

# Represents an invoice item and its details, including relationships with Unit and VendorItem.
type InvoiceItem {
  id: String!
  invoiceId: String!
  quantityOrdered: Float!
  purchasingUnit: String!
  sku: String!
  priceUnit: String!
  costCents: Float
  unitCostCents: Float
  name: String!
  createdAt: String!
  vendorItem: VendorItem
  unit: Unit
  vendorItemSuggestions: [InvoiceItemSuggestion]!
  unitSuggestions: [InvoiceItemSuggestion]!
  ignored: Boolean!
  original: OriginalInvoiceItem
  glCode: String
}

# Represents a paginated list of invoice items, including totalCount, pageInfo, and a list of invoice item edges.
type InvoiceItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [InvoiceItemConnectionEdge!]!
}

# Represents an edge in the invoice item connection, containing an index and a node (InvoiceItem).
type InvoiceItemConnectionEdge {
  index: Int!
  node: InvoiceItem!
}

# Input for filtering invoice item connections based on criteria like invoiceId.
input InvoiceItemConnectionFilter {
  invoiceId: String!
}

# Input for the pagination options, including startIndex, first (limit), sortDirection, and orderBy.
input InvoiceItemPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: SortFieldInvoiceItemEnum
}

# Represents suggestions related to invoice items, containing id, entityId, and entityName.
type InvoiceItemSuggestion {
  id: String!
  entityId: String!
  entityName: String!
}

# Input for the pagination options, including startIndex, first (limit), sortDirection, and orderBy.
input InvoicePaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: SortFieldInvoiceEnum
}

# An invoice rule is a set of rules actions based on the companyId, vendorId and locationId.
type InvoiceRule {
  id: String!
  companyId: String!
  vendorId: String
  vendor: Vendor
  locationId: String
  location: Location
  action: String
  userId: String
  user: User
  createdAt: String!
  updatedAt: String
  deletedAt: String
}

# The InvoiceRuleActionEnum define the enum for Invoice Rule Action field, used on create or update.
enum InvoiceRuleActionEnum {
  AutoReceive
  AutoUpdateCosts
}

# An invoice rule connection is a response from the invoice rule connection viewer with information on the number of total items with the provided filter, the pagination applied and the listed invoices rules on the page inside the edges.
type InvoiceRuleConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [InvoiceRuleConnectionEdge!]!
}

# An invoice rule connection edge is an item inside an array from the invoice rule connection edges, with an index and a specific invoice rule inside the node.
type InvoiceRuleConnectionEdge {
  index: Int!
  node: InvoiceRule!
}

# An invoice rule filter is a set of rules that can be applied to list invoice rules based on a term on their vendorId or locationId.
input InvoiceRuleConnectionFilters {
  vendorId: String
  locationId: String
}

# The invoice rule pagination options are a set of parameters to define invoice rule list pagination.
input InvoiceRuleConnectionPaginationOptions {
  first: Int
  orderBy: SortFieldInvoiceRuleEnum
  sortDirection: SortDirectionEnum
  startIndex: Int
}

# The InvoiceRulePayload is the interface with basic returning payload for every action type.
interface InvoiceRulePayload {
  invoiceRule: InvoiceRule
}

# Represents suggestions related to invoices, containing id, entityId, and entityName.
type InvoiceSuggestion {
  id: String!
  entityId: String!
  entityName: String!
}

# Date must be ISO Date string. Example: '2022-01-11T15:10:47.175Z'
scalar ISODate

type ItemWithErrors {
  item: NutritionalItemUnion!
  usages: [RecipeUsage!]
  errors: [NutritionalErrorUnion!]!
}

type Job {
  id: String!
  companyId: String!
  userId: String!
  name: String!
  status: Status!
  startedAt: Date
  endedAt: Date
  body: JSONType
  bodySchema: JSONType
  number: Int
  createdAt: Date!
  updatedAt: Date
  deletedAt: Date
}

type JobConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [JobConnectionEdge!]!
}

type JobConnectionEdge {
  index: Int!
  node: Job!
}

enum JobConnectionOrderByEnum {
  createdAt
  userId
  status
}

input JobFilter {
  status: [String!]
  createdAt: CreatedAtFilterInput
  userId: String
  name: String
}

input JobPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: JobConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

# JSON represents a object in js.
scalar JSON

# The `JSON` scalar type represents raw JSON as values.
scalar JSONType

# Dimension of a label
type LabelDimension {
  width: Float
  height: Float
  unit: String
}

# The input data for an individual job when requesting multiple printing jobs via PrintLabels
input LabelInputType {
  labelID: ID!
  entityID: ID!
  quantity: Int
  additionalData: AdditionalPrintLabelDataType
}

enum LabelType {
  VERTICAL
  HORIZONTAL
}

# Variable of a label
type LabelVariable {
  name: String!
  description: String!
}

type Location {
  id: ID!
  name: String!
  streetAddress: String
  city: String
  state: String
  zipCode: String
  type: String
  billingTier: String
  externalId: String
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String
  vendors: [Vendor!]!
  vendorGroups: [VendorGroup!]!
  derivedVendors: [Vendor!]!
  locationGroups: [LocationGroup!]!
  subLocations: [SubLocation!]!
  defaultSubLocation: SubLocation!
  transfersCatalogItem(id: String!): TransfersCatalogItemType
  transfersCatalogItemsConnection(
    filterOptions: TransfersCatalogConnectionFilter
    paginationOptions: TransfersCatalogItemsPaginationOptions
  ): TransfersCatalogItemsConnection
  transfersCatalog: TransfersCatalogType
}

type LocationConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [LocationConnectionEdge!]!
}

type LocationConnectionEdge {
  index: Int!
  node: Location!
}

input LocationConnectionFilter {
  id: [String!]
  name: String
  externalId: [String!]
}

type LocationGroup {
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  locations: [Location!]!
  locationGroupLocations: [LocationGroupLocation!]!
  vendorGroups: [VendorGroup!]!
  id: ID!
}

input LocationGroupInput {
  id: String
  name: String!
  companyId: String
}

type LocationGroupLocation {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  locationId: String
  locationGroupId: String
  locationGroup: LocationGroup
  location: Location
}

input LocationGroupLocationInput {
  id: String
  locationId: String!
  locationGroupId: String!
}

type LocationGroupVendorGroup {
  id: ID!
  locationGroupId: String!
  vendorGroupId: String!
  locationGroup: LocationGroup!
  vendorGroup: VendorGroup!
}

type LocationMapping {
  venueCode: String!
  locationId: String!
}

input LocationMappingInput {
  venueCode: String!
  locationId: String!
}

type LocationMappingPayload {
  venueCode: String!
  locationId: String!
}

type LocationVendor {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  locationId: String
  vendorId: String
  vendor: Vendor
  location: Location
}

type LocationVendorGroup {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  locationId: String
  vendorGroupId: String
  vendorGroup: VendorGroup
  location: Location
}

input LocationVendorGroupInput {
  id: String
  locationId: String
  vendorGroupId: String
}

input LocationVendorInput {
  id: String
  locationId: String
  vendorId: String
}

# Long represents a int64 number
scalar Long

type Lot {
  id: String!
  code: String!
  unit: Unit!
  quantity: Float!
  totalCostCents: Float!
  expirationDate: Date!
  location: Location!
  companyId: String!
  createdAt: DateTime!
  creatorId: String!
  sourceEvent: SourceEventEnum!
  receivedPurchasedItem: ReceivedPurchasedItem
}

type LotConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [LotConnectionEdge!]!
}

type LotConnectionEdge {
  index: Int!
  node: Lot!
}

input LotConnectionFilter {
  lotCode: String
  vendorItemIds: [String!]
  locationIds: [String!]
  createdAtFrom: DateTime
  createdAtTo: DateTime
  expirationDateFrom: Date
  expirationDateTo: Date
}

input LotPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: [SortingLotFieldEnum!]
}

union MatchedItem = Ingredient | Recipe

# Media represents a file uploaded that can be attached to an entity
type Media {
  id: ID!
  type: String!
  sourceUrl: String
  storageKey: String
  company: Company!
  createdBy: String!
  updatedBy: String!
  deletedBy: String
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

# An entity that can have media
interface MediaEntity {
  id: ID!
  files: Files!
}

# The allowed types of entities that can have media
enum MediaEntityType {
  recipe
  ingredient
  vendorItem
}

# Attributes used to create a new Media and EntityMedia for an entity
input MediaInput {
  mimeType: String!
  sourceUrl: String!
  storageKey: String!
  title: String!
  type: MediaType!
}

# The allowed types of media for an entity
enum MediaType {
  document
  photo
  video
}

type Menu {
  id: ID!
  name: String!
  date: DateOnly
  startDate: DateOnly
  endDate: DateOnly
  headCount: Int
  isPerHead: Boolean
  notes: String
  manualTotalSalesValueCents: Float
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  locationId: String!
  companyId: String!
  menuItems: [MenuItem!]!
  location: Location!
  menuPlanId: String
    @deprecated(reason: "It's only available for menu plan POC")
  categoryValues: [CategoryValue!]!
  event: Event
  ingredientsWithUsages: [IngredientWithUsages!]!
  concept: Concept
  conceptId: String
  totalFoodCostCents: Float
  expectedSalesValueCents: Float!
  actualSalesValueCents: Float!
}

type MenuConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuConnectionEdge!]!
}

type MenuConnectionEdge {
  index: Int!
  node: Menu!
}

input MenuConnectionFilter {
  id: [String]
  conceptId: [String]
  locationId: [String]
  locationName: [String]
  categoryValueIdsBooleanExpressionFilterJSON: CategoryValueIdFilterBooleanExpressionType
  from: DateOnly
  until: DateOnly
  date: [DateOnly]
  includeEmptyDate: Boolean
  name: String
}

#  MenuCycle.
type MenuCycle {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  lastPublishedAt: DateTime
  companyId: ID!
  name: String!
  status: MenuCycleStatusEnum!
  isPerHead: Boolean!
  lengthDays: Int!
  dailyHeadcount: Int!
  budgetCents: Decimal!
  publishedAtLocations: [Location!]
  menuCycleEventGroups: [MenuCycleEventGroup!]
  menuCycleWeekConnection(
    paginationOptions: MenuCycleWeekPaginationOptions
  ): MenuCycleWeekConnection!
  menuCycleSummary(locationId: ID): MenuCycleSummary
  menuCycleConstraints: [Constraint!]
  menuCycleConstraintViolations: [MenuCycleConstraintViolation!]
}

#  MenuCycleCollectionItemContraintSolutionProductsInput represents the parameters required to create or update CollectionItemContraintSolutionProducts.
input MenuCycleCollectionItemContraintSolutionProductsInput {
  menuCycleEventItemId: ID!
  collectionItemConstraintId: ID!
  selectedProductIds: [ID!]!
}

#  MenuCycleConnection.
type MenuCycleConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuCycleConnectionEdge!]!
}

#  MenuCycleConnectionEdge.
type MenuCycleConnectionEdge {
  index: Int!
  node: MenuCycle!
}

#  MenuCycleConnectionFilter.
input MenuCycleConnectionFilter {
  ids: [ID!]
  name: String
  status: [MenuCycleStatusEnum!]
  date: DateFilter
}

#  MenuCycleConstraintViolation.
type MenuCycleConstraintViolation {
  menuCycleEventItem: MenuCycleEventItem!
  constraint: Constraint!
  dietaryFlags: [DietaryFlag!]!
}

#  MenuCycleDay.
type MenuCycleDay {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  day: Int!
  menuCycle: MenuCycle!
  totalCostCents(locationId: ID): Decimal
  menuCycleEvents(orderOptions: MenuCycleEventOrderOptions): [MenuCycleEvent!]!
}

#  MenuCycleEvent.
type MenuCycleEvent {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  menuCycleDay: MenuCycleDay!
  menuCycleEventGroup: MenuCycleEventGroup
  position: Int!
  headCount: Int!
  totalCostCents(locationId: ID): Decimal
  menuCycleEventItems(
    orderOptions: MenuCycleEventOrderOptions
  ): [MenuCycleEventItem!]!
}

#  MenuCycleEventGroup.
type MenuCycleEventGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!
  position: Int!
  menuCycleProductGroups: [MenuCycleProductGroup!]
}

#  MenuCycleEventItem.
type MenuCycleEventItem {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  position: Int!
  quantity: Decimal
  isPerHead: Boolean!
  menuCycleEvent: MenuCycleEvent!
  product: Product!
  menuCycleProductGroup: MenuCycleProductGroup
  unit: Unit
  collectionItemConstraintSolutionProducts: [CollectionItemConstraintSolutionProducts!]
  costCents(locationId: ID): Decimal
}

#  MenuCycleEventItemFilter.
input MenuCycleEventItemFilter {
  ingredientId: ID
  ingredientIds: [ID!]
}

#  MenuCycleEventOrderByEnum.
enum MenuCycleEventOrderByEnum {
  id
  position
  createdAt
}

#  MenuCycleEventOrderOptions.
input MenuCycleEventOrderOptions {
  orderBy: MenuCycleEventOrderByEnum
  sortDirection: SortDirectionEnum
}

#  MenuCycleOrderByEnum.
enum MenuCycleOrderByEnum {
  id
  name
  status
  createdAt
}

#  MenuCyclePaginationOptions.
input MenuCyclePaginationOptions {
  startIndex: Int
  first: Int
  orderBy: MenuCycleOrderByEnum
  sortDirection: SortDirectionEnum
}

#  MenuCycleProductGroup.
type MenuCycleProductGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!
  position: Int!
}

#  MenuCycleStatusEnum.
enum MenuCycleStatusEnum {
  published
  draft
}

#  MenuCycleSummary.
type MenuCycleSummary {
  weekSummaries: [MenuCycleWeekSummary!]
  totalCost: Decimal!
  totalBudgetConsumedPercentage: Decimal!
  plateCost: Decimal!
  weeklyTargetBudget: Decimal!
}

#  MenuCycleWeek.
type MenuCycleWeek {
  week: Int!
  menuCycle: MenuCycle!
  menuCycleDays: [MenuCycleDay!]!
  totalCostCents(locationId: ID): Decimal
}

#  MenuCycleWeekConnection.
type MenuCycleWeekConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuCycleWeekConnectionEdge!]!
}

#  MenuCycleWeekConnectionEdge.
type MenuCycleWeekConnectionEdge {
  index: Int!
  node: MenuCycleWeek!
}

#  MenuCycleWeekPaginationOptions.
input MenuCycleWeekPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
}

#  MenuCycleWeekSummary.
type MenuCycleWeekSummary {
  week: Int!
  totalCost: Decimal!
}

type MenuItem {
  volume: Float
  salesPriceCents: Int
  unitDeprecated: String
  position: Int
  isPerHead: Boolean!
  perHeadFactor: Float
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  menuId: String!
  recipeId: String!
  companyId: String!

  # The menu item's parent menu
  menu: Menu!
  originalRecipeId: String!
  originalRecipe: Recipe!

  # The recipe or recipe variation as a result of applied variation rules
  recipe: Recipe!
  categoryValues: [CategoryValue!]!
  unit: Unit
  foodCostCents(locationId: String): Float
  unitFoodCostCents(locationId: String): Float

  # A flat list of all the components in a recipe tree.
  # Params:
  #   levels: Provide an array of integers only return the components at a certain level of the tree, 0 indexed. Pass -1 as one of the values to get the leaf nodes of the tree
  recipeTreeComponents(levels: [Int!]): [RecipeTreeComponent!]!
  id: ID!
  volumeUnitValues(includeAll: Boolean): [UnitValue!]!
  volumeSold: Float
}

input MenuItemInput {
  id: String
  volume: Float
  volumeSold: Float
  salesPriceCents: Int
  unitDeprecated: String
  position: Int
  isPerHead: Boolean
  perHeadFactor: Float
  menuId: String
  recipeId: String
  unit: UnitInput
}

# MenuPlan aims to define menu plan.
type MenuPlan {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  startDate: Date!
  companyId: ID!
  company: Company!
  menuCycleId: ID!
  menuCycle: MenuCycle!
  locationId: ID!
  location: Location!
  name: String!
  isPerHead: Boolean!
  lengthDays: Int!
  dailyHeadcount: Int!
  budgetCents: Decimal!
  menuPlanSummary: Summary!
  menuPlanEventGroups: [MenuPlanEventGroup]
  menuPlanWeekConnection(
    paginationOptions: MenuPlanWeekPaginationOptions
  ): MenuPlanWeekConnection!
  menuPlanConstraints: [Constraint!]
  menuPlanConstraintViolations: [MenuPlanConstraintViolation!]
}

#  MenuPlanCollectionItemContraintSolutionProductsInput represents the parameters required to create or update CollectionItemContraintSolutionProducts.
input MenuPlanCollectionItemContraintSolutionProductsInput {
  menuPlanEventItemId: ID!
  collectionItemConstraintId: ID!
  selectedProductIds: [ID]!
}

#  MenuPlanConnection is a summary of MenuPlans with overview info.
type MenuPlanConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuPlanConnectionEdge!]!
}

#  MenuPlanConnectionEdge is a each node of list of MenuPlans.
type MenuPlanConnectionEdge {
  index: Int!
  node: MenuPlan!
}

#  MenuPlanConnectionFilter.
input MenuPlanConnectionFilter {
  ids: [ID!]
  name: String
  locationIds: [ID!]
  date: DateFilter
}

#  MenuPlanConstraintViolation.
type MenuPlanConstraintViolation {
  menuPlanEventItem: MenuPlanEventItem!
  constraint: Constraint!
  dietaryFlags: [DietaryFlag!]!
}

#  MenuPlanDay.
type MenuPlanDay {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  day: Int!
  menuPlan: MenuPlan!
  menuPlanEvents(orderOptions: MenuPlanEventOrderOptions): [MenuPlanEvent!]!
}

# MenuPlanEvent aims to define each event of menu plan.
type MenuPlanEvent {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  menuPlanEventGroup: MenuPlanEventGroup
  menuPlanDay: MenuPlanDay!
  headCount: Int!
  status: MenuPlanEventStatusEnum!
  position: Int!
  menu: Menu
  menuPlanEventItems(
    filters: MenuPlanEventItemFilter
    orderOptions: MenuPlanEventOrderOptions
  ): [MenuPlanEventItem!]!
  ingredients: [Ingredient!]
  name: String
  notes: String
  concept: Concept
  isReady: Boolean!
  categoryValues: [CategoryValue!]
}

#  MenuPlanEventConnection is a summary of MenuPlans with overview info.
type MenuPlanEventConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuPlanEventConnectionEdge!]!
}

#  MenuPlanEventConnectionEdge is a each node of list of MenuPlans.
type MenuPlanEventConnectionEdge {
  index: Int!
  node: MenuPlanEvent!
}

#  MenuPlanEventConnectionFilter.
input MenuPlanEventConnectionFilter {
  ids: [ID!]
  locationIds: [ID!]
  updatedAtSince: DateTime
  status: MenuPlanEventStatusEnum
}

# MenuPlanEventGroup.
type MenuPlanEventGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!
  position: Int!
  menuPlan: MenuPlan!
  menuPlanProductGroups: [MenuPlanProductGroup]
}

#  MenuPlanEventItem.
type MenuPlanEventItem {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  position: Int!
  quantity: Decimal!
  isPerHead: Boolean!
  menuPlanEvent: MenuPlanEvent!
  menuPlanProductGroup: MenuPlanProductGroup
  product: Product!
  unit: Unit
  collectionItemConstraintSolutionProducts: [CollectionItemConstraintSolutionProducts!]
  costCents: Decimal
}

#  MenuPlanEventItemFilter.
input MenuPlanEventItemFilter {
  ingredientId: ID
  ingredientIds: [ID!]
}

#  MenuPlanEventOrderByEnum represents the fields that can be ordered in MenuPlanEvent.
enum MenuPlanEventOrderByEnum {
  id
  position
  status
  createdAt
  updatedAt
}

#  MenuPlanEventOrderOptions.
input MenuPlanEventOrderOptions {
  orderBy: MenuPlanEventOrderByEnum
  sortDirection: SortDirectionEnum
}

#  MenuPlanEventPaginationOptions.
input MenuPlanEventPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: MenuPlanEventOrderByEnum
  sortDirection: SortDirectionEnum
}

#  MenuPlanEventStatusEnum represents the status field of MenuPlanEvent.
enum MenuPlanEventStatusEnum {
  draft
  approved
}

#  MenuPlanOrderByEnum represents the option fields to order response items.
enum MenuPlanOrderByEnum {
  id
  name
  createdAt
}

#  MenuPlanPaginationOptions.
input MenuPlanPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: MenuPlanOrderByEnum
  sortDirection: SortDirectionEnum
}

type MenuPlanPOC {
  id: String!
  name: String!
  menuTemplates: [MenuTemplate!]!
  startDate: Date!
  numberOfDays: Int!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  lastUpdatedByUserId: String!
}

type MenuPlanPOCConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuPlanPOCConnectionEdge!]!
}

type MenuPlanPOCConnectionEdge {
  index: Int!
  node: MenuPlanPOC!
}

input MenuPlanPOCConnectionFilter {
  name: String
  date: Date
  ids: [String!]
}

input MenuPlanPOCInput {
  name: String!
  startDate: Date!
  numberOfDays: Int!
}

type MenuPlanPOCTemplateItem {
  id: ID!
  menuPlanId: String
  menuTemplateId: String
  menuPlan: MenuPlanPOC
  menuTemplate: MenuTemplate
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  lastUpdatedByUserId: String
}

type MenuPlanPOCTemplateItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuPlanPOCTemplateItemConnectionEdge!]!
}

type MenuPlanPOCTemplateItemConnectionEdge {
  index: Int!
  node: MenuPlanPOCTemplateItem!
}

input MenuPlanPOCTemplateItemConnectionFilter {
  menuPlanIds: [String!]
  menuTemplateIds: [String!]
}

input MenuPlanPOCTemplateItemInput {
  menuPlanId: String!
  menuTemplateId: String!
}

#  MenuPlanProductGroup.
type MenuPlanProductGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!
  menuPlanEventGroup: MenuPlanEventGroup!
  position: Int!
}

#  MenuPlanWeek.
type MenuPlanWeek {
  week: Int!
  menuPlan: MenuPlan!
  menuPlanDays: [MenuPlanDay!]!
}

#  MenuPlanWeekConnection.
type MenuPlanWeekConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuPlanWeekConnectionEdge!]!
}

#  MenuPlanWeekConnectionEdge.
type MenuPlanWeekConnectionEdge {
  index: Int!
  node: MenuPlanWeek!
}

#  MenuPlanWeekPaginationOptions.
input MenuPlanWeekPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
}

type MenuTemplate {
  id: ID!
  name: String!
  mealRecipeCategoryValueId: String
  mealRecipeCategoryValue: CategoryValue
  menuTemplateItems: [MenuTemplateItem!]
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  lastUpdatedByUserId: String
}

type MenuTemplateConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuTemplateConnectionEdge!]!
}

type MenuTemplateConnectionEdge {
  index: Int!
  node: MenuTemplate!
}

input MenuTemplateConnectionFilter {
  mealRecipeCategoryValueIds: [String!]
  menuPlanIds: [String!]
  ids: [String!]
  name: String
}

input MenuTemplateInput {
  name: String!
  mealRecipeCategoryValueId: String!
}

type MenuTemplateItem {
  id: String
  menuTemplateId: String
  companyId: String
  name: String
  position: Int
  lastUpdatedByUserId: String
  recipeCategoryValueId: String
  recipeCategoryValue: CategoryValue
  deletedAt: Date
}

type MenuTemplateItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [MenuTemplateItemConnectionEdge!]!
}

type MenuTemplateItemConnectionEdge {
  index: Int!
  node: MenuTemplateItem!
}

input MenuTemplateItemConnectionFilter {
  ids: [String!]
  name: String
  menuTemplateId: String
}

input MenuTemplateItemInput {
  menuTemplateId: String
  name: String
  position: Int
  recipeCategoryValueId: String
}

enum MissingCostEnum {
  CurrentLocation
  AllLocations
}

type MissingFieldError {
  nutrientFieldNames: [String!]!
}

type MissingNutritionalQuantityError {
  nutritionalQuantity: Int
}

type MissingUnitConversionError {
  fromUnit: Unit
  toUnit: Unit
  usage: RecipeUsage
  message: String!
}

# MultipleTargetInput represents the field where user can set multiple targets for a column.
input MultipleTargetInput {
  # possibilities is an array of PossibilitiesInput where user give the direction to extract from
  # the sample, for example:
  # [{"entity": "Coca Cola", "target": "brand name"}, {"entity": "$10.00", "target": "cost unit"}]
  possibilities: [PossibilitiesInput!]!

  # sample is where user will give example how text will come, like: "Coca Cola costs $10.00 in the market"
  # so the machine can extract entities supplied above from this sample, and feed the machine learning with
  # the entities extracted from sample.
  sample: String!
}

type Mutation {
  parseVendorItemsForImport(
    input: ParseVendorItemsForImportInput!
  ): ParseVendorItemsForImportJob!
  setResetFlow(
    jobId: String!
    input: ParseVendorItemsForImportInput!
  ): VendorItemsUserInteractionResponse!
  setFileParsingPossibility(
    jobId: String!
    input: [FieldParsingPossibilityInput!]!
  ): FieldParsingPossibilityResponse!
  setReseatHeader(
    jobId: String!
    headerLine: Int!
  ): VendorItemsUserInteractionResponse!
  setFileApproved(
    jobId: String!
    input: ParseVendorItemsForImportInput!
  ): VendorItemsUserInteractionResponse!

  # *SUPERADMIN ONLY*
  addClaimPolicyMapping(
    input: ClaimPolicyMappingInput!
  ): ClaimPolicyMappingPayload!

  # *SUPERADMIN ONLY*
  deleteClaimPolicyMapping(
    input: ClaimPolicyMappingInput!
  ): ClaimPolicyMappingPayload!

  # *SUPERADMIN ONLY*
  addLocationMapping(input: LocationMappingInput!): LocationMappingPayload!

  # *SUPERADMIN ONLY*
  deleteLocationMapping(input: LocationMappingInput!): LocationMappingPayload!
  assignPolicies(input: AssignPoliciesInput!): AssignPoliciesPayload!
  unassignPolicies(input: UnassignPoliciesInput!): UnassignPoliciesPayload!
  assignRoles(input: AssignRolesInput!): AssignRolesPayload!
  unassignRoles(input: UnassignRolesInput!): UnassignRolesPayload!
  createPolicyDefinition(
    input: CreatePolicyDefinitionInput
  ): CreatePolicyDefinitionResponse!
  updatePolicyDefinition(
    input: UpdatePolicyDefinition
  ): UpdatePolicyDefinitionResponse!
  assignPolicyDefinition(
    input: AssignPolicyDefinitionInput
  ): AssignPolicyDefinitionResponse!
  bulkAssignPolicyDefinition(
    input: BulkAssignPolicyDefinitionInput
  ): BulkAssignPolicyDefinitionResponse!
  bulkUnassignPolicyDefinition(
    input: BulkUnassignPolicyDefinitionInput
  ): BulkUnassignPolicyDefinitionResponse!
  unassignPolicyDefinition(
    input: UnassignPolicyDefinitionInput
  ): UnassignPolicyDefinitionResponse!
  deletePolicyDefinition(
    input: DeletePolicyDefinitionInput!
  ): DeletePolicyDefinitionResponse!
  bulkAssignPermissions(
    input: BulkAssignPermissionsInput!
  ): BulkAssignPermissionsPayload!
  bulkUnassignPermissions(
    input: BulkUnassignPermissionsInput!
  ): BulkUnassignPermissionsPayload!
  bulkSetPermissions(
    input: BulkSetPermissionsInput!
  ): BulkSetPermissionsPayload!

  # *SUPERADMIN ONLY*
  createPolicy(input: CreatePolicyInput!): CreatePolicyPayload!

  # *SUPERADMIN ONLY*
  deletePolicy(input: DeletePolicyInput!): DeletePolicyPayload!

  # The create collection is an interface available to create a new collection.
  createCollection(input: CreateCollectionInput!): CreateCollectionPayload!

  # The update collection is an interface available to update a specific collection.
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionPayload!

  # The delete collection is an interface available to delete a specific collection.
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload!

  # The bulk delete collections is an interface available to delete one or more collections.
  bulkDeleteCollections(
    input: BulkDeleteCollectionsInput!
  ): BulkDeleteCollectionsPayload!

  # The create collection instruction is an interface available to create a new instruction to a collection.
  createCollectionInstruction(
    input: CreateCollectionInstructionInput!
  ): CreateCollectionInstructionPayload!

  # The update collection instruction is an interface available to update a specific collection instruction.
  updateCollectionInstruction(
    input: UpdateCollectionInstructionInput!
  ): UpdateCollectionInstructionPayload!

  # The reorder collection instructions is an interface available to reorder the positions from the instructions in a collection using the order of the collection instructions ids in the list as reference
  reorderCollectionInstructions(
    input: ReorderCollectionInstructionsInput!
  ): ReorderCollectionInstructionsPayload!

  # The delete collection instruction is an interface available to delete a specific collection instruction.
  deleteCollectionInstruction(
    input: DeleteCollectionInstructionInput!
  ): DeleteCollectionInstructionPayload!

  # The create collection item is an interface available to create a new collection component.
  createCollectionItem(
    input: CreateCollectionItemInput!
  ): CreateCollectionItemPayload!

  # The create collection item with optional list is an interface available to create a new collection component with an optional list.
  createCollectionItemWithOptionalList(
    input: CreateCollectionItemWithOptionalListInput!
  ): CreateCollectionItemPayload!

  # The update collection item is an interface available to update a specific collection component.
  updateCollectionItem(
    input: UpdateCollectionItemInput!
  ): UpdateCollectionItemPayload!

  # The update collection item with optional list is an interface available to update a collection component with an optional list.
  updateCollectionItemWithOptionalList(
    input: UpdateCollectionItemWithOptionalListInput!
  ): UpdateCollectionItemPayload!

  # The delete collection item is an interface available to delete a specific collection component.
  deleteCollectionItem(
    input: DeleteCollectionItemInput!
  ): DeleteCollectionItemPayload!

  # The bulk delete collection items is an interface available to delete one or more collection components.
  bulkDeleteCollectionItems(
    input: BulkDeleteCollectionItemsInput!
  ): BulkDeleteCollectionItemsPayload!

  # The reorder collection items is an interface available to update the order from the collection components on a specific collection.
  reorderCollectionItems(
    input: ReorderCollectionItemsInput!
  ): ReorderCollectionItemsPayload!

  # The createCollectionItemProductConstraint is an interface available to create a constraint for a collection item.
  createCollectionItemProductConstraint(
    input: CreateCollectionItemProductConstraintInput
  ): CollectionItemConstraint!

  # The updateCollectionItemProductConstraint is an interface available to update a constraint for a collection item.
  updateCollectionItemProductConstraint(
    input: UpdateCollectionItemProductConstraintInput
  ): CollectionItemConstraint!

  # The deleteCollectionItemProductConstraint is an interface available to delete a constraint for a collection item.
  deleteCollectionItemProductConstraint(
    input: DeleteCollectionItemProductConstraintInput
  ): CollectionItemConstraint!

  # The createDietaryFlagConstraint is an interface available to create a constraint for dietary flags.
  createDietaryFlagConstraint(
    input: CreateDietaryFlagConstraintInput!
  ): Constraint!

  # The updateDietaryFlagConstraint is an interface available to update a constraint for dietary flags.
  updateDietaryFlagConstraint(
    input: UpdateDietaryFlagConstraintInput!
  ): Constraint!

  # The deleteDietaryFlagConstraint is an interface available to delete a constraint for dietary flags.
  deleteDietaryFlagConstraint(input: DeleteDietaryFlagConstraintInput): ID!

  # The createCategoryValueConstraint is an interface available to create a constraint for category values.
  createCategoryValueConstraint(
    input: CreateCategoryValueConstraintInput!
  ): Constraint!

  # The updateCategoryValueConstraint is an interface available to update a constraint for category values.
  updateCategoryValueConstraint(
    input: UpdateCategoryValueConstraintInput!
  ): Constraint!

  # The deleteCategoryValueConstraint is an interface available to delete a constraint for category values.
  deleteCategoryValueConstraint(input: DeleteCategoryValueConstraintInput): ID!
  requestDraftOrders(
    input: RequestDraftOrdersInput!
  ): RequestDraftOrdersPayload!
  createCycleCount(input: CreateCycleCountInput!): CreateCycleCountPayload!
  deleteCycleCount(input: DeleteCycleCountInput!): DeleteCycleCountPayload!
  updateCycleCount(input: UpdateCycleCountInput!): UpdateCycleCountPayload!
  submitCycleCount(input: SubmitCycleCountInput!): SubmitCycleCountPayload!
  createCycleCountItem(
    input: CreateCycleCountItemInput!
  ): CreateCycleCountItemPayload!
  updateCycleCountItem(
    input: UpdateCycleCountItemInput!
  ): UpdateCycleCountItemPayload!
  deleteCycleCountItem(
    input: DeleteCycleCountItemInput!
  ): DeleteCycleCountItemPayload!
  createCycleCountTemplate(
    input: CreateCycleCountTemplateInput!
  ): CreateCycleCountTemplatePayload!
  updateCycleCountTemplate(
    input: UpdateCycleCountTemplateInput!
  ): UpdateCycleCountTemplatePayload!
  deleteCycleCountTemplate(
    input: DeleteCycleCountTemplateInput!
  ): DeleteCycleCountTemplatePayload!
  createCycleCountTemplateItem(
    input: CreateCycleCountTemplateItemInput!
  ): CreateCycleCountTemplateItemPayload!
  deleteCycleCountTemplateItem(
    input: DeleteCycleCountTemplateItemInput!
  ): DeleteCycleCountTemplateItemPayload!
  reorderCycleCountTemplateItems(
    input: ReorderCycleCountTemplateItemsInput!
  ): ReorderCycleCountTemplateItemsPayload!

  # Receive an item that was expected.
  receiveItem(input: ReceiveItemInput!): ReceivingEventPayload!

  # Receive an item that was not expected.
  receiveAdHocItem(input: ReceiveAdHocItemInput!): ReceivingItemPayload!

  # Reject an item that did arrive.
  rejectItem(input: RejectItemInput!): ReceivingEventPayload!

  # Cancel an item before it arrives.
  cancelItem(input: CancelItemInput!): ReceivingEventPayload!
  deleteReceivingEvent(id: String!): ReceivingEventPayload!
  approveInvoice(input: ApproveInvoiceInput!): UpdateInvoiceStatusPayload!
  archiveInvoice(input: ArchiveInvoiceInput!): UpdateInvoiceStatusPayload!
  bulkUpdateInvoiceStatus(
    input: BulkUpdateInvoiceStatusInput!
  ): BulkUpdateInvoiceStatusPayload!
  completeInvoice(input: CompleteInvoiceInput!): UpdateInvoiceStatusPayload!
  createInvoice(input: CreateInvoiceInput!): CreateInvoicePayload!
  createInvoiceApprovalRule(
    input: CreateInvoiceApprovalRuleInput!
  ): CreateInvoiceApprovalRulePayload!
  updateInvoiceApprovalRule(
    input: UpdateInvoiceApprovalRuleInput!
  ): UpdateInvoiceApprovalRulePayload!
  toggleInvoiceAutoApproveRule(
    input: ToggleInvoiceAutoApproveRuleInput!
  ): UpdateInvoiceApprovalRulePayload!
  deleteInvoiceApprovalRule(
    input: DeleteInvoiceApprovalRuleInput!
  ): UpdateInvoiceApprovalRulePayload!
  createInvoiceItem(input: CreateInvoiceItemInput!): CreateInvoiceItemPayload!
  deleteInvoiceItem(input: DeleteInvoiceItemInput!): UpdateInvoiceItemPayload!
  draftInvoice(input: DraftInvoiceInput!): UpdateInvoiceStatusPayload!
  reprocessInvoiceDataMatching(
    input: ReprocessInvoiceDataMatchingInput!
  ): ReprocessInvoiceDataMatchingPayload!
  updateInvoice(input: UpdateInvoiceInput!): UpdateInvoicePayload!
  updateInvoiceItem(input: UpdateInvoiceItemInput!): UpdateInvoiceItemPayload!

  # The createInvoiceRule is an interface available to create a new invoice rule.
  createInvoiceRule(input: CreateInvoiceRuleInput!): CreateInvoiceRulePayload!

  # The createInvoiceRule is an interface available to create a new invoice rule.
  updateInvoiceRule(input: UpdateInvoiceRuleInput!): UpdateInvoiceRulePayload!

  # The createInvoiceRule is an interface available to create a new invoice rule.
  deleteInvoiceRule(input: DeleteInvoiceRuleInput!): DeletedInvoiceRulePayload!
  createDownloadUrlEntityMedias(
    entityMediaIds: [ID!]!
  ): CreateDownloadUrlEntityMediasPayload!
  updateEntityMedia(input: UpdateEntityMediaInput!): UpdateEntityMediaPayload!
  createEntityMedias(
    input: CreateEntityMediasInput!
  ): CreateEntityMediasPayload!
  deleteEntityMedias(
    input: DeleteEntityMediasInput!
  ): DeleteEntityMediasPayload!
  createMenuCycle(input: CreateMenuCycleInput!): MenuCycle
  updateMenuCycle(input: UpdateMenuCycleInput!): MenuCycle
  bulkDeleteMenuCycles(input: BulkDeleteMenuCyclesInput!): [MenuCycle]
  publishMenuCycle(input: PublishMenuCycleInput!): MenuCycle
  createMenuCycleEvent(input: CreateMenuCycleEventInput!): MenuCycleEvent
  updateMenuCycleEvent(input: UpdateMenuCycleEventInput!): MenuCycleEvent
  bulkDeleteMenuCycleEvents(
    input: BulkDeleteMenuCycleEventsInput!
  ): [MenuCycleEvent!]
  bulkClearMenuCycleEvents(
    input: BulkClearMenuCycleEventsInput!
  ): [MenuCycleEvent!]
  createMenuCycleEventGroup(
    input: CreateMenuCycleEventGroupInput!
  ): MenuCycleEventGroup
  updateMenuCycleEventGroup(
    input: UpdateMenuCycleEventGroupInput!
  ): MenuCycleEventGroup
  bulkDeleteMenuCycleEventGroups(
    input: BulkDeleteMenuCycleEventGroupsInput!
  ): [MenuCycleEventGroup!]
  createMenuCycleEventItem(
    input: CreateMenuCycleEventItemInput!
  ): MenuCycleEventItem
  updateMenuCycleEventItem(
    input: UpdateMenuCycleEventItemInput!
  ): MenuCycleEventItem
  bulkDeleteMenuCycleEventItems(
    input: BulkDeleteMenuCycleEventItemsInput!
  ): [MenuCycleEventItem!]
  createMenuCycleProductGroup(
    input: CreateMenuCycleProductGroupInput!
  ): MenuCycleProductGroup
  updateMenuCycleProductGroup(
    input: UpdateMenuCycleProductGroupInput!
  ): MenuCycleProductGroup
  bulkDeleteMenuCycleProductGroups(
    input: BulkDeleteMenuCycleProductGroupsInput!
  ): [MenuCycleProductGroup!]
  upsertMenuCycleCollectionItemConstraintSolutionProducts(
    input: MenuCycleCollectionItemContraintSolutionProductsInput!
  ): CollectionItemConstraintSolutionProducts
  approveMenuPlanEvent(input: ApproveMenuPlanEventInput!): MenuPlanEvent
  createMenuPlanEvent(input: CreateMenuPlanEventInput!): MenuPlanEvent
  createMenuPlanEventItem(
    input: CreateMenuPlanEventItemInput!
  ): MenuPlanEventItem
  createMenuPlanEventGroup(
    input: CreateMenuPlanEventGroupInput!
  ): MenuPlanEventGroup
  createMenuPlanProductGroup(
    input: CreateMenuPlanProductGroupInput!
  ): MenuPlanProductGroup
  requestMenuPlanPurchaseGuide(
    input: RequestMenuPlanPurchaseGuideInput!
  ): RequestMenuPlanPurchaseGuideResponse
  requestMenuPlanProductionSchedule(
    input: RequestMenuPlanProductionScheduleInput!
  ): RequestMenuPlanProductionScheduleResponse
  updateMenuPlan(input: UpdateMenuPlanInput!): MenuPlan
  updateMenuPlanProductGroup(
    input: UpdateMenuPlanProductGroupInput!
  ): MenuPlanProductGroup
  updateMenuPlanEventGroup(
    input: UpdateMenuPlanEventGroupInput!
  ): MenuPlanEventGroup
  updateMenuPlanEvent(input: UpdateMenuPlanEventInput!): MenuPlanEvent
  updateMenuPlanEventItem(
    input: UpdateMenuPlanEventItemInput!
  ): MenuPlanEventItem
  bulkClearMenuPlanEvents(
    input: BulkClearMenuPlanEventsInput!
  ): [MenuPlanEvent!]
  bulkDeleteMenuPlans(input: BulkDeleteMenuPlansInput!): [MenuPlan]
  bulkDeleteMenuPlanEventGroups(
    input: BulkDeleteMenuPlanEventGroupsInput!
  ): [MenuPlanEventGroup]
  bulkDeleteMenuPlanProductGroups(
    input: BulkDeleteMenuPlanProductGroupsInput!
  ): [MenuPlanProductGroup]
  bulkDeleteMenuPlanEvents(
    input: BulkDeleteMenuPlanEventInput!
  ): [MenuPlanEvent!]
  bulkDeleteMenuPlanEventItems(
    input: BulkDeleteMenuPlanEventItemsInput!
  ): [MenuPlanEventItem!]
  upsertMenuPlanCollectionItemConstraintSolutionProducts(
    input: MenuPlanCollectionItemContraintSolutionProductsInput!
  ): CollectionItemConstraintSolutionProducts
  bulkUpsertMenus(input: BulkUpsertMenusInput!): BulkUpsertMenusPayload!
  deleteVendor(input: DeleteVendorInput!): DeleteVendorPayload!
  createVendorGroup(input: CreateVendorGroupInput!): CreateVendorGroupPayload!
  deleteVendorGroupVendor(
    input: DeleteVendorGroupVendorInput!
  ): DeleteVendorGroupVendorPayload!
  deleteVendorGroup(input: DeleteVendorGroupInput!): DeleteVendorGroupPayload!
  updateVendorGroup(input: UpdateVendorGroupInput!): UpdateVendorGroupPayload!
  upsertUnit(input: UpsertUnitInput!): UpsertUnitPayload!
  deleteUnit(input: DeleteUnitInput!): DeleteUnitPayload!
  deleteUnitConversion(
    input: DeleteUnitConversionInput!
  ): DeleteUnitConversionPayload!
  deleteLocation(input: DeleteLocationInput!): DeleteLocationPayload!
  createLocationVendorGroup(
    input: CreateLocationVendorGroupInput!
  ): CreateLocationVendorGroupPayload!
  deleteLocationVendorGroup(
    input: DeleteLocationVendorGroupInput!
  ): DeleteLocationVendorGroupPayload!
  createLocationVendor(
    input: CreateLocationVendorInput!
  ): CreateLocationVendorPayload!
  deleteLocationVendor(
    input: DeleteLocationVendorInput!
  ): DeleteLocationVendorPayload!
  createLocationGroup(
    input: CreateLocationGroupInput!
  ): CreateLocationGroupPayload!
  deleteLocationGroup(
    input: DeleteLocationGroupInput!
  ): DeleteLocationGroupPayload!
  updateLocationGroup(
    input: UpdateLocationGroupInput!
  ): UpdateLocationGroupPayload!
  createLocationGroupLocation(
    input: CreateLocationGroupLocationInput!
  ): CreateLocationGroupLocationPayload!
  deleteLocationGroupLocation(
    input: DeleteLocationGroupLocationInput!
  ): DeleteLocationGroupLocationPayload!
  sendWelcomeEmail(input: SendWelcomeEmailInput!): SendWelcomeEmailPayload!
  upsertUser(input: UpsertUserInput!): UpsertUserPayload!
  deleteUser(input: DeleteUserInput!): DeleteUserPayload!
  updateRecipeConcepts(
    input: UpdateRecipeConceptInput!
  ): UpdateRecipeConceptPayload!
  createRecipesConcepts(
    input: CreateRecipesConceptsInput!
  ): CreateRecipesConceptsPayload!
  deleteRecipesConcepts(
    input: DeleteRecipesConceptsInput!
  ): DeleteRecipesConceptsPayload!
  createRecipeInstruction(
    input: CreateRecipeInstructionInput!
  ): CreateRecipeInstructionPayload!
  deleteRecipeInstruction(
    input: DeleteRecipeInstructionInput!
  ): DeleteRecipeInstructionPayload!
  reorderRecipeInstructions(
    input: ReorderRecipeInstructionsInput!
  ): ReorderRecipeInstructionsPayload!
  updateRecipeInstruction(
    input: UpdateRecipeInstructionInput!
  ): UpdateRecipeInstructionPayload!
  createRecipeItemPreparation(
    input: CreateRecipeItemPreparationInput!
  ): CreateRecipeItemPreparationPayload!
  deleteRecipeItemPreparation(
    input: DeleteRecipeItemPreparationInput!
  ): DeleteRecipeItemPreparationPayload!
  createRecipeItem(input: CreateRecipeItemInput!): CreateRecipeItemPayload!
  bulkUploadRecipeItems(
    input: BulkUploadRecipeItemsInput!
  ): BulkUploadRecipeItemsPayload!
  deleteRecipeItem(input: DeleteRecipeItemInput!): DeleteRecipeItemPayload!
  reorderRecipeItems(
    input: ReorderRecipeItemsInput!
  ): ReorderRecipeItemsPayload!
  updateRecipeItem(input: UpdateRecipeItemInput!): UpdateRecipeItemPayload!
  deleteRecipeVariation(
    input: DeleteRecipeVariationInput!
  ): DeleteRecipeVariationPayload!
  createRecipeVariation(
    input: CreateRecipeVariationInput!
  ): CreateRecipeVariationPayload!
  createRecipeVariationRemoval(
    input: CreateRecipeVariationRemovalInput!
  ): CreateRecipeVariationRemovalPayload!
  deleteRecipeVariationRemoval(
    input: DeleteRecipeVariationRemovalInput!
  ): DeleteRecipeVariationRemovalPayload!
  deleteRecipeVariationRule(
    input: DeleteRecipeVariationRuleInput!
  ): DeleteRecipeVariationRulePayload!
  upsertRecipeVariationRule(
    input: UpsertRecipeVariationRuleInput!
  ): UpsertRecipeVariationRulePayload!
  bulkUpdateRecipeItems(
    input: BulkUpdateRecipeItemsInput!
  ): BulkUpdateRecipeItemsPayload!
  copyRecipe(input: CopyRecipeInput!): CopyRecipePayload!
  deleteRecipe(input: DeleteRecipeInput!): DeleteRecipePayload!
  restoreRecipe(input: RestoreRecipeInput!): RestoreRecipePayload!
  updateRecipeHaccpRules(
    input: UpdateRecipeHaccpRulesInput!
  ): UpdateRecipeHaccpRulesPayload!
  upsertRecipe(input: UpsertRecipeInput!): UpsertRecipePayload!
  deleteMenu(input: DeleteMenuInput!): DeleteMenuPayload!
  copyMenu(input: CopyMenuInput!): CopyMenuPayload!
  createMenuItem(input: CreateMenuItemInput!): CreateMenuItemPayload!
  deleteMenuItem(input: DeleteMenuItemInput!): DeleteMenuItemPayload!
  updateMenuItem(input: UpdateMenuItemInput!): UpdateMenuItemPayload!
  reorderMenuItems(input: ReorderMenuItemsInput!): ReorderMenuItemsPayload!
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryPayload!
  upsertCategory(input: UpsertCategoryInput!): UpsertCategoryPayload!
  deleteCategoryValue(
    input: DeleteCategoryValueInput!
  ): DeleteCategoryValuePayload!
  updateCategoryValue(
    input: UpdateCategoryValueInput!
  ): UpdateCategoryValuePayload!
  createCategoryValue(
    input: CreateCategoryValueInput!
  ): CreateCategoryValuePayload!
  updateCompanySettings(
    input: updateCompanySettingsInput!
  ): updateCompanySettingsPayload!
  revokeApiAccess(
    input: RevokeApiAccessMutationInput!
  ): RevokeApiAccessMutationPayload!
  grantApiAccess(
    input: GrantApiAccessMutationInput!
  ): GrantApiAccessMutationPayload!
  deleteIngredient(input: DeleteIngredientInput!): DeleteIngredientPayload!
  createIngredientVendorItem(
    input: CreateIngredientVendorItemInput!
  ): CreateIngredientVendorItemPayload!
  reorderIngredientVendorItems(
    input: ReorderIngredientVendorItemsInput!
  ): ReorderIngredientVendorItemsPayload!
  deleteIngredientVendorItem(
    input: DeleteIngredientVendorItemInput!
  ): DeleteIngredientVendorItemPayload!
  createIngredientPreparation(
    input: CreateIngredientPreparationInput!
  ): CreateIngredientPreparationPayload!
  updateIngredientPreparation(
    input: UpdateIngredientPreparationInput!
  ): UpdateIngredientPreparationPayload!
  upsertPreparation(input: UpsertPreparationInput!): UpsertPreparationPayload!
  deletePreparation(input: DeletePreparationInput!): DeletePreparationPayload!
  createConcept(input: CreateConceptInput!): CreateConceptPayload!
  updateConcept(input: UpdateConceptInput!): UpdateConceptPayload!
  deleteConcept(input: DeleteConceptInput!): DeleteConceptPayload!
  createViewState(input: CreateViewStateInput!): CreateViewStatePayload!
  updateViewState(input: UpdateViewStateInput!): UpdateViewStatePayload!
  deleteViewState(input: DeleteViewStateInput!): DeleteViewStatePayload!
  createHaccpRule(input: CreateHaccpRuleInput!): CreateHaccpRulePayload!
  deleteHaccpRule(input: DeleteHaccpRuleInput!): DeleteHaccpRulePayload!
  updateHaccpRule(input: UpdateHaccpRuleInput!): UpdateHaccpRulePayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!

  # Use `bulkUploadCategories` to create and/or update multiple categories and their values.
  bulkUploadCategories(
    input: BulkUploadCategoriesInput!
  ): BulkUploadCategoriesPayload!
  setCategoryValueItems(
    input: SetCategoryValueItemsInput!
  ): SetCategoryValueItemsPayload!

  # Creates an association between a list of items and a list of category values.
  # If you need to add the same list of category values to a list of items of the same time,
  # use `bulkAddCategoryValueItems` instead.
  bulkCreateCategoryValueItems(
    input: BulkCreateCategoryValueItemsInput!
  ): BulkCreateCategoryValueItemsPayload!
  bulkRemoveCategoryValueItems(
    input: BulkRemoveCategoryValueItemsInput!
  ): BulkRemoveCategoryValueItemsPayload!

  # Adds a category value or list of category values to a list of items.
  # All items must be of the same type.
  # All items will get assigned all category values.
  bulkAddCategoryValueItems(
    input: BulkAddCategoryValueItemsInput!
  ): BulkAddCategoryValueItemsPayload!
  addCategoryValueItem(
    input: AddCategoryValueItemInput!
  ): AddCategoryValueItemPayload!
  createLocation(input: CreateLocationInput!): CreateLocationPayload!
  updateLocation(input: UpdateLocationInput!): UpdateLocationPayload!
  bulkCreateSubLocationItems(
    input: BulkCreateSubLocationItemsInput!
  ): BulkCreateSubLocationItemsPayload!
  bulkDeleteSubLocationItems(
    input: BulkDeleteSubLocationItemsInput!
  ): BulkDeleteSubLocationItemsPayload!
  reorderSubLocationItems(
    input: ReorderSubLocationItemsInput!
  ): ReorderSubLocationItemsPayload!
  createSubLocation(input: CreateSubLocationInput!): CreateSubLocationPayload!
  deleteSubLocation(input: DeleteSubLocationInput!): DeleteSubLocationPayload!
  updateSubLocation(input: UpdateSubLocationInput!): UpdateSubLocationPayload!
  setDefaultSubLocation(
    input: SetDefaultSubLocationInput!
  ): SetDefaultSubLocationPayload!
  createLocationGroupVendorGroup(
    input: CreateLocationGroupVendorGroupInput!
  ): CreateLocationGroupVendorGroupPayload!
  deleteLocationGroupVendorGroup(
    input: DeleteLocationGroupVendorGroupInput!
  ): DeleteLocationGroupVendorGroupPayload!
  upsertCompany(input: UpsertCompanyInput!): UpsertCompanyPayload!
  sendLMSEmail(input: SendLMSEmailInput!): SendLMSEmailPayload!
  setUserAttribute(input: SetUserAttributeInput!): SetUserAttributePayload!
  assignLocationsToUsers(
    input: AssignLocationsToUsersInput!
  ): AssignLocationsToUsersPayload!
  sendFreemiumWelcomeEmail(
    input: SendFreemiumWelcomeEmailInput!
  ): SendFreemiumWelcomeEmail!
  createEvent(input: CreateEventInput!): CreateEventPayload!
  deleteEvent(input: DeleteEventInput!): DeleteEventPayload!
  addMenuToEvent(input: AddMenuToEventInput!): AddMenuToEventPayload!
  removeMenuFromEvent(
    input: RemoveMenuFromEventInput!
  ): RemoveMenuFromEventPayload!
  updateEvent(input: UpdateEventInput!): UpdateEventPayload!
  bulkDeleteIngredients(
    input: BulkDeleteIngredientsInput!
  ): BulkDeleteIngredientsPayload!
  bulkUploadIngredients(
    input: BulkUploadIngredientsInput!
  ): BulkUploadIngredientsPayload!
  upsertIngredient(input: UpsertIngredientInput!): UpsertIngredientPayload!
  bulkCreateIngredientsVendorItems(
    input: BulkCreateIngredientsVendorItemsInput!
  ): BulkCreateIngredientsVendorItemsPayload!
  bulkDeleteIngredientsVendorItems(
    input: BulkDeleteIngredientsVendorItemsInput!
  ): BulkDeleteIngredientsVendorItemsPayload!
  bulkCopyIngredientsVendorItems(
    input: BulkCopyIngredientsVendorItemsInput!
  ): BulkCopyIngredientsVendorItemsPayload!
  bulkReorderIngredientVendorItems(
    input: BulkReorderIngredientVendorItemsInput!
  ): BulkReorderIngredientVendorItemsPayload!
  unsuspendInventoryTasks(
    input: UnsuspendInventoryTasksInput!
  ): UnsuspendInventoryTasksPayload!
  resolveSuspendedInventoryTask(
    input: ResolveSuspendedInventoryTaskInput!
  ): ResolveSuspendedInventoryTaskPayload!
  forcePendingInventoryTasksProcess(
    input: ForcePendingInventoryTasksProcessInput!
  ): ForcePendingInventoryTasksProcessPayload!
  copyEntities(input: CopyEntitiesInput!): CopyEntitiesPayload
  createReceivedItem(input: CreateReceivedItemInput!): CreateReceivedItemPayload
  updateReceivedItem(input: UpdateReceivedItemInput!): UpdateReceivedItemPayload
  createRecipeShareableView(
    input: CreateRecipeShareableViewInput!
  ): CreateRecipeShareableViewPayload!
  deleteAllRecipeInstructions(
    input: DeleteAllRecipeInstructionsInput!
  ): DeleteAllRecipeInstructionsPayload!
  deleteRecipeShareableView(
    input: DeleteRecipeShareableViewInput!
  ): DeleteRecipeShareableViewPayload!
  updateRecipe(input: UpdateRecipeInput!): UpdateRecipePayload
  updateRecipeShareableView(
    input: UpdateRecipeShareableViewInput!
  ): UpdateRecipeShareableViewPayload!
  bulkUploadRecipes(input: BulkUploadRecipesInput!): BulkUploadRecipesPayload!
  bulkDeleteRecipes(input: BulkDeleteRecipesInput!): BulkDeleteRecipesPayload!
  updateRecipeYieldPercent(
    input: UpdateRecipeYieldPercentInput!
  ): UpdateRecipeYieldPercentPayload
  generateShortCodeForRecipe(
    input: GenerateShortCodeForRecipeInput!
  ): GenerateShortCodeForRecipePayload!
  reorderRecipeItemPreparations(
    input: ReorderRecipeItemPreparationsInput!
  ): ReorderRecipeItemPreparationsPayload
  bulkDeleteMenus(input: BulkDeleteMenusInput!): BulkDeleteMenusPayload!

  # DEPRECATED.  Mutation will be replaced in a short time
  _bulkUpsertMenu(input: _BulkUpsertMenusInput!): _BulkUpsertMenusPayload!
  bulkUploadMenus(input: BulkUploadMenusInput!): BulkUploadMenusPayload!
  upsertMenu(input: UpsertMenuInput!): UpsertMenuPayload!
  validateBulkUploadMenus(
    input: ValidateBulkUploadMenusInput!
  ): ValidateBulkUploadMenusPayload!
  validateBulkUpsertMenus(
    input: ValidateBulkUpsertMenusInput!
  ): ValidateBulkUpsertMenusPayload!
  bulkCreateMenuTemplateItems(
    input: BulkCreateMenuTemplateItemsInput!
  ): BulkCreateMenuTemplateItemsPayload!
    @deprecated(reason: "will be replaced by a different graph")
  createMenuTemplateItem(
    input: CreateMenuTemplateItemInput!
  ): CreateMenuTemplateItemPayload!
    @deprecated(reason: "will be replaced by a different graph")
  bulkDeleteMenuTemplateItems(
    input: BulkDeleteMenuTemplateItemsInput!
  ): BulkDeleteMenuTemplateItemsPayload
    @deprecated(reason: "will be replaced by a different graph")
  deleteMenuTemplateItem(
    input: DeleteMenuTemplateItemInput!
  ): DeleteMenuTemplateItemPayload
    @deprecated(reason: "will be replaced by a different graph")
  reorderTemplateItem(
    input: ReorderMenuTemplateItemInput!
  ): ReorderMenuTemplateItemPayload
    @deprecated(reason: "will be replaced by a different graph")
  updateTemplateItem(
    input: UpdateMenuTemplateItemInput!
  ): UpdateMenuTemplateItemPayload
    @deprecated(reason: "will be replaced by a different graph")
  bulkCreateMenuTemplates(
    input: BulkCreateMenuTemplatesInput!
  ): BulkCreateMenuTemplatesPayload!
    @deprecated(reason: "will be replaced by a different graph")
  createMenuTemplate(
    input: CreateMenuTemplateInput!
  ): CreateMenuTemplatePayload!
    @deprecated(reason: "will be replaced by a different graph")
  bulkDeleteMenuTemplates(
    input: BulkDeleteMenuTemplatesInput!
  ): BulkDeleteMenuTemplatesPayload!
    @deprecated(reason: "will be replaced by a different graph")
  deleteMenuTemplate(
    input: DeleteMenuTemplateInput!
  ): DeleteMenuTemplatePayload!
    @deprecated(reason: "will be replaced by a different graph")
  bulkUpdateMenuTemplates(
    input: BulkUpdateMenuTemplatesInput!
  ): BulkUpdateMenuTemplatesPayload!
    @deprecated(reason: "will be replaced by a different graph")
  updateMenuTemplate(
    input: UpdateMenuTemplateInput!
  ): UpdateMenuTemplatePayload!
    @deprecated(reason: "will be replaced by a different graph")
  createMenuPlanPOC(input: CreateMenuPlanPOCInput!): CreateMenuPlanPOCPayload!
    @deprecated(reason: "will be replaced by a different graph")
  deleteMenuPlanPOC(input: DeleteMenuPlanPOCInput!): DeleteMenuPlanPOCPayload!
    @deprecated(reason: "will be replaced by a different graph")
  updateMenuPlanPOC(input: UpdateMenuPlanPOCInput!): UpdateMenuPlanPOCPayload!
    @deprecated(reason: "will be replaced by a different graph")
  reorderMenuPlanPOCMenuItems(
    input: ReorderMenuPlanPOCMenuItemsInput!
  ): ReorderMenuPlanPOCMenuItemsPayload!
    @deprecated(reason: "It's only available for menu plan POC")
  bulkCreateMenuPlanPOCTemplateItems(
    input: BulkCreateMenuPlanPOCTemplateItemsInput!
  ): BulkCreateMenuPlanPOCTemplateItemsPayload!
    @deprecated(reason: "will be replaced by a different graph")
  bulkDeleteMenuPlanPOCTemplateItems(
    input: BulkDeleteMenuPlanPOCTemplateItemsInput!
  ): BulkDeleteMenuPlanPOCTemplateItemsPayload!
    @deprecated(reason: "will be replaced by a different graph")
  createMenuPlanPOCTemplateItem(
    input: CreateMenuPlanPOCTemplateItemInput!
  ): CreateMenuPlanPOCTemplateItemPayload!
    @deprecated(reason: "will be replaced by a different graph")
  deleteMenuPlanPOCTemplateItem(
    input: DeleteMenuPlanPOCTemplateItemInput!
  ): DeleteMenuPlanPOCTemplateItemPayload!
    @deprecated(reason: "will be replaced by a different graph")
  upsertVendor(input: UpsertVendorInput!): UpsertVendorPayload!

  # Sets the priority of vendor items for the provided vendors to 0 for
  # ingredients at the specified locations.
  bulkSetPriorityVendors(
    input: BulkSetPriorityVendorsInput!
  ): BulkSetPriorityVendorsPayload!
  deleteVendorItems(input: DeleteVendorItemsInput!): DeleteVendorItemsPayload!
  setPurchasingUnit(input: SetPurchasingUnitInput!): SetPurchasingUnitPayload!
  setVendorItemCost(input: SetVendorItemCostInput!): SetVendorItemCostPayload!
  upsertVendorItem(input: UpsertVendorItemInput!): UpsertVendorItemPayload!
  bulkUploadVendorItems(
    input: BulkUploadVendorItemsInput!
  ): BulkUploadVendorItemsPayload!
  bulkUploadVendorItemIngredients(
    input: BulkUploadVendorItemIngredientsInput!
  ): BulkUploadVendorItemIngredientsPayload!
  createVendorGroupVendor(
    input: CreateVendorGroupVendorInput!
  ): CreateVendorGroupVendorPayload!
  createChouxboxUser(
    input: CreateChouxboxUserInput!
  ): CreateChouxboxUserPayload @deprecated
  updateUnitConversion(
    input: UpdateUnitConversionInput!
  ): UpdateUnitConversionPayload!
  createUnitConversion(
    input: CreateUnitConversionInput!
  ): CreateUnitConversionPayload!
  replaceUnit(input: ReplaceUnitInput!): ReplaceUnitPayload!
  bulkUploadDietaryFlags(
    input: BulkUploadDietaryFlagsInput!
  ): BulkUploadDietaryFlagsPayload!
  createDietaryFlag(input: CreateDietaryFlagInput!): CreateDietaryFlagPayload!
  deleteDietaryFlag(input: DeleteDietaryFlagInput!): DeleteDietaryFlagPayload!
  updateDietaryFlag(input: UpdateDietaryFlagInput!): UpdateDietaryFlagPayload!
  createDietaryFlagItem(
    input: CreateDietaryFlagItemInput!
  ): CreateDietaryFlagItemPayload!
  deleteDietaryFlagItem(
    input: DeleteDietaryFlagItemInput!
  ): DeleteDietaryFlagItemPayload!
  reefCreateRequisitionOrder(
    input: ReefCreateRequisitionOrderInput!
  ): ReefCreateRequisitionOrderPayload @deprecated
  reefCreateComponentCycleCount(
    input: ReefCreateComponentCycleCountInput!
  ): ReefCreateComponentCycleCountPayload @deprecated
  createCredit(input: CreateCreditInput!): CreateCreditPayload
  updateCredit(input: UpdateCreditInput!): UpdateCreditPayload
  createNutritionLabelPng(
    labelType: LabelType!
    recipeId: String!
    allergensList: String
    ingredientsList: String
    servingSizeQuantity: Float
    servingSizeUnit: NutritionLabelServingSizeUnit
    servingsPerContainer: Float
    showAllergens: Boolean
    showIngredients: Boolean
    showProteinDV: Boolean
    showServingsPerContainer: Boolean
    locationId: String
  ): NutritionLabel
  createOrderCategory(input: CreateOrderCategoryInput!): OrderCategoryPayload!
  updateOrderCategory(input: UpdateOrderCategoryInput!): OrderCategoryPayload!
  deleteOrderCategory(input: DeleteOrderCategoryInput!): OrderCategoryPayload!
  createOrderCategoryValue(
    input: CreateOrderCategoryValueInput!
  ): OrderCategoryValuePayload!
  updateOrderCategoryValue(
    input: UpdateOrderCategoryValueInput!
  ): OrderCategoryValuePayload!
  deleteOrderCategoryValue(
    input: DeleteOrderCategoryValueInput!
  ): OrderCategoryValuePayload!
  bulkAddOrderCategoryValueItems(
    input: BulkAddOrderCategoryValueItemsInput!
  ): OrderCategoryValueItemPayload!
  bulkRemoveOrderCategoryValueItems(
    input: BulkRemoveOrderCategoryValueItemsInput!
  ): OrderCategoryValueItemPayload!
  addOrderCategoryValueItems(
    input: AddOrderCategoryValueItemsInput!
  ): OrderCategoryValueItemPayload!
  setOrderCategoryValueItems(
    input: SetOrderCategoryValueItemsInput!
  ): OrderCategoryValueItemPayload!
  deleteItemPurchaseOrder(
    input: DeleteItemPurchaseOrderInput!
  ): DeleteItemPurchaseOrderPayload!
  createItemPurchaseOrder(
    input: CreateItemPurchaseOrderInput!
  ): CreateItemPurchaseOrderPayload!
  createPurchaseOrderItem(
    input: CreatePurchaseOrderItemInput!
  ): CreatePurchaseOrderItemPayload!
  deletePurchaseOrderItem(
    input: DeletePurchaseOrderItemInput!
  ): DeletePurchaseOrderItemPayload!
  updatePurchaseOrderItem(
    input: UpdatePurchaseOrderItemInput!
  ): UpdatePurchaseOrderItemPayload!
  createTransferOrderItem(
    input: CreateTransferOrderItemInput!
  ): CreateTransferOrderItemPayload!
  updateTransferOrderItem(
    input: UpdateTransferOrderItemInput!
  ): UpdateTransferOrderItemPayload!
  deleteTransferOrderItem(
    input: DeleteTransferOrderItemInput!
  ): DeleteTransferOrderItemPayload!
  bulkCreateTransferOrderItem(
    input: [CreateTransferOrderItemInput!]!
  ): BulkCreateTransferOrderItemPayload!
  upsertPurchaseOrder(
    input: UpsertPurchaseOrderInput!
  ): UpsertPurchaseOrderPayload!
  deletePurchaseOrder(
    input: DeletePurchaseOrderInput!
  ): DeletePurchaseOrderPayload!
  transitionPurchaseOrder(
    input: TransitionPurchaseOrderInput!
  ): TransitionPurchaseOrderPayload!
  bulkTransitionPurchaseOrder(
    input: BulkTransitionPurchaseOrderInput!
  ): BulkTransitionPurchaseOrderPayload!
  createTransferOrder(
    input: CreateTransferOrderInput!
  ): CreateTransferOrderPayload!
  updateTransferOrder(
    input: UpdateTransferOrderInput!
  ): UpdateTransferOrderPayload!
  deleteTransferOrder(
    input: DeleteTransferOrderInput!
  ): DeleteTransferOrderPayload!
  transitionTransferOrder(
    input: TransitionTransferOrderInput!
  ): TransitionTransferOrderPayload!
  createSendOrder(input: CreateSendOrderInput!): CreateSendOrderPayload!

  # create a new LinkLabelToPrinter integration
  createLabelPrint(
    printerIds: [ID!]!
    labelIds: [ID!]!
    companyId: ID!
  ): [CreateLabelPrinterResult!]!

  # Delete a LinkLabelToPrinter integration
  deleteLabelPrint(
    printerId: ID!
    labelIds: [ID!]!
    companyId: ID!
  ): DeleteLabelPrinterResult!

  # create a new LinkRecipeToLabel integration
  createRecipePrintLabel(
    recipeIds: [ID!]!
    labelIds: [ID!]!
    companyId: ID!
  ): [CreateRecipePrintLabelResult!]!

  # Delete a LinkRecipeToLabel integration
  deleteRecipePrintLabel(
    recipeId: ID!
    labelIds: [ID!]!
    companyId: ID!
  ): DeleteRecipePrintLabelResult!

  # Setup a new NiceLabel integration
  addNiceLabelPrintingService(
    subscriptionKey: String!
    cloudTriggerName: String!
    isCloudPrint: Boolean
  ): PrintingServiceResult!

  # Upgrade values for subscriptionKey or cloudTriggerName or both
  updateNiceLabelPrintingService(
    id: ID!
    subscriptionKey: String
    cloudTriggerName: String
  ): PrintingServiceResult!

  # Delete a NiceLabel integration
  deleteNiceLabelPrintingService(id: ID!): PrintingServiceResult!

  # Send to print a label
  printLabel(
    labelID: ID!
    entityID: ID!
    printerID: ID!
    quantity: Int
    additionalData: AdditionalPrintLabelDataType
  ): PrintLabelResult!
  printLabels(input: PrintLabelsInput!): PrintLabelsResult!

  # Preview a label to print
  previewLabel(labelID: ID!, entityID: ID!): PrintLabelResult!

  # Assign a location for the printer, this also enables its use
  setLocationToPrinter(
    locationID: ID!
    printerID: ID!
  ): SetLocationToPrinterResult!

  # Bulk assign a location for the printers, this also enables its use
  bulkSetLocationToPrinters(
    locationID: ID!
    printerIDs: [ID!]!
  ): BulkSetLocationToPrinterResult!

  # Synchronize printers from the printing service
  syncPrinters(printingServiceID: ID!): ID!

  # Synchronize labels from the printing service
  syncPrintLabels(printingServiceID: ID!): ID!
  approvePlan(input: ProductionExecutionId!): ProductionExecution!
  finishPlan(input: ProductionExecutionId!): ProductionExecution!
  deletePlan(input: ProductionExecutionId!): ProductionExecutionIdPayload!
  startProductionTasks(input: ProductionStartTaskInput!): [ProductionTask!]
  finishProductionTask(input: ProductionFinishTaskInput!): ProductionTask!
  updateProductionTask(input: ProductionUpdateTaskInput!): ProductionTask!
  updateProductionTasksByPriority(
    input: [ProductionUpdateTaskByPriorityInput!]!
  ): [ProductionTask!]
  updateProductionPicklist(
    input: ProductionUpdatePicklistInput
  ): ProductionPicklist!
  deleteProductionPicklist(
    input: ProductionDeletePicklistInput
  ): ProductionPicklistIdPayload!
  updateAssigneeProductionTasks(
    input: ProductionUpdateAssigneeTaskInput!
  ): [ProductionTask!]
  deleteProductionTasks(
    input: ProductionDeleteTaskInput!
  ): [ProductionTaskIdsPayload!]

  # This mutation create a production schedule using a set of menuIds
  createProductionSchedule(
    input: ProductionScheduleInput!
  ): ProductionScheduleIdPayload!
  retryProductionSchedule(
    input: ProductionScheduleIdInput!
  ): ProductionScheduleIdPayload!
  deleteProductionSchedule(
    input: ProductionScheduleIdInput!
  ): ProductionScheduleIdPayload!
  updateProductionScheduleName(
    input: ProductionScheduleUpdateInput!
  ): ProductionScheduleIdPayload!
  updateProductionScheduleLocationSettings(
    input: ProductionScheduleSettingsInput!
  ): ProductionScheduleSettings!
  updateTemplate(input: UpdateTemplateInput!): UpdateTemplatePayload!
  createCatalogDestinationLocation(
    input: CreateCatalogDestinationLocationInput!
  ): CreateCatalogDestinationLocationPayload!
  bulkCreateCatalogDestinationLocation(
    input: [CreateCatalogDestinationLocationInput!]!
  ): BulkCreateCatalogDestinationLocationPayload!
  deleteCatalogDestinationLocation(
    input: DeleteCatalogDestinationLocationInput!
  ): DeleteCatalogDestinationLocationPayload!
  bulkDeleteCatalogDestinationLocation(
    input: [DeleteCatalogDestinationLocationInput!]!
  ): BulkDeleteCatalogDestinationLocationPayload!
  bulkUpsertTransfersDestinationLocations(
    input: [BulkUpsertTransfersDestinationLocationsInput!]!
  ): BulkUpsertTransfersDestinationLocationsPayload!
  createTransfersCatalogItem(
    input: CreateTransfersCatalogItemInput!
  ): CreateTransfersCatalogItemPayload!
  bulkCreateTransfersCatalogItems(
    input: [CreateTransfersCatalogItemInput!]!
  ): BulkCreateTransfersCatalogItemPayload!
  updateTransfersCatalogItem(
    input: UpdateTransfersCatalogItemInput!
  ): UpdateTransfersCatalogItemPayload!
  bulkUpdateTransfersCatalogItems(
    input: [UpdateTransfersCatalogItemInput!]!
  ): BulkUpdateTransfersCatalogItemsPayload!
  deleteTransfersCatalogItem(
    input: DeleteTransfersCatalogItemInput!
  ): DeleteTransfersCatalogItemPayload!
  bulkDeleteTransfersCatalogItems(
    input: [DeleteTransfersCatalogItemInput!]!
  ): BulkDeleteTransfersCatalogItemPayload!
  bulkUpsertTransfersCatalogItems(
    input: [BulkUpsertTransfersCatalogItemsInput!]!
  ): BulkUpsertTransfersCatalogItemsPayload!
  exportTransfersCatalogItems(
    input: ExportTransfersCatalogItemsInput!
  ): ExportTransfersCatalogItemsPayload!
  createTransfersCatalog(
    input: CreateTransfersCatalogInput!
  ): CreateTransfersCatalogPayload!
  bulkCreateTransfersCatalog(
    input: [CreateTransfersCatalogInput!]!
  ): BulkCreateTransfersCatalogPayload!
  updateTransfersCatalog(
    input: UpdateTransfersCatalogInput!
  ): UpdateTransfersCatalogPayload!
  bulkUpdateTransfersCatalog(
    input: [UpdateTransfersCatalogInput!]!
  ): BulkUpdateTransfersCatalogPayload!
  deleteTransfersCatalog(
    input: DeleteTransfersCatalogInput!
  ): DeleteTransfersCatalogPayload!
  bulkDeleteTransfersCatalog(
    input: [DeleteTransfersCatalogInput!]!
  ): BulkDeleteTransfersCatalogPayload!
  bulkUpdateVendorItems(
    input: BulkUpdateVendorItemsInput!
  ): BulkUpdateVendorItemsPayload!
}

# NiceLabel settings
type NiceLabelSettings {
  # NiceLabel subscription key
  subscriptionKey: String!

  # Name of the Cloud Trigger
  cloudTriggerName: String!
}

type NotFoundError {
  entityId: String!
  message: String!
}

enum NotificationAction {
  NUTRITION_LABEL_FAILED
  DOWNLOAD
  GET_JOB_SUMMARY
  DRAFT_PURCHASE_ORDERS_COMPLETED
  FILE_EXPORT_FAILED
}

type NotificationType {
  id: String!
  message: String!
  payload: String
  action: NotificationAction
}

union NutritionalErrorUnion =
    MissingUnitConversionError
  | MissingFieldError
  | MissingNutritionalQuantityError

type NutritionalInfo {
  addedSugarGDetailed: NutritionalInfoType
  biotinMcgDetailed: NutritionalInfoType
  calciumMgDetailed: NutritionalInfoType
  caloriesKCalDetailed: NutritionalInfoType
  carbsGDetailed: NutritionalInfoType
  chlorideMgDetailed: NutritionalInfoType
  cholesterolMgDetailed: NutritionalInfoType
  cholineMgDetailed: NutritionalInfoType
  chromiumMcgDetailed: NutritionalInfoType
  copperMgDetailed: NutritionalInfoType
  fiberGDetailed: NutritionalInfoType
  folateMcgDetailed: NutritionalInfoType
  iodineMcgDetailed: NutritionalInfoType
  ironMgDetailed: NutritionalInfoType
  magnesiumMgDetailed: NutritionalInfoType
  manganeseMgDetailed: NutritionalInfoType
  molybdenumMcgDetailed: NutritionalInfoType
  niacinMgDetailed: NutritionalInfoType
  nutritionalsQuantity: NutritionalInfoType
  nutritionalsUnit: NutritionalInfoType
  pantothenicAcidMgDetailed: NutritionalInfoType
  phosphorusMgDetailed: NutritionalInfoType
  potassiumMgDetailed: NutritionalInfoType
  proteinGDetailed: NutritionalInfoType
  riboflavinMgDetailed: NutritionalInfoType
  saturatedFatGDetailed: NutritionalInfoType
  seleniumMcgDetailed: NutritionalInfoType
  sodiumMgDetailed: NutritionalInfoType
  sugarGDetailed: NutritionalInfoType
  thiaminMgDetailed: NutritionalInfoType
  totalFatGDetailed: NutritionalInfoType
  transFatGDetailed: NutritionalInfoType
  vitaminAMcgDetailed: NutritionalInfoType
  vitaminB12McgDetailed: NutritionalInfoType
  vitaminB6MgDetailed: NutritionalInfoType
  vitaminCMgDetailed: NutritionalInfoType
  vitaminDMcgDetailed: NutritionalInfoType
  vitaminEMgDetailed: NutritionalInfoType
  vitaminKMcgDetailed: NutritionalInfoType
  zincMgDetailed: NutritionalInfoType
}

type NutritionalInfoType {
  Value: Float
}

union NutritionalItemUnion =
    Ingredient
  | Recipe
  | VendorItem
  | CanonicalIngredient

type NutritionLabel {
  dataURI: String!
  svg: String!
}

input NutritionLabelServingSizeUnit {
  id: String
  name: String!
}

# OrchestratorJobFilter represents the filter for connection
input OrchestratorJobFilter {
  jobId: String
  status: String
  fileName: String
  startDate: Long
  endDate: Long
}

interface Order {
  # The ID of an object
  id: ID!
  orderType: OrderTypeEnum!
  name: String!
  number: Int!
  deliveryDate: DateOnly
  status: String
  categoryValues: [OrderCategoryValue!]!
  companyId: String!
  company: Company!
  creatorId: String
  creator: User
  destinationLocationId: String
  destinationLocation: Location!
  validTargetStatuses: [String!]!
  concept: Concept
  conceptId: String
  notes: String
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

type OrderCategory {
  # The ID of an object
  id: ID!
  companyId: String
  hasPolicyAssociated: Boolean!
  name: String!
  categoryValues: [OrderCategoryValue]
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

type OrderCategoryConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [OrderCategoryConnectionEdge!]!
}

type OrderCategoryConnectionEdge {
  index: Int!
  node: OrderCategory!
}

input OrderCategoryConnectionFilter {
  ids: [String!]
  name: String
}

enum OrderCategoryConnectionOrderByEnum {
  name
}

input OrderCategoryPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: OrderCategoryConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type OrderCategoryPayload {
  orderCategory: OrderCategory
  error: Error
}

type OrderCategoryValue {
  # The ID of an object
  id: ID!
  companyId: String
  hasPolicyAssociated: Boolean!
  categoryId: String!
  name: String!
  categoryValueItems: [OrderCategoryValueItem]
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

type OrderCategoryValueConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [OrderCategoryValueConnectionEdge!]!
}

type OrderCategoryValueConnectionEdge {
  index: Int!
  node: OrderCategoryValue!
}

input OrderCategoryValueConnectionFilter {
  ids: [String!]
  name: String
}

enum OrderCategoryValueConnectionOrderByEnum {
  name
}

scalar OrderCategoryValueIdFilterBooleanExpressionType

type OrderCategoryValueItem {
  # The ID of an object
  id: ID!
  companyId: String
  categoryValueId: String!
  orderId: String!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
}

type OrderCategoryValueItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [OrderCategoryValueItemConnectionEdge!]!
}

type OrderCategoryValueItemConnectionEdge {
  index: Int!
  node: OrderCategoryValueItem!
}

input OrderCategoryValueItemConnectionFilter {
  ids: [String!]
  name: String
}

enum OrderCategoryValueItemConnectionOrderByEnum {
  name
}

input OrderCategoryValueItemPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: OrderCategoryValueItemConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type OrderCategoryValueItemPayload {
  categoryValueItems: [OrderCategoryValueItem]
  error: Error
}

input OrderCategoryValuePaginationOptions {
  startIndex: Int
  first: Int
  orderBy: OrderCategoryValueConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type OrderCategoryValuePayload {
  orderCategoryValue: OrderCategoryValue
  error: Error
}

type OrderConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [OrderConnectionEdge!]!
}

type OrderConnectionEdge {
  index: Int!
  node: Order!
}

input OrderConnectionFilter {
  ids: [String!]
  name: String
  orderType: OrderTypeEnum
  statuses: [String!]
  conceptIds: [String!]
  deliveryDate: DeliveryDateFilterInput
  destinationLocationIds: [String!]
  vendorIds: [String!]
  sourceLocationIds: [String!]
  categoryValueIdsBooleanExpression: OrderCategoryValueIdFilterBooleanExpressionType
}

enum OrderConnectionOrderByEnum {
  id
  name
  updatedAt
  status
  deliveryDate
  destinationLocationId
  destinationLocationName
  sourceLocationId
  sourceName
  vendorId
  conceptId
  conceptName
}

input OrderPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: OrderConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

enum OrderTypeEnum {
  PURCHASE
  TRANSFER
}

# Represents the original invoice data as it was ingested from any external source
type OriginalInvoice {
  id: String!
  invoiceDate: String!
  invoiceNumber: String!
  extLocationId: String!
  extVendorId: String
  shippingAddress: String!
  city: String!
  state: String!
  zipCode: String!
  totalCostCents: Float!
  tax: String!
  totalItems: Int!
  notes: String
  createdAt: String!
  source: String!
  extVendorName: String
}

# Represents the original invoice item data as it was ingested from any external source
type OriginalInvoiceItem {
  id: String!
  quantityOrdered: Float!
  purchasingUnit: String!
  sku: String!
  priceUnit: String!
  costCents: Float!
  name: String!
  createdAt: String!
  description: String
  glCode: String
}

type PageInfo {
  startIndex: Int
  endIndex: Int
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

# PageInfoType basically inform if there more items on pagination flow.
type PageInfoType {
  startIndex: Int
  endIndex: Int
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

input PaginationOptions {
  startIndex: Int

  # Max value is 25; default value is 25
  first: Int
  orderBy: String
  sortDirection: SortDirectionEnum
}

type ParsedRecipeItem {
  rowText: String!
  name: String
  quantityUnits: [ParsedRecipeItemQuantityUnit!]!
  matchedItem: MatchedItem
}

type ParsedRecipeItemQuantityUnit {
  quantity: Float
  unit: Unit
}

# ParseFileInitialRows represents the first 15 rows from a file.
type ParseFileInitialRows {
  rows: String!
}

# ParseVendorItemsEdge represents a node for edge.
type ParseVendorItemsEdge {
  index: Int!
  node: ParseVendorItemsForImportJob!
}

# ParseVendorItemsForImportInput represents the input for starting flow.
input ParseVendorItemsForImportInput {
  fileBase64: String!
  fileName: String!
  description: String
}

# ParseVendorItemsForImportJob represents the response for parse vendors item for import job.
type ParseVendorItemsForImportJob {
  jobId: String!
  createdAt: String!
  status: String!
  fileParsedUrl: String
  possibilities: JSON
  originalName: String!
  description: String!
}

# ParseVendorItemsForImportJobConnection represents the response for query to retrieve jobs from a user.
type ParseVendorItemsForImportJobConnection {
  totalCount: Int!
  pageInfo: ParseVendorItemsPageInfo!
  edges: [ParseVendorItemsEdge!]
}

# ParseVendorItemsForImportJobsPaginationOptions represents the pagination.
input ParseVendorItemsForImportJobsPaginationOptions {
  startIndex: Int!
  first: Int!
}

# ParseVendorItemsPageInfo represents the type for page info.
type ParseVendorItemsPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PoliciesPaginationOptionsInput {
  startIndex: Int
  first: Int
}

type Policy {
  id: ID!
  name: String!
  version: String
  precedence: Int
  statements: [Statement!]!
  description: String
  companyId: String
  type: PolicyType
}

input PolicyAssociationFilter {
  categoryId: String
  categoryValueId: String
}

type PolicyConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PolicyConnectionEdge!]!
}

type PolicyConnectionEdge {
  index: Int!
  node: Policy!
}

type PolicyDefinitionError {
  message: String
}

input PolicyDefinitionInput {
  name: String!
  statements: [PolicyDefinitionStatementInput!]!
  description: String
  type: PolicyType
}

input PolicyDefinitionStatementInput {
  id: String
  effect: String!
  actions: [String!]!
  resource: String!
  conditions: JSONType
}

enum PolicyType {
  Company
  User
  System
}

#  PositiveDecimal.
scalar PositiveDecimal

#  PositiveInt.
scalar PositiveInt

# PossibilitiesInput represents the input for multiple targets.
input PossibilitiesInput {
  entity: String!
  target: String
}

type Preparation {
  # The ID of an object
  id: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  creatorId: String
  recipeItems: [RecipeItem!]!
  recipeItemPreparations: [RecipeItemPreparation!]!
    @deprecated(reason: "will be replaced with Connections")
}

type PreparationConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PreparationConnectionEdge!]!
}

type PreparationConnectionEdge {
  index: Int!
  node: Preparation!
}

input PreparationConnectionFilter {
  id: [String!]
  name: String
}

enum PreparationConnectionOrderByEnum {
  id
  name
  nameMatch
  updatedAt
  createdAt
}

input PreparationConnectionPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: PreparationConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type PreparationWithUsages {
  trimYieldPercent: Float!
  preparation: Preparation!
  recipeItems: [RecipeItem!]!
}

# Printer
type Printer {
  id: ID!

  # Display name of the printer
  name: String!
  createdAt: String!
  updatedAt: String!

  # Associated location for the printer
  location: Location

  # Shows if the printer is enabled
  enabled: Boolean!

  # Returns related labels
  labels: [PrintLabel]!
}

# Connection for printer
type PrinterConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PrinterConnectionEdge!]!
}

# ConnectionEdge for printer type
type PrinterConnectionEdge {
  index: Int!
  node: Printer!
}

# Filter for PrinterConnection
input PrinterConnectionFilter {
  locationId: String
}

# OrderBy options for PrinterConnection
enum PrinterConnectionOrderBy {
  ID
  CREATED_AT
  NAME
}

# Pagination options for PrinterConnection
input PrinterPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: PrinterConnectionOrderBy
  sortDirection: SortDirectionEnum
}

# Represents a printing service at Galley
type PrintingService {
  id: ID!

  # Type of the printing service
  type: PrintingServiceType

  # Settings for the printing service
  settings: PrintingServiceSettings!

  # Returns the date the service was created
  createdAt: String!

  # Returns the date the service was updated
  updatedAt: String!

  # Returns related printers
  printers(
    paginationOptions: PrinterPaginationOptions
    filters: PrinterConnectionFilter
  ): PrinterConnection!

  # Returns related labels
  labels(
    paginationOptions: PrintLabelPaginationOptions
    filters: PrintLabelConnectionFilter
  ): PrintLabelConnection!

  # Returns print jobs
  jobs(
    paginationOptions: PrintJobPaginationOptions
    filters: PrintJobConnectionFilter
  ): PrintJobConnection!
}

# Connection for printing service type
type PrintingServiceConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PrintingServiceConnectionEdge!]!
}

# ConnectionEdge for printing service type
type PrintingServiceConnectionEdge {
  index: Int!
  node: PrintingService!
}

# Pagination options for PrintingServiceConnection
input PrintingServicePaginationOptions {
  startIndex: Int!
  first: Int!
}

# Returns the created or updated printing service
type PrintingServiceResult {
  printingServiceID: ID!
}

# Printing service settings
union PrintingServiceSettings = NiceLabelSettings

# Types of available printing services
enum PrintingServiceType {
  NICELABEL_CLOUD_TRIGGER
  NICELABEL_CLOUD_PRINT
}

# Print job
type PrintJob {
  id: ID!

  # Job type, equals to printer printing service
  type: PrintingServiceType!

  # Printer in charge of the print
  printer: Printer!

  # Label associated with the job
  label: PrintLabel!

  # Amount of labels to print
  quantity: Int!

  # Job creation date
  createdAt: String!

  # Job update date
  updatedAt: String!

  # User that created the job
  user: User

  # Job input data
  data: String!

  # Job last status
  status: PrintJobStatus!
}

# Connection for print job type
type PrintJobConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PrintJobConnectionEdge!]!
}

# ConnectionEdge for print job type
type PrintJobConnectionEdge {
  index: Int!
  node: PrintJob!
}

# Filter for PrintJobConnection
input PrintJobConnectionFilter {
  kind: PrintLabelKind
  status: PrintJobStatus
}

# OrderBy options for PrintJobConnection
enum PrintJobConnectionOrderBy {
  ID
  CREATED_AT
  UPDATED_AT
  STATUS
}

# Pagination options for PrintJobConnection
input PrintJobPaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: PrintJobConnectionOrderBy
  sortDirection: SortDirectionEnum
}

# Print job status
enum PrintJobStatus {
  IN_PROGRESS
  DONE
  ERROR
}

# Print label
type PrintLabel {
  id: ID!
  name: String!
  createdAt: String!
  kind: PrintLabelKind
  variables: [LabelVariable!]!
  dimensions: LabelDimension

  # Recipes related to the label
  recipes: [Recipe!]!
}

# Connection for print label type
type PrintLabelConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [PrintLabelConnectionEdge!]!
}

# ConnectionEdge for label type
type PrintLabelConnectionEdge {
  index: Int!
  node: PrintLabel!
}

# Filter for PrintLabelConnection
input PrintLabelConnectionFilter {
  kind: PrintLabelKind
  recipeIds: [String]
  labelIds: [String]
  hideLinkedLabels: Boolean
}

# OrderBy options for PrintLabelConnection
enum PrintLabelConnectionOrderBy {
  ID
  CREATED_AT
  NAME
}

# Print label types
enum PrintLabelKind {
  RECIPE
  FINISHED_GOOD
  MENU_ITEM
}

# Pagination options for PrintLabelConnection
input PrintLabelPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: PrintLabelConnectionOrderBy
  sortDirection: SortDirectionEnum
}

# Print label result job
type PrintLabelResult {
  jobId: String!
}

# The input data for requesting multiple printing jobs via PrintLabels
input PrintLabelsInput {
  printerId: String!
  labelInputs: [LabelInputType!]!
}

# The response contains an id for every job requested by the PrintLabels mutation
type PrintLabelsResult {
  jobIds: [String!]!
}

type ProcurementSourceItem {
  destinationLocation: Location!
  sourceLocation: Location
  recipe: Recipe
  ingredient: Ingredient
}

input ProcurementSourceItemInput {
  recipeId: String
  ingredientId: String
  destinationLocationId: String!
}

type ProcurementSourceItemInputType {
  recipeId: String
  ingredientId: String
  destinationLocationId: String!
}

type ProcurementSourceItemPayload {
  input: ProcurementSourceItemInputType!
  result: [ProcurementSourceItem!]
  error: Error
}

# Product handles product attributes.
type Product {
  id: String!
  name: String!
  companyId: String!
  productItems: [ProductItem!]
  concepts: [Concept!]
  categoryValues: [CategoryValue!]
  costCents(locationId: ID): Float
  costUnit(locationId: ID): Unit
  dietaryFlags(locationId: ID): [DietaryFlag!]
  createdAt: String!
  updatedAt: String
  deletedAt: String
}

# ProductConnection is the result of a list of edges.
type ProductConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ProductConnectionEdge!]!
}

# ProductConnectionEdge is the graphql response representation.
type ProductConnectionEdge {
  index: Int!
  node: Product!
}

# ProductConnectionFilters enable filters over product on mutation.
input ProductConnectionFilters {
  name: String
  categories: CategoriesFilter
  conceptIds: [String!]
  ids: [String!]
}

# ProductConnectionPaginationOptions pagination specification.
input ProductConnectionPaginationOptions {
  first: Int
  orderBy: SortFieldProductEnum
  sortDirection: SortDirectionEnum
  startIndex: Int
}

input ProductionDeletePicklistInput {
  id: String!
  taskId: String!
}

input ProductionDeleteTaskInput {
  ids: [String!]!
  applyToDependencies: Boolean!
}

# Represents the execution of the Production Schedule
type ProductionExecution {
  id: String!
  productionScheduleId: String!
  productionScheduleName: String!
  companyId: String!
  creator: User!
  location: Location!
  state: ProductionExecutionStateEnum!
  createdDate: String!
  firstDate: String
  lastDate: String
  error: String
}

type ProductionExecutionConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ProductionExecutionConnectionEdge!]!
}

type ProductionExecutionConnectionEdge {
  index: Int!
  node: ProductionExecution!
}

input ProductionExecutionConnectionFilter {
  ids: [String!]
  productionScheduleId: String
  productionScheduleName: String
  creatorIds: [String!]
  locationIds: [String!]
  locationName: String
  state: [ProductionExecutionStateEnum!]
  createdDate: String
  firstDate: String
  lastDate: String
}

enum ProductionExecutionConnectionOrderByEnum {
  id
  locationName
  productionScheduleName
  state
}

input ProductionExecutionId {
  id: String!
}

type ProductionExecutionIdPayload {
  id: String!
}

input ProductionExecutionPaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: ProductionExecutionConnectionOrderByEnum!
  sortDirection: SortDirectionEnum!
}

# Possible states for producionExecution (plan)
enum ProductionExecutionStateEnum {
  Processing
  Error

  # Plan assumes a Draft state after being approved
  Draft
  ToDo
  InProgress
  Finished
}

input ProductionFinishTaskInput {
  id: String!
  producedQuantity: Float!
  applyToDependencies: Boolean!
}

type ProductionPicklist {
  id: Int!
  taskId: Int!
  name: String!
  itemId: Int!
  IsRecipe: Boolean!
  component: String!
  location: Location!
  unit: Unit!
  toPick: Float!
  lotNumber: String
  vendorName: String
  vendorItemName: String
  cost: Float
  picked: Float
  wasted: Float
  remaining: Float
}

type ProductionPicklistConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ProductionPicklistConnectionEdge!]!
}

type ProductionPicklistConnectionEdge {
  index: Int!
  node: ProductionPicklist!
}

input ProductionPicklistConnectionFilter {
  ids: [String!]
  name: String
}

enum ProductionPicklistConnectionOrderByEnum {
  id
  name
}

type ProductionPicklistIdPayload {
  id: String!
}

input ProductionPicklistPaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: ProductionPicklistConnectionOrderByEnum!
  sortDirection: SortDirectionEnum!
}

type ProductionPickListType {
  id: Int!
  taskId: Int!
  name: String!
  itemId: Int!
  IsRecipe: Boolean!
  unit: Unit!
  toPick: Float!
  lotNumber: String
  vendorName: String
  vendorItemName: String
  cost: Float
  picked: Float
  wasted: Float
  remaining: Float
  nutritionalInfo: NutritionalInfo
}

type ProductionSchedule {
  id: String!
  name: String!
  menuIds: [String!]!
  menus: [Menu!]!
  locationId: String!
  locationName: String!
  createdDate: String!
  firstMenuDate: String!
  lastMenuDate: String!
  processedDate: String!
  validationErrors: [ValidationError!]!
  state: ProductionScheduleStateEnum!
  settings: ProductionScheduleSettings!
  output: ProductionScheduleOutput
  productionExecutionState: ProductionScheduleExecutionStateEnum
}

type ProductionScheduleConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ProductionScheduleConnectionEdge!]!
}

type ProductionScheduleConnectionEdge {
  index: Int!
  node: ProductionSchedule!
}

input ProductionScheduleConnectionFilter {
  ids: [String!]
  name: String
  state: ProductionScheduleStateEnum
  createdDate: String
  firstMenuDate: String
  lastMenuDate: String
  locationId: String
  locationName: String
}

enum ProductionScheduleConnectionOrderByEnum {
  id
  createdAt
  firstMenuDate
  lastMenuDate
  processedDate
  state
}

enum ProductionScheduleConnectionSortDirectionEnum {
  asc
  desc
}

enum ProductionScheduleExecutionStateEnum {
  Processing
  Error
  Draft
  ToDo
  InProgress
  Finished
}

input ProductionScheduleIdInput {
  id: String!
}

type ProductionScheduleIdPayload {
  id: String!
}

input ProductionScheduleInput {
  locationId: String!
  menuIds: [String!]!
  name: String
  batch: Boolean
}

type ProductionScheduleOutput {
  finishedGoods: [RecipeProductionOutput!]!
  subRecipes: [RecipeProductionOutput!]!
}

input ProductionSchedulePaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: ProductionScheduleConnectionOrderByEnum!
  sortDirection: ProductionScheduleConnectionSortDirectionEnum!
}

type ProductionScheduleRecipe {
  recipeId: String!
  recipeName: String!
}

input ProductionSchedulerId {
  id: String!
}

type ProductionScheduleSettings {
  preProductionDays: Int!
  workingHoursPerDay: Int!
  parallelWorkersPerDay: Int!
  workingDays: [Int!]!
  batch: Boolean!
  automation: Boolean!
}

type ProductionScheduleSettingsIdPayload {
  id: String!
}

input ProductionScheduleSettingsInput {
  locationId: String!
  preProductionDays: Int
  workingHoursPerDay: Int
  parallelWorkersPerDay: Int
  workingDays: [Int!]
  batch: Boolean
  automation: Boolean
}

enum ProductionScheduleStateEnum {
  Unknown
  Created
  Validating
  Processing
  Error
  Done
}

input ProductionScheduleUpdateInput {
  id: String!
  name: String!
}

input ProductionStartTaskInput {
  ids: [String!]!
  applyToDependencies: Boolean!
}

type ProductionTask {
  id: String!
  name: String!
  label: String
  recipeId: String!
  productionExecutionId: String!
  productionScheduleId: String!
  productionScheduleName: String!
  productionScheduleOutputId: Int!
  companyId: String!
  priority: Int
  assignee: User

  # The user that created the production from the production schedule
  creator: User!

  # The user that started the task
  starter: User

  # The user that finished the task
  finisher: User
  location: Location!
  state: ProductionTaskStateEnum!
  expectedStartDate: String!
  actualStartedDate: String!
  actualFinishedDate: String!

  # expectedQuantityUnitValues:
  unit: Unit!
  expectedQuantity: Float!
  actualQuantity: Float!
  instructions: String
  notes: String
  components: [ProductionTaskComponent]
  categoryValues: [ProductionTaskCategoryValues]
  prepTime: Int!
  shelfLifeDays: Int!
  isBatched: Boolean!
  isFinishedGood: Boolean!
  expectedCost: Float!
  parentsCount: Int!
  childrenCount: Int!
}

type ProductionTaskCategory {
  id: String
  name: String
}

type ProductionTaskCategoryValues {
  category: ProductionTaskCategory
  name: String
  id: String
}

type ProductionTaskComponent {
  id: String
  name: String
  preparations: [ProductionTaskPreparation]
  unit: Unit
  volume: Float
}

type ProductionTaskConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ProductionTaskConnectionEdge!]!
}

type ProductionTaskConnectionEdge {
  index: Int!
  node: ProductionTask!
}

input ProductionTaskConnectionFilter {
  ids: [String!]
  scheduleIds: [String!]
  productionScheduleName: String
  executionIds: [String!]
  expectedStartDate: [String!]
  actualStartDate: [String!]
  categoryValuesIds: CategoryValueIdFilterBooleanExpressionType
  priority: [Int!]
  locationIds: [String!]
  locationName: String
  name: String
  state: [ProductionTaskStateEnum!]
  prepTime: Int
  assignee: [String!]
  isFinishedGood: Boolean
}

enum ProductionTaskConnectionOrderByEnum {
  id
  productionScheduleId
  productionScheduleName
  location
  state
  expectedStartDate
  actualStartedDate
  priority
  unitName
  name
}

type ProductionTaskCountByState {
  state: String
  total: Int
}

type ProductionTaskDependency {
  id: String!
  name: String!
  unit: Unit!
  state: String!
  quantity: Float
  startDate: String
  level: Int!
  children: [ProductionTaskDependency]!
  parent: [ProductionTaskDependency]!
}

type ProductionTaskIdsPayload {
  id: String!
}

input ProductionTaskPaginationOptions {
  startIndex: Int!
  first: Int!
  orderBy: ProductionTaskConnectionOrderByEnum!
  sortDirection: SortDirectionEnum!
}

type ProductionTaskPreparation {
  name: String
}

enum ProductionTaskStateEnum {
  Draft
  ToDo
  InProgress
  Finished

  # We've created the task and canceled it before it was started
  Canceled
}

input ProductionUpdateAssigneeTaskInput {
  ids: [String!]!
  assignee: String
}

input ProductionUpdatePicklistInput {
  id: String!
  taskId: String!
  cost: Float
  picked: Float
  wasted: Float
  remaining: Float
}

input ProductionUpdateTaskByPriorityInput {
  id: String!
  priority: Int!
}

input ProductionUpdateTaskInput {
  id: String!
  actualStartDate: String
  producedQuantity: Float
  applyToDependencies: Boolean!
}

# ProductItem representation.
type ProductItem {
  id: String!
  productId: String!
  companyId: String!
  locationId: String
  priority: Int!
  quantityG: Float
  quantityMl: Float
  quantityEach: Float
  recipeId: ID
  recipe: Recipe
  ingredientId: ID
  ingredient: Ingredient
  collectionId: String
  collection: Collection
  createdAt: String!
  updatedAt: String
  deletedAt: String
}

# A ProductPredicate contains a list of products available to be selected in a product constraint in a certain quantity.
type ProductPredicate {
  id: ID!
  name: String
  quantity: Int!
  products: [Product!]!
}

#  PublishMenuCycleInput represents the parameters required to publish a MenuCycle.
input PublishMenuCycleInput {
  id: ID!
  locationIds: [ID!]!
}

type PurchaseOrder implements Order {
  # The ID of an object
  id: ID!
  menus: [Menu!]!
  purchaseOrderItems: [PurchaseOrderItem!]!
    @deprecated(reason: "will be replaced with Connections")
  orderType: OrderTypeEnum!
  name: String!
  number: Int!
  deliveryDate: DateOnly
  status: String
  categoryValues: [OrderCategoryValue!]!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  creatorId: String
  destinationLocationId: String
  vendorId: String!
  creator: User
  vendor: Vendor!
  destinationLocation: Location!
  company: Company!
  validTargetStatuses: [String!]!
  concept: Concept
  conceptId: String
  notes: String
}

input PurchaseOrderInput {
  id: String
  status: String
  companyId: String
  creatorId: String
  destinationLocationId: String
  conceptId: String
  vendorId: String
  menuIds: [String!]
  purchaseOrderItems: [PurchaseOrderItemInput!]
  deliveryDate: DateOnly
  notes: String
  name: String
}

type PurchaseOrderItem {
  id: ID!
  locationId: String
  vendorItemId: String!
  ingredientId: String
  unitId: String
  quantity: Float!
  quantityUnitValues(includeAll: Boolean): [UnitValue!]!
  companyId: String!
  createdAt: Date!
  deletedAt: Date
  ingredient: Ingredient
  notes: String
  purchaseOrder: PurchaseOrder!
  purchaseOrderId: String
  unit: Unit
  updatedAt: Date!
  vendorItem: VendorItem!
  unitCostCents: Float
  totalCostCents: Float
}

input PurchaseOrderItemInput {
  id: String
  quantity: Float!
  unitDeprecated: String
  ingredientId: String
  vendorItemId: String
  unit: UnitInput
  notes: String
  totalCostCents: Float
  unitCostCents: Float
}

input QuantityUnitInput {
  quantity: Float
  unitId: String
}

type Query {
  viewer: Viewer!
  shareableRecipe(id: String!): ShareableRecipeView
  notifications: [NotificationType!]!

  # Returns printing service by id
  printingService(id: String!): PrintingService

  # Returns printing services
  printingServices(
    paginationOptions: PrintingServicePaginationOptions!
  ): PrintingServiceConnection!
}

# The input required to make a receiveAdHocItem mutation
input ReceiveAdHocItemInput {
  itemId: String!
  vendorId: String
  sourceLocationId: String
  eventDate: Date
  expectedExpiresAt: Date
  quantity: Float!
  unitId: String!
  costUnitId: String
  costCents: Float

  # If provided, must be a valid UUID.
  idempotenceKey: String
  locationId: String!

  # Your Galley internal lotId
  lotId: String
  externalLotId: String
  invoiceNumber: String
}

type ReceivedPurchasedItem {
  vendor: Vendor!
  vendorItem: VendorItem!
  externalLotCodes: [String!]!
}

# The input required to make a receiveItem mutation
input ReceiveItemInput {
  eventDate: Date
  receivingItemId: String!
  expectedExpiresAt: Date
  quantity: Float!
  unitId: String!
  costUnitId: String
  costCents: Float

  # If provided, must be a valid UUID.
  idempotenceKey: String

  # Your Galley internal lotId
  lotId: String
  externalLotId: String
  invoiceNumber: String
}

type Receiving {
  location: Location!
  vendors: [Vendor!]!
  items: [ReceivingItem!]!
}

# The payload returned from receivingItemEvent mutations
type ReceivingEventPayload {
  receivingItemEvent: ReceivingItemEvent
  error: Error
}

type ReceivingItem {
  id: String!
  vendorItem: VendorItem!
  expectedCostCents: Float
  actualCostCents: Float
  expectedQuantity: Float
  actualQuantity: Float
  expectedUnit: Unit
  actualUnit: Unit
  expectedCostUnit: Unit
  actualCostUnit: Unit
  receivedItemId: String
  purchaseOrderItemId: String
  receivedAt: Date
  purchaseOrder: PurchaseOrder
}

# The reason a receivingItem was cancelled
enum ReceivingItemCancelledReason {
  noLongerNeeded
  outOfStock
  other
}

# A connectionType whos nodes are of type ReceivingItemV2
type ReceivingItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [ReceivingItemEdge!]!
}

# An edge whos node is of type ReceivingItemV2
type ReceivingItemEdge {
  index: Int!
  node: ReceivingItemV2!
}

# An event that can happen to a receivingItem, such as expected, received, or rejected
type ReceivingItemEvent {
  id: String!

  # The date that the record was created in Galley's database
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date

  # The date the event actually occured
  eventDate: Date!
  receivingItemId: String!
  receivingItem: ReceivingItemV2
  expectedExpiresAt: Date
  quantity: Float!
  unitId: String!
  unit: Unit
  costUnitId: String
  costUnit: Unit

  # The cost, in cents, of the item per costUnit
  costCents: Float

  # The total cost of the item, regardless of unit
  totalCostCents: Float
  eventType: ReceivingItemEventType!
  userId: String!
  user: User
  rejectedReason: ReceivingItemRejectedReason
  cancelledReason: ReceivingItemCancelledReason

  # More specific details about the event, especially with regards to the rejected or cancelled reason
  description: String
  status: ReceivingItemEventStatus!
  idempotenceKey: String!
  legacyReceivedItemId: String

  # The Galley internal lot id
  lotId: String

  # The lot id from the system of data the item originated from, for example the vendor's lot id
  externalLotId: String

  # The invoice number informed by the user, is not related to any galley entity
  invoiceNumber: String
}

# Receiving events are processed asynchronously.  Use this status to track progress.
enum ReceivingItemEventStatus {
  # The event has been created but has not yet affected your inventory levels.
  processing

  # The event requires user intervention to continue, such as providing a missing unitConversion.
  suspended

  # The event has now affected your inventory levels.
  processed
}

# The kinds of events that may occur to a receivingItem
enum ReceivingItemEventType {
  expected
  received

  # The item has arrived in an unacceptable state
  rejected

  # The item should no longer be expected to arrive
  cancelled
}

# The fields that receivingItems can be ordered by
enum ReceivingItemOrderByEnum {
  SourceDocId
  ItemName
  VendorName
  SourceLocationName
  ExpectedDeliveryDate
}

# Options for paginating a ReceivingItemConnection's edges
input ReceivingItemPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: ReceivingItemOrderByEnum
  sortDirection: SortDirectionEnum
}

# The payload returned from receivingItem mutations
type ReceivingItemPayload {
  receivingItem: ReceivingItemV2
  error: Error
}

# The reason a receivingItem was rejected
enum ReceivingItemRejectedReason {
  badQuality
  broken
  notOrdered
  outOfTemp
  spoiled
  tooManySent
  unacceptableSubstitution
  other
}

# Filters for receivingItems
input ReceivingItemsFilter {
  # Destination locations.
  locationIds: [String!]
  vendorIds: [String!]
  sourceLocationIds: [String!]

  # The starting point of your expected delivery date filter.
  startDate: Date

  # The ending point of your expected delivery date filter.
  endDate: Date
  itemName: String

  # By default, 'closed' items (those that have been fully received, rejected, or cancelled) will be omitted from search results.  Use this filter option to include them.
  includeClosed: Boolean
  sourceDocTypes: [SourceDocTypeEnum!]
  sourceDocName: String
}

# An item that is expected to be received
type ReceivingItemV2 {
  id: String!
  createdAt: Date!
  updatedAt: Date!
  companyId: String!
  company: Company!
  locationId: String!
  location: Location!
  vendorItemId: String
  vendorItem: VendorItem
  ingredientId: String
  ingredient: Ingredient
  recipeId: String
  recipe: Recipe
  vendorId: String
  vendor: Vendor
  sourceLocationId: String
  sourceLocation: Location
  purchaseOrderId: String
  purchaseOrder: PurchaseOrder
  purchaseOrderItemId: String
  purchaseOrderItem: PurchaseOrderItem
  transferOrderId: String
  transferOrder: TransferOrder
  transferOrderItemId: String
  transferOrderItem: TransferOrderItem
  expectedDeliveryDate: Date

  # The amount still expected after counting all receivingItemEvents.
  outstandingQuantity: Float!
  outstandingUnitId: String!
  outstandingUnit: Unit
  receivingItemEvents: [ReceivingItemEvent!]!
}

type Recipe implements MediaEntity & HasNutritionalFieldsAndQuantity {
  id: ID!
  files: Files!
  recipePhoto: EntityMedia
  media: [EntityMedia!]!
  name: String!
  externalName: String
  instructions: String
  notes: String
  description: String
  yieldUnitDeprecated: String
  isDish: Boolean
  shelfLifeDays: Float
  prepTime: Int
  shortCode: String
  nutritionalsQuantity: Float
  nutritionalsServingsPerContainer: Float
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  priceCents: Int
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String
  variationOfRecipeId: String
  creatorId: String

  # PDCAAS (Protein Digestibility Corrected Amino Acid Score) is used to adjust the Protein DV% of a recipe to account for the quality of the protein
  pdcaas: Float
  nutritionalsUnit: Unit
  recipeVariationRemovals(
    recipeVariationId: String
  ): [RecipeVariationRemoval!]!
    @deprecated(reason: "will be replaced with Connections")
  originalRecipeItems: [RecipeItem!]!

  # This is a list of derived recipe items that may include a variation's parent recipe items
  recipeItems: [RecipeItem!]!
  recipeInstructions: [RecipeInstruction!]!
  originalRecipeInstructions: [RecipeInstruction!]!
  versions(limit: Int): [Version!]!
  recipeVariationRules: [RecipeVariationRule!]!
    @deprecated(reason: "will be replaced with Connections")
  recipeView: [RecipeViews!]!
  parentRecipeItems: [RecipeItem!]!
  upcomingMenus: [Menu!]!
  menuItems: [MenuItem!]!
  usagesCount: Int!
  units: [Unit!]!
  unitConversions: [UnitConversion!]!
  categoryValues: [CategoryValue!]!
  recipeVariations: [Recipe!]!
  variationOfRecipe: Recipe
  isVariation: Boolean
  haccpRules: [HaccpRule!]!
  inventoryUnit: Unit
  subLocationItems(locationId: String): [SubLocationItem!]!
  caloriesPercentDRV: Float
  totalFatPercentDRV: Float
  saturatedFatPercentDRV: Float
  transFatPercentDRV: Float
  cholesterolPercentDRV: Float
  sodiumPercentDRV: Float
  carbsPercentDRV: Float
  fiberPercentDRV: Float
  sugarPercentDRV: Float
  addedSugarPercentDRV: Float
  proteinPercentRDI: Float
  vitaminAPercentRDI: Float
  vitaminB6PercentRDI: Float
  vitaminB12PercentRDI: Float
  vitaminCPercentRDI: Float
  vitaminDPercentRDI: Float
  vitaminEPercentRDI: Float
  vitaminKPercentRDI: Float
  calciumPercentRDI: Float
  ironPercentRDI: Float
  thiaminPercentRDI: Float
  riboflavinPercentRDI: Float
  niacinPercentRDI: Float
  folatePercentRDI: Float
  biotinPercentRDI: Float
  pantothenicAcidPercentRDI: Float
  phosphorusPercentRDI: Float
  iodinePercentRDI: Float
  magnesiumPercentRDI: Float
  zincPercentRDI: Float
  seleniumPercentRDI: Float
  copperPercentRDI: Float
  manganesePercentRDI: Float
  chromiumPercentRDI: Float
  molybdenumPercentRDI: Float
  chloridePercentRDI: Float
  potassiumPercentRDI: Float
  cholinePercentRDI: Float

  # A recipe's calculated nutritional value of a recipe is determined by summing the amount of a given nutrient found in each recipe item multiplied by the contribution percentage of that recipe item.
  #
  # sum({recipe item reconciled nutritional} * {recipe item contribution %})
  calculatedNutritionals(
    locationId: String
    scaleQuantityUnit: QuantityUnitInput
  ): CalculatedNutritionals!

  # A recipe's reconciled nutritional value will be equal to a manually set nutritional value if it exists. If not, the calculated nutritional value will be used.
  #
  # A nutritional value is calculated by summing the amount of a given nutrient found in each recipe item multiplied by the contribution percentage of that recipe item.
  #
  # IF({manually set value}!=null) THEN {manually set value}
  #
  # ELSE sum({recipe item reconciled nutritional} * {recipe item contribution %})
  reconciledNutritionals(
    locationId: String
    scaleQuantityUnit: QuantityUnitInput
  ): ReconciledNutritionals!
  allIngredients(locationId: String): [String!]!
  dietaryFlagsWithUsages(locationId: String): [DietaryFlagWithUsage!]!
  foodCostCents(locationId: String): Float
  foodCostCentsUnitValues(
    includeAll: Boolean
    locationId: String
  ): [UnitValue!]!
  unitFoodCostCents(locationId: String): Float
  unitFoodCostCentsUnitValues(
    includeAll: Boolean
    locationId: String
  ): [UnitValue!]!
  ingredientsWithUsages(locationId: String): [IngredientWithUsages!]!
  allIngredientsWithUsages(locationId: String): [IngredientWithUsages!]!
  label: String!
  parsedRecipeItems(text: String!): [ParsedRecipeItem!]!
  concepts: [Concept!]!

  # A flat list of all the components in a recipe tree.
  # Params:
  #   levels: Provide an array of integers only return the components at a certain level of the tree, 0 indexed. Pass -1 as one of the values to get the leaf nodes of the tree
  recipeTreeComponents(
    scaledYield: Float
    scaledUnitId: String
    levels: [Int!]
  ): [RecipeTreeComponent!]!
  versionConnection(
    paginationOptions: PaginationOptions
    filters: RecipeVersionConnectionFilter
  ): RecipeVersionConnection!
  totalYield: Float
  totalYieldUnitValues(includeAll: Boolean): [UnitValue!]!
  originalTotalYield: Float
  yieldUnit: Unit
  originalYieldUnit: Unit
  yieldPercent: Float
  nutritionLabel(
    labelType: LabelType!
    allergensList: String
    ingredientsList: String
    servingSizeQuantity: Float
    servingSizeUnit: NutritionLabelServingSizeUnit
    servingsPerContainer: Float
    showAllergens: Boolean
    showIngredients: Boolean
    showProteinDV: Boolean
    showServingsPerContainer: Boolean
    locationId: String
  ): NutritionLabel
}

type RecipeConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [RecipeConnectionEdge!]!
}

type RecipeConnectionEdge {
  index: Int!
  node: Recipe!
}

input RecipeConnectionFilter {
  id: [String]
  conceptId: [String!]
  isUnused: Boolean
  hasNoProcedures: Boolean
  isDish: Boolean
  categoryValueIdsBooleanExpressionFilterJSON: CategoryValueIdFilterBooleanExpressionType
  dietaryFlagsIdBooleanExpressionFilterJSON: DietaryFlagsIdFilterBooleanExpressionType
  name: String
  updatedAt: TimestampFilter
  dietaryFlagLastChangedAt: TimestampFilter
  ingredientsWithUsagesLastChangedAt: TimestampFilter
  nutritionalValuesLastChangedAt: TimestampFilter

  # Use query to fuzzy search by various fields like name and sku.
  query: String
}

input RecipeInput {
  id: String
  name: String
  externalName: String
  instructions: String
  notes: String
  description: String
  totalYield: Float
  yieldUnitDeprecated: String
  isDish: Boolean
  shelfLifeDays: Float
  prepTime: Int
  pdcaas: Float
  shortCode: String
  nutritionalsQuantity: Float
  nutritionalsServingsPerContainer: Float
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  priceCents: Int
  companyId: String
  variationOfRecipeId: String
  creatorId: String
  units: UnitInput
  yieldUnit: UnitInput
  inventoryUnit: UnitInput
  nutritionalsUnit: UnitInput
}

type RecipeInstruction {
  # The ID of an object
  id: ID!
  text: String!
  position: Int!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  recipeId: String!
  companyId: String
  recipe: Recipe!
}

input RecipeInstructionInput {
  id: String
  text: String!
  deletedAt: Date
  position: Int
}

type RecipeItem {
  # The ID of an object
  id: ID!
  quantity: Float
  unitDeprecated: String
  position: Int
  nutrientsContributionPercent: Float
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  ingredientId: String
  recipeId: String
  subRecipeId: String
  companyId: String!

  # The recipe item's parent recipe
  recipe: Recipe!

  # The recipe item's ingredient
  ingredient: Ingredient
  originalSubRecipeId: String

  # The recipe item's ingredient
  originalSubRecipe: Recipe

  # The subrecipe or subrecipe variation derived via variation rules
  subRecipe: Recipe
  preparations: [Preparation!]!
  recipeItemPreparations: [RecipeItemPreparation!]!
    @deprecated(reason: "will be replaced with Connections")
  unit: Unit
  reconciledNutritionals(locationId: String): ReconciledNutritionals!
  foodCostCents(locationId: String): Float
  foodCostCentsError(locationId: String): FoodCostCentsError
  untrimmedQuantity: Float
}

type RecipeItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [RecipeItemConnectionEdge!]!
}

type RecipeItemConnectionEdge {
  index: Int!
  node: RecipeItem!
}

input RecipeItemConnectionFilter {
  recipeIds: [String!]
  ingredientIds: [String!]
  subRecipeIds: [String!]
}

enum RecipeItemConnectionOrderByEnum {
  CreatedAt
  RecipeName
}

input RecipeItemConnectionPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: RecipeItemConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

input RecipeItemInput {
  id: String
  quantity: Float
  unitDeprecated: String
  position: Int
  nutrientsContributionPercent: Float
  recipeId: String
  unit: UnitInput
  ingredientId: String
  subRecipeId: String
  preparationIds: [String]
}

type RecipeItemPreparation {
  # The ID of an object
  id: ID!
  position: Int
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  preparationId: String
  recipeItemId: String
  preparation: Preparation!
  recipeItem: RecipeItem!
}

input RecipeItemPreparationInput {
  id: String
  position: Int
  preparationId: String
  recipeItemId: String
}

type RecipeProductionDependencies {
  parents: [ProductionScheduleRecipe]
  children: [ProductionScheduleRecipe]
}

type RecipeProductionOutput {
  date: String!
  recipeId: String!
  recipeName: String!
  recipeLabel: String
  recipeVolume: Float!
  recipePrepTime: Int!
  recipeTotalPrepTime: Int!
  recipeShelfLifeDays: Int!
  recipeUnitId: String!
  recipeUnitName: String!
  recipeDependencies: RecipeProductionDependencies!
}

type RecipeTreeComponent {
  id: ID!
  ingredient: Ingredient
  recipeItem: RecipeItem
  recipe: Recipe
  quantity: Float
  untrimmedQuantity: Float
  unit: Unit
  quantityUnitValues(includeAll: Boolean): [UnitValue!]!
  untrimmedQuantityUnitValues(includeAll: Boolean): [UnitValue!]!
  costCents: Float
  costCentsUnitValues(includeAll: Boolean): [UnitValue!]!
  costUnit: Unit
  totalCostCents: Float
  ancestorComponentIds: [String!]!
}

type RecipeUsage {
  unit: Unit
  quantity: Float
  costCents: Float
  untrimmedQuantity: Float
  recipeItem: RecipeItem!
  ancestorRecipes: [Recipe!]!
  ancestorRecipesWithUsages: [RecipeWithUsage!]!
}

type RecipeVariationRemoval {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  recipeVariationId: String
  recipeItemId: String
  recipeItem: RecipeItem
}

input RecipeVariationRemovalInput {
  id: String
  recipeVariationId: String
  recipeItemId: String
}

type RecipeVariationRule {
  # The ID of an object
  id: ID!
  predicateType: RecipeVariationRulePredicateType!
  predicateValue: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  recipeId: String
  recipeVariationId: String
  recipeVariation: Recipe!
  recipe: Recipe!
}

input RecipeVariationRuleInput {
  id: String
  predicateType: String!
  predicateValue: String!
  recipeId: String
  recipeVariationId: String
}

enum RecipeVariationRulePredicateType {
  isLocation
  isLocationGroup
  isConcept
}

type RecipeVersionConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [RecipeVersionConnectionEdge!]!
}

type RecipeVersionConnectionEdge {
  index: Int!
  node: Version!
}

input RecipeVersionConnectionFilter {
  since: Date
}

type RecipeViews {
  # The ID of an object
  id: ID!
  name: String!
  settings: SequelizeJSON!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  recipeId: String!
  companyId: String
  recipe: Recipe!
}

type RecipeWithUsage {
  recipe: Recipe!
  usage: UsageQuantityUnit!
}

type ReconciledDietaryFlag {
  # The ID of an object
  id: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  dietaryFlagItems: [DietaryFlagItem!]!
    @deprecated(reason: "will be replaced with Connections")
  isCanonical: Boolean! @deprecated(reason: "will be removed")
  shouldShowOnNutritionLabel: Boolean!
  source: ReconciledDietaryFlagSource!
}

union ReconciledDietaryFlagSource = Ingredient | VendorItem

# ReconciledNutritionals factor in all nutritional logic to return nutritional values as they appear in the Galley UI.
type ReconciledNutritionals implements HasNutritionalFields {
  # The manually set amount of caloriesKCal. To find the quantity as it appears in the UI, use reconciledNutritionals.
  caloriesKCal: Float

  # The manually set amount of totalFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  totalFatG: Float

  # The manually set amount of saturatedFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  saturatedFatG: Float

  # The manually set amount of transFatG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  transFatG: Float

  # The manually set amount of cholesterolMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholesterolMg: Float

  # The manually set amount of sodiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sodiumMg: Float

  # The manually set amount of carbsG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  carbsG: Float

  # The manually set amount of fiberG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  fiberG: Float

  # The manually set amount of sugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  sugarG: Float

  # The manually set amount of addedSugarG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  addedSugarG: Float

  # The manually set amount of proteinG. To find the quantity as it appears in the UI, use reconciledNutritionals.
  proteinG: Float

  # The manually set amount of vitaminAMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminAMcg: Float

  # The manually set amount of vitaminB6Mg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB6Mg: Float

  # The manually set amount of vitaminB12Mcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminB12Mcg: Float

  # The manually set amount of vitaminCMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminCMg: Float

  # The manually set amount of vitaminDMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminDMcg: Float

  # The manually set amount of vitaminEMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminEMg: Float

  # The manually set amount of vitaminKMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  vitaminKMcg: Float

  # The manually set amount of calciumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  calciumMg: Float

  # The manually set amount of ironMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  ironMg: Float

  # The manually set amount of thiaminMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  thiaminMg: Float

  # The manually set amount of riboflavinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  riboflavinMg: Float

  # The manually set amount of niacinMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  niacinMg: Float

  # The manually set amount of folateMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  folateMcg: Float

  # The manually set amount of biotinMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  biotinMcg: Float

  # The manually set amount of pantothenicAcidMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  pantothenicAcidMg: Float

  # The manually set amount of phosphorusMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  phosphorusMg: Float

  # The manually set amount of iodineMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  iodineMcg: Float

  # The manually set amount of magnesiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  magnesiumMg: Float

  # The manually set amount of zincMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  zincMg: Float

  # The manually set amount of seleniumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  seleniumMcg: Float

  # The manually set amount of copperMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  copperMg: Float

  # The manually set amount of manganeseMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  manganeseMg: Float

  # The manually set amount of chromiumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chromiumMcg: Float

  # The manually set amount of molybdenumMcg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  molybdenumMcg: Float

  # The manually set amount of chlorideMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  chlorideMg: Float

  # The manually set amount of potassiumMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  potassiumMg: Float

  # The manually set amount of cholineMg. To find the quantity as it appears in the UI, use reconciledNutritionals.
  cholineMg: Float
  caloriesPercentDRV: Float
  totalFatPercentDRV: Float
  saturatedFatPercentDRV: Float

  # This field will always return null as there is no recommendation for daily intake
  transFatPercentDRV: Float
  cholesterolPercentDRV: Float
  sodiumPercentDRV: Float
  carbsPercentDRV: Float
  fiberPercentDRV: Float

  # This field will always return null as there is no recommendation for daily intake
  sugarPercentDRV: Float
  addedSugarPercentDRV: Float
  proteinPercentRDI: Float
  vitaminAPercentRDI: Float
  vitaminB6PercentRDI: Float
  vitaminB12PercentRDI: Float
  vitaminCPercentRDI: Float
  vitaminDPercentRDI: Float
  vitaminEPercentRDI: Float
  vitaminKPercentRDI: Float
  calciumPercentRDI: Float
  ironPercentRDI: Float
  thiaminPercentRDI: Float
  riboflavinPercentRDI: Float
  niacinPercentRDI: Float
  folatePercentRDI: Float
  biotinPercentRDI: Float
  pantothenicAcidPercentRDI: Float
  phosphorusPercentRDI: Float
  iodinePercentRDI: Float
  magnesiumPercentRDI: Float
  zincPercentRDI: Float
  seleniumPercentRDI: Float
  copperPercentRDI: Float
  manganesePercentRDI: Float
  chromiumPercentRDI: Float
  molybdenumPercentRDI: Float
  chloridePercentRDI: Float
  potassiumPercentRDI: Float
  cholinePercentRDI: Float
  itemWithErrors: [ItemWithErrors!]

  # A timestamp of when a change was last made to a recipe tree that could have effected the reconciledNutritionals cache. If the values returned by reconciledNutritionals are not from the cache, the result will be null.
  lastChangedAt: Date

  # A timestamp of when a change was last made to a recipe tree that could have effected the reconciledNutritionals cache. If the values returned by reconciledNutritionals are not from the cache, the result will be null.
  lastSyncedAt: Date
}

type ReconciledNutritionValue {
  source: NutritionalItemUnion
  fallbackValue: Float
  value: Float
}

type ReconciledNutritionValues {
  nutritionalsQuantity: Float
  nutritionalsUnit: Unit
  caloriesKCalDetailed: ReconciledNutritionValue!
  totalFatGDetailed: ReconciledNutritionValue!
  saturatedFatGDetailed: ReconciledNutritionValue!
  transFatGDetailed: ReconciledNutritionValue!
  cholesterolMgDetailed: ReconciledNutritionValue!
  sodiumMgDetailed: ReconciledNutritionValue!
  carbsGDetailed: ReconciledNutritionValue!
  fiberGDetailed: ReconciledNutritionValue!
  sugarGDetailed: ReconciledNutritionValue!
  addedSugarGDetailed: ReconciledNutritionValue!
  proteinGDetailed: ReconciledNutritionValue!
  vitaminAMcgDetailed: ReconciledNutritionValue!
  vitaminB6MgDetailed: ReconciledNutritionValue!
  vitaminB12McgDetailed: ReconciledNutritionValue!
  vitaminCMgDetailed: ReconciledNutritionValue!
  vitaminDMcgDetailed: ReconciledNutritionValue!
  vitaminEMgDetailed: ReconciledNutritionValue!
  vitaminKMcgDetailed: ReconciledNutritionValue!
  calciumMgDetailed: ReconciledNutritionValue!
  ironMgDetailed: ReconciledNutritionValue!
  thiaminMgDetailed: ReconciledNutritionValue!
  riboflavinMgDetailed: ReconciledNutritionValue!
  niacinMgDetailed: ReconciledNutritionValue!
  folateMcgDetailed: ReconciledNutritionValue!
  biotinMcgDetailed: ReconciledNutritionValue!
  pantothenicAcidMgDetailed: ReconciledNutritionValue!
  phosphorusMgDetailed: ReconciledNutritionValue!
  iodineMcgDetailed: ReconciledNutritionValue!
  magnesiumMgDetailed: ReconciledNutritionValue!
  zincMgDetailed: ReconciledNutritionValue!
  seleniumMcgDetailed: ReconciledNutritionValue!
  copperMgDetailed: ReconciledNutritionValue!
  manganeseMgDetailed: ReconciledNutritionValue!
  chromiumMcgDetailed: ReconciledNutritionValue!
  molybdenumMcgDetailed: ReconciledNutritionValue!
  chlorideMgDetailed: ReconciledNutritionValue!
  potassiumMgDetailed: ReconciledNutritionValue!
  cholineMgDetailed: ReconciledNutritionValue!
}

input ReefCreateComponentCycleCountInput {
  menuIds: [String!]!
  date: DateOnly
}

type ReefCreateComponentCycleCountPayload {
  cycleCount: CycleCount
  error: Error
}

input ReefCreateRequisitionOrderInput {
  menuIds: [String!]!
  timestamp: String
}

type ReefCreateRequisitionOrderPayload {
  purchaseOrder: PurchaseOrder
  purchaseOrders: [PurchaseOrder!]
  error: Error
}

# The input required to make a rejectItem mutation
input RejectItemInput {
  eventDate: Date
  receivingItemId: String!
  quantity: Float!
  unitId: String!
  costUnitId: String
  costCents: Float

  # If provided, must be a valid UUID.
  idempotenceKey: String
  reason: ReceivingItemRejectedReason!

  # Provide details about your reason.
  description: String
  invoiceNumber: String
}

input RemoveMenuFromEventInput {
  eventId: String!
  menuId: String!
}

type RemoveMenuFromEventPayload {
  error: Error
  event: Event
}

# A reorder collection instruction input is a set of information required to reorder the instructions inside a collection.
input ReorderCollectionInstructionsInput {
  instructionIds: [String!]!
  collectionId: String!
}

# A reorder collection instruction payload is the result of a collection instruction reorder, with an error or the collection instruction ids reordered.
type ReorderCollectionInstructionsPayload {
  error: Error
  instructions: [CollectionInstruction!]
}

# A reorder collection items input contains the ids of the collection components to be reordered from a specific collection.
input ReorderCollectionItemsInput {
  collectionItemIds: [String!]!
  parentCollectionId: String!
}

# A reorder collection items payload is the result of a collection component reorder, with an error or the collection components listed in the new order.
type ReorderCollectionItemsPayload {
  error: Error
  items: [CollectionItem!]
}

# A list of ids of cycleCountTemplateItems in the order you would like them to be
# and the id of the cycleCountTemplate that the cycleCountTemplateItems belong to
input ReorderCycleCountTemplateItemsInput {
  cycleCountTemplateItemIds: [String]
  cycleCountTemplateId: String
}

#  The reordered cycleCountTemplateItems or the error that occured when trying to reorder.
type ReorderCycleCountTemplateItemsPayload {
  error: Error
  cycleCountTemplateItems: [CycleCountTemplateItem]
}

input ReorderIngredientVendorItemsInput {
  vendorItemIds: [String]
  ingredientId: String
  locationId: String!
}

type ReorderIngredientVendorItemsPayload {
  error: Error
  ingredient: Ingredient
}

input ReorderMenuItemsInput {
  menuItemIds: [String]
  menuId: String
}

type ReorderMenuItemsPayload {
  error: Error
  menuItems: [MenuItem]
}

input ReorderMenuPlanPOCMenuItemsInput {
  menuItemIds: [String]
  menuId: String
}

type ReorderMenuPlanPOCMenuItemsPayload {
  error: Error
  menuItems: [MenuItem]
}

input ReorderMenuTemplateItemInput {
  menuTemplateItemIds: [String!]!
}

type ReorderMenuTemplateItemPayload {
  error: Error
  menuTemplateItems: [MenuTemplateItem]
}

input ReorderRecipeInstructionsInput {
  recipeInstructionIds: [String]
  recipeId: String
}

type ReorderRecipeInstructionsPayload {
  error: Error
  recipeInstructions: [RecipeInstruction]
}

input ReorderRecipeItemPreparationsInput {
  recipeItemId: ID!
  recipeItemPreparationIds: [ID!]!
}

type ReorderRecipeItemPreparationsPayload {
  recipeItem: RecipeItem
  error: Error
}

input ReorderRecipeItemsInput {
  recipeItemIds: [String]
  recipeId: String
}

type ReorderRecipeItemsPayload {
  error: Error
  recipeItems: [RecipeItem]
}

input ReorderSubLocationItemsInput {
  locationId: String!
  subLocationId: String!
  itemIds: [String!]!
}

type ReorderSubLocationItemsPayload {
  subLocationItems: [SubLocationItem]
  error: Error
}

input ReplaceUnitInput {
  sourceUnitId: String!
  destinationUnitId: String
}

type ReplaceUnitPayload {
  unit: Unit
  error: Error
}

# Input type for reprocessing invoice data matching. Contains a field id for the invoice to be reprocessed.
input ReprocessInvoiceDataMatchingInput {
  id: String!
}

# Payload type for the ReprocessInvoiceDataMatching mutation. Contains a field id which represents the reprocessed invoice's ID.
type ReprocessInvoiceDataMatchingPayload {
  id: String
}

input RequestDraftOrdersInput {
  menuIds: [String!]!
  options: RequestDraftOrdersOptionsInput
}

input RequestDraftOrdersOptionsInput {
  isSplitByConcept: Boolean
  destinationLocationId: String
  vendorIds: [String!]
  allowAlternateVendorItems: Boolean
}

type RequestDraftOrdersPayload {
  jobId: String!
}

#  RequestMenuPlanProductionScheduleInput represents the parameters required to create production schedule from menu plan events.
input RequestMenuPlanProductionScheduleInput {
  menuPlanEventIds: [ID!]!
  name: String!
  batch: Boolean!
}

#  RequestMenuPlanProductionScheduleResponse represents the response of RequestMenuPlanProductionSchedule.
type RequestMenuPlanProductionScheduleResponse {
  correlationId: String!
}

#  RequestMenuPlanPurchaseGuideInput represents the parameters required to create purchase guide from menu plan events.
input RequestMenuPlanPurchaseGuideInput {
  menuPlanEventIds: [ID!]!
  vendorIds: [ID!]!
  allowAlternateVendorItems: Boolean!
}

#  RequestMenuPlanPurchaseGuideResponse represents the response of RequestMenuPlanPurchaseGuide.
type RequestMenuPlanPurchaseGuideResponse {
  correlationId: String!
}

input ResetPasswordInput {
  id: String!
}

type ResetPasswordPayload {
  error: Error
  viewer: Viewer
}

input ResolveSuspendedInventoryTaskInput {
  taskId: String!
  unitConversion: ResolveSuspendedInventoryTaskUnitConversionInput!
}

type ResolveSuspendedInventoryTaskPayload {
  error: Error
}

input ResolveSuspendedInventoryTaskUnitConversionInput {
  accountingUnitQuantity: Float!
  taskUnitQuantity: Float!
}

input RestoreRecipeInput {
  id: String!
}

type RestoreRecipePayload {
  error: Error
  recipe: Recipe
}

input RevokeApiAccessMutationInput {
  companyId: String!
}

type RevokeApiAccessMutationPayload {
  company: Company
}

type Role {
  id: ID!
  name: String!
  description: String
}

type SecurityMappings {
  claimPolicyMappings: [ClaimPolicyMapping]!
  locationMappings: [LocationMapping]!
}

type SendFreemiumWelcomeEmail {
  user: User
  error: Error
}

input SendFreemiumWelcomeEmailInput {
  userId: String!
}

input SendLMSEmailInput {
  userId: String!
}

type SendLMSEmailPayload {
  user: User
  error: Error
}

input SendWelcomeEmailInput {
  userId: String!
}

type SendWelcomeEmailPayload {
  error: Error
  user: User
}

# The `JSON` scalar type represents raw JSON as values.
scalar SequelizeJSON

type ServiceScope {
  isGlobal: Boolean!
  servicedLocations: [Location!]!
}

input SetCategoryValueItemsInput {
  itemGlobalId: String!
  categoryValueIds: [String!]!
}

type SetCategoryValueItemsPayload {
  categoryValueItems: [CategoryValueItem!]!
}

input SetDefaultSubLocationInput {
  subLocationId: String!
}

type SetDefaultSubLocationPayload {
  subLocation: SubLocation
  error: Error
}

# Location to printer result
type SetLocationToPrinterResult {
  printerID: ID!
  locationID: ID!
}

input SetOrderCategoryValueItemsInput {
  orderId: String!
  categoryValueIds: [String!]!
}

input SetPurchasingUnitInput {
  vendorItemId: String!
  purchasingUnitId: String!
}

type SetPurchasingUnitPayload {
  vendorItem: VendorItem
}

input SetUserAttributeInput {
  userId: String!
  attributeName: String!
  attributeValueJSON: String!
}

type SetUserAttributePayload {
  user: User
}

input SetVendorItemCostInput {
  vendorItemId: String!
  costCents: Float!
  costUnit: UnitInput!
  source: String!
  type: CostTypeEnum!
  startsAt: String
  endsAt: String
}

type SetVendorItemCostPayload {
  vendorItem: VendorItem
  error: Error
}

type ShareableHaccpRule {
  description: String!
  name: String!
}

type ShareableIngredient {
  name: String!
}

type ShareablePreparations {
  name: String!
}

type ShareableRecipe {
  id: ID!
  displayedSections: ShareableRecipeDisplayedSections!
  recipePhoto: ShareableRecipePhoto
  label: String!
  totalYield: Float
  yieldUnit: ShareableRecipeUnit
  recipeItems: [ShareableRecipeItem!]!
  recipeInstructions: [ShareableRecipeInstruction!]!
  notes: String
  haccpRules: [ShareableHaccpRule!]!
  reconciledNutritionals: ShareableRecipeReconciledNutritionals
  allIngredients: [String!]!
  nutritionalsQuantity: Float
  nutritionalsUnit: ShareableRecipeUnit
}

type ShareableRecipeDisplayedSections {
  hasImageDisplayed: Boolean!
  hasComponentsDisplayed: Boolean!
  hasHaccpDisplayed: Boolean!
  hasInstructionsDisplayed: Boolean!
  hasNotesDisplayed: Boolean!
  hasNutritionalDisplayed: Boolean!
}

type ShareableRecipeInstruction {
  text: String!
}

type ShareableRecipeItem {
  quantity: Float
  untrimmedQuantity: Float
  unit: ShareableRecipeUnit
  preparations: [ShareablePreparations!]!
  ingredient: ShareableIngredient
  subRecipe: ShareableSubRecipe
}

# Limited set of attributes for recipe photo
type ShareableRecipePhoto {
  sourceUrl: String
  caption: String
  altText: String
}

type ShareableRecipeReconciledNutritionals {
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  caloriesPercentDRV: Float
  totalFatPercentDRV: Float
  saturatedFatPercentDRV: Float
  transFatPercentDRV: Float
  cholesterolPercentDRV: Float
  sodiumPercentDRV: Float
  carbsPercentDRV: Float
  fiberPercentDRV: Float
  sugarPercentDRV: Float
  addedSugarPercentDRV: Float
  proteinPercentRDI: Float
  vitaminAPercentRDI: Float
  vitaminB6PercentRDI: Float
  vitaminB12PercentRDI: Float
  vitaminCPercentRDI: Float
  vitaminDPercentRDI: Float
  vitaminEPercentRDI: Float
  vitaminKPercentRDI: Float
  calciumPercentRDI: Float
  ironPercentRDI: Float
  thiaminPercentRDI: Float
  riboflavinPercentRDI: Float
  niacinPercentRDI: Float
  folatePercentRDI: Float
  biotinPercentRDI: Float
  pantothenicAcidPercentRDI: Float
  phosphorusPercentRDI: Float
  iodinePercentRDI: Float
  magnesiumPercentRDI: Float
  zincPercentRDI: Float
  seleniumPercentRDI: Float
  copperPercentRDI: Float
  manganesePercentRDI: Float
  chromiumPercentRDI: Float
  molybdenumPercentRDI: Float
  chloridePercentRDI: Float
  potassiumPercentRDI: Float
  cholinePercentRDI: Float
}

type ShareableRecipeUnit {
  name: String!
}

type ShareableRecipeView {
  id: ID!
  settings: JSONType!
  settingsJSON: JSONType! @deprecated(reason: "Use settings field instead")
  recipes: [ShareableRecipe!]!
}

type ShareableSubRecipe {
  label: String!
}

# Enum representing the sort direction (ascending or descending) for sorting lists.
enum SortDirectionEnum {
  desc
  asc
}

# The types of fields that a Catalog can be sorted by
enum SortFieldCatalogEnum {
  id
  name
}

# The types of fields that a CatalogItem can be sorted by
enum SortFieldCatalogItemEnum {
  id
}

# Enum representing different fields that can be used for sorting the invoices.
enum SortFieldInvoiceEnum {
  createdAt
  invoiceNumber
  invoiceDate
  updatedAt
  source
  currentStatus
  totalCostCents
}

# Enum representing different fields that can be used for sorting the invoice items.
enum SortFieldInvoiceItemEnum {
  createdAt
  updatedAt
}

# The invoice rule order by enum lists the options available to order the invoice rule list.
enum SortFieldInvoiceRuleEnum {
  createdAt
}

# SortFieldProductEnum allow to sort by createdAt
enum SortFieldProductEnum {
  createdAt
}

enum SortingLotFieldEnum {
  code
  createdAt
  expirationDate
  locationName
  totalCostCents
}

# The types of source documents that can be received from
enum SourceDocTypeEnum {
  # A Galley internal purchaseOrder.
  purchaseOrder

  # A Galley internal transferOrder.
  transferOrder
  packSlip
}

enum SourceEventEnum {
  PRODUCED_FINISHED_GOOD
  RECEIVED_PURCHASED_ITEM
}

type Statement {
  id: String
  effect: String!
  actions: [String!]!
  resource: String!
  conditions: JSONType
}

input StatementInput {
  effect: String!
  actions: [String!]!
  resource: String!
  conditions: JSONType
}

enum Status {
  PENDING
  STARTED
  COMPLETE
  FAILED
  COMPLETE_WITH_ERRORS
}

# Enum representing various invoice statuses such as DRAFT, APPROVED, COMPLETED, ARCHIVED, and DUPLICATED.
enum StatusEnum {
  APPROVED
  ARCHIVED
  COMPLETED
  DRAFT
  DUPLICATED
  MATCHING_COMPLETED
  MATCHING_FAILED
  MATCHING_REQUIRES_REVIEW
  MATCHING_STARTED
}

type Sublocation {
  id: String!
  name: String!
  location: Location!
  company: Company!
  isDefault: Boolean!
}

type SubLocation {
  id: String!
  name: String!
  location: Location!
  company: Company!
  isDefault: Boolean!
  subLocationItems: [SubLocationItem!]!
}

type SubLocationConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [SubLocationConnectionEdge!]!
}

type SubLocationConnectionEdge {
  index: Int!
  node: SubLocation!
}

input SubLocationConnectionFilter {
  id: [String!]
}

type SubLocationItem {
  id: String!
  location: Location!
  company: Company!
  subLocation: SubLocation!
  item: SubLocationItemItem!
  vendorItem: VendorItem
  recipe: Recipe
  position: Int!
}

input SubLocationItemInput {
  locationId: String!
  subLocationId: String!
  itemType: SubLocationItemItemType!
  itemId: String!
}

union SubLocationItemItem = Recipe | VendorItem

enum SubLocationItemItemType {
  Recipe
  VendorItem
}

#  The id of the cycleCount to be submitted.
input SubmitCycleCountInput {
  id: String!
}

#  The submitted cycleCount or the error that occured when trying to submit.
type SubmitCycleCountPayload {
  error: Error
  cycleCount: CycleCount
}

#  Summary.
type Summary {
  weekSummaries: [WeekSummary!]
  totalCost: Float!
  totalBudgetConsumedPercentage: Float!
  plateCost: Float!
  weeklyTargetBudget: Float!
}

type Template {
  id: String!
  name: String!
  entityType: TemplateEntityType!
  workflowType: TemplateWorkflowType!
  isGeneric: Boolean!
  companyId: String
  description: String
  storageId: String
  fileName: String
}

enum TemplateEntityType {
  RECIPE
  PRODUCTION
}

input TemplateFiltersType {
  workflowType: TemplateWorkflowType
}

enum TemplateWorkflowType {
  RECIPE
  PRODUCTION
}

input TimestampFilter {
  # 'le' is "less than or equal to" and takes an ISO Formatted String such as "2022-01-01T12:00:00.123Z"
  le: ISODate

  # 'ge' is "greater than or equal to" and takes an ISO Formatted String such as "2022-01-01T12:00:00.123Z"
  ge: ISODate
}

# Input type for turn on and off  an invoice auto approve rule. Contains a field id for the invoice approval rule to be match.
input ToggleInvoiceAutoApproveRuleInput {
  id: String!
}

type TransferOrder implements Order {
  # The ID of an object
  id: ID!
  orderType: OrderTypeEnum!
  name: String!
  number: Int!
  deliveryDate: DateOnly
  status: String
  categoryValues: [OrderCategoryValue!]!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  company: Company!
  creatorId: String
  creator: User
  destinationLocationId: String
  destinationLocation: Location!
  sourceLocationId: String!
  sourceLocation: Location!
  menuIds: [String!]!
  menus: [Menu!]!
  transferOrderItems: [TransferOrderItem!]!
  validTargetStatuses: [String!]!
  concept: Concept
  conceptId: String
  notes: String
  candidateTransferOrderItem(
    filter: CandidateTransferOrderItemFilter
  ): TransferOrderItemResult
}

type TransferOrderItem {
  # The ID of an object
  id: ID!
  quantity: Float
  unit: Unit
  unitId: String
  quantityUnitValues(includeAll: Boolean): [UnitValue!]!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  transferOrderId: String
  ingredientId: String
  recipeId: String
  companyId: String!
  transferOrder: TransferOrder!
  ingredient: Ingredient
  recipe: Recipe
  unitCostCents: Float
  totalCostCents: Float
  notes: String
}

type TransferOrderItemIngredient {
  id: String!
  name: String
}

input TransferOrderItemInput {
  id: String
  quantity: Float
  ingredientId: String
  recipeId: String
  unit: UnitInput
  notes: String
}

type TransferOrderItemRecipe {
  id: String!
  name: String
}

type TransferOrderItemResult {
  recipes: [TransferOrderItemRecipe]
  ingredients: [TransferOrderItemIngredient]
}

input TransfersCatalogConnectionFilter {
  name: String
}

enum TransfersCatalogConnectionOrderBy {
  CreatedAt
  ExternalId
}

type TransfersCatalogDestinationLocation {
  id: ID!
  locationId: String
  locationGroupId: String
  location: Location
  locationGroup: LocationGroup
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
}

type TransfersCatalogItemsConnection {
  totalCount: Int!
  totalRecipeCount: Int!
  totalIngredientCount: Int!
  pageInfo: PageInfoType!
  edges: [TransfersCatalogItemsConnectionEdge!]!
}

type TransfersCatalogItemsConnectionEdge {
  index: Int!
  node: TransfersCatalogItemType!
}

enum TransfersCatalogItemsConnectionOrderBy {
  CreatedAt
  PriceCents
  CostCents
  Name
  Barcode
  Sku
  ExternalId
}

input TransfersCatalogItemsPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: TransfersCatalogItemsConnectionOrderBy
}

type TransfersCatalogItemType {
  barcode: String
  company: Company!
  companyId: String!
  costCents: Float
  createdAt: DateTime
  deletedAt: DateTime
  externalId: String
  id: ID!
  ingredient: Ingredient
  ingredientId: String
  leadTimeDays: Int
  name: String
  priceCents: Float
  primaryUnit: Unit
  primaryUnitId: String
  recipe: Recipe
  recipeId: String
  transfersCatalogId: String!
  sku: String
  updatedAt: DateTime
}

input TransfersCatalogPaginationOptions {
  startIndex: Int
  first: Int
  sortDirection: SortDirectionEnum
  orderBy: TransfersCatalogConnectionOrderBy
}

type TransfersCatalogsConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [TransfersCatalogsConnectionEdge!]!
}

type TransfersCatalogsConnectionEdge {
  index: Int!
  node: TransfersCatalogType!
}

input TransfersCatalogsConnectionFilter {
  sourceLocationIds: [ID!]
  destinationLocationIds: [ID!]
}

type TransfersCatalogType {
  destinationLocations: [TransfersCatalogDestinationLocation!]!
  transfersCatalogItem(id: String!): TransfersCatalogItemType
  transfersCatalogItemsConnection(
    filterOptions: TransfersCatalogConnectionFilter
    paginationOptions: TransfersCatalogItemsPaginationOptions
  ): TransfersCatalogItemsConnection
  id: ID!
  name: String
  companyId: String!
  company: Company!
  sourceLocationId: String!
  sourceLocation: Location!
  leadTimeDays: Int
  externalId: String
  deliveryDows: DeliveryDowType
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
}

input TransitionPurchaseOrderInput {
  id: String
  targetStatus: String
}

type TransitionPurchaseOrderPayload {
  error: Error
  purchaseOrder: PurchaseOrder
}

input TransitionTransferOrderInput {
  id: String
  targetStatus: String
}

type TransitionTransferOrderPayload {
  error: Error
  transferOrder: TransferOrder
}

input UnassignPoliciesInput {
  email: String!
  policies: [String!]!
}

type UnassignPoliciesPayload {
  policies: [String!]
}

input UnassignPolicyDefinitionInput {
  policyIds: [String!]!
  userId: String!
}

type UnassignPolicyDefinitionResponse {
  policies: [Policy!]!
}

input UnassignRolesInput {
  email: String!
  roles: [String!]!
}

type UnassignRolesPayload {
  roles: [String!]
}

type Unit {
  id: String!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  ingredientId: String
  recipeId: String
  companyId: String
  vendorItemId: String
  vendorItemCost: VendorItemCost
  kind: UnitKind!
  system: UnitSystem!
  nameWithCanonicalUnitConversion: String!
  unitValues(includeAll: Boolean): [UnitValue!]!
}

type UnitConversion {
  id: String!
  fromQuantity: Float!
  fromUnitDeprecated: String
  toQuantity: Float!
  toUnitDeprecated: String
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  ingredientId: String
  recipeId: String
  vendorItemId: String
  companyId: String!
  vendorItem: VendorItem
  ingredient: Ingredient
  recipe: Recipe
  fromUnit: Unit!
  fromUnitId: String!
  toUnit: Unit!
  toUnitId: String!
}

input UnitConversionInput {
  fromQuantity: Float!
  toQuantity: Float!
  ingredientId: String
  recipeId: String
  vendorItemId: String
  fromUnit: UnitInput!
  toUnit: UnitInput!
}

input UnitInput {
  id: String
  name: String
  ingredientId: String
  recipeId: String
  vendorItemId: String
}

enum UnitKind {
  VOLUME
  WEIGHT
  MISCELLANEOUS
  CUSTOM
}

enum UnitSystem {
  IMPERIAL
  METRIC
  MISCELLANEOUS
  CUSTOM
}

type UnitValue {
  value: Float
  unit: Unit!
}

input UnsuspendInventoryTasksInput {
  locationId: String!
  entityId: String!
  entityType: String!
}

type UnsuspendInventoryTasksPayload {
  error: Error
}

# The UpdateCategoryValueConstraintInput is a group of parameters required to update a constraint for category values through the updateCategoryValueConstraint mutation.
input UpdateCategoryValueConstraintInput {
  constraintId: ID!
  categoryValueItems: [CategoryValueConstraintItemInput!]!
}

input UpdateCategoryValueInput {
  categoryValue: CategoryValueInput
}

type UpdateCategoryValuePayload {
  error: Error
  categoryValue: CategoryValue
}

# An update collection input is a set of information available to be defined on a collection update.
input UpdateCollectionInput {
  id: String!
  name: String
  externalName: String
  description: String
  isDish: Boolean
  priceCents: Int
}

# An update collection instruction input is a set of information available to be updated on a collection instruction.
input UpdateCollectionInstructionInput {
  instructionId: String!
  text: String!
}

# An update collection instruction payload is the result of a collection instruction update, with an error or the collection instruction updated.
type UpdateCollectionInstructionPayload {
  error: Error
  instruction: CollectionInstruction
}

# An update collection item input is a set of information available to be defined on a collection component update.
input UpdateCollectionItemInput {
  id: String!
  position: Int
  unitId: String
  quantity: Float
}

# An update collection item payload is the result of a collection component update, with an error or the collection component updated.
type UpdateCollectionItemPayload {
  error: Error
  item: CollectionItem
}

# The UpdateCollectionItemProductConstraintInput is a group of parameters required to update a constraint for a collection item through the updateCollectionItemProductConstraint mutation.
input UpdateCollectionItemProductConstraintInput {
  name: String
  constraintId: ID!
  quantity: Int!
  productIds: [ID!]!
}

# An update collection item with optional list input is a set of information available to be defined on a collection component with optional list update.
input UpdateCollectionItemWithOptionalListInput {
  id: String!
  position: Int
  unitId: String
  quantity: Float
  constraint: CollectionItemOptionalListInput!
}

# An update collection payload is the result of a collection update, with an error or the collection updated.
type UpdateCollectionPayload {
  error: Error
  collection: Collection
}

input updateCompanySettingsInput {
  settings: JSONType
}

type updateCompanySettingsPayload {
  error: Error
  company: Company
}

input UpdateConceptInput {
  concept: ConceptInput!
}

type UpdateConceptPayload {
  error: Error
  concept: Concept
}

input UpdateCreditInput {
  id: String!
  quantity: Float
  unitId: String
  costCents: Float
  costUnitId: String
  notes: String
  date: DateOnly
}

type UpdateCreditPayload {
  error: Error
  credit: Credit
}

#  Input data about the cycleCount to be updated.
input UpdateCycleCountCycleCountInput {
  id: String!
  date: DateOnly!
  companyId: String
  locationId: String
  creatorId: String
}

#  The cycleCount to be updated.
input UpdateCycleCountInput {
  cycleCount: UpdateCycleCountCycleCountInput!
}

#  The cycleCountItem to be updated.
input UpdateCycleCountItemInput {
  cycleCountItem: UpdateCycleCountItemItemInput!
}

#  Input data about the cycleCountItem to be updated.
input UpdateCycleCountItemItemInput {
  id: String!
  primaryQuantity: Float
  primaryUnit: UpdateCycleCountItemUnitInput
  secondaryQuantity: Float
  secondaryUnit: UpdateCycleCountItemUnitInput
  cycleCountId: String
  recipeId: String
  ingredientId: String
  vendorItemId: String
  companyId: String
}

#  The updated cycleCountItem or the error that occured when trying to update.
type UpdateCycleCountItemPayload {
  error: Error
  cycleCountItem: CycleCountItem
}

#  Input data about the cycleCountItem's unit to be updated.
input UpdateCycleCountItemUnitInput {
  id: String
  name: String
}

#  The updated cycleCount or the error that occured when trying to update.
type UpdateCycleCountPayload {
  error: Error
  cycleCount: CycleCount
}

#  Input data about the cycleCountTemplate to be updated.
input UpdateCycleCountTemplateCycleCountTemplateInput {
  id: String!
  name: String
  categoryValueIdBooleanExpression: CategoryValueIdFilterBooleanExpressionType
}

#  The cycleCountTemplate to be updated.
input UpdateCycleCountTemplateInput {
  cycleCountTemplate: UpdateCycleCountTemplateCycleCountTemplateInput!
}

#  The updated cycleCountTemplate or the error that occured when trying to update.
type UpdateCycleCountTemplatePayload {
  error: Error
  cycleCountTemplate: CycleCountTemplate
}

# The UpdateDietaryFlagConstraintInput is a group of parameters required to update a constraint for dietary flags through the updateDietaryFlagConstraint mutation.
input UpdateDietaryFlagConstraintInput {
  constraintId: ID!
  dietaryFlagIds: [ID!]!
}

input UpdateDietaryFlagDietaryFlagInput {
  id: String!
  name: String
  shouldShowOnNutritionLabel: Boolean
}

input UpdateDietaryFlagInput {
  dietaryFlag: UpdateDietaryFlagDietaryFlagInput!
}

type UpdateDietaryFlagPayload {
  error: Error
  dietaryFlag: DietaryFlag
}

# Allows updating an entityMedia by ID
input UpdateEntityMediaInput {
  id: String!
  description: String!
  title: String!
}

# Returns the updated entityMedia or an error, but not both
type UpdateEntityMediaPayload {
  entityMedia: EntityMedia
  error: Error
}

input UpdateEventInput {
  id: String!
  name: String
  description: String
  locationName: String
  locationStreetAddress: String
  locationCity: String
  locationState: String
  locationZip: String
  startDate: String
  endDate: String
  headCount: Int
}

type UpdateEventPayload {
  error: Error
  event: Event
}

input UpdateHaccpRuleInput {
  haccpRule: HaccpRuleInput!
}

type UpdateHaccpRulePayload {
  error: Error
  haccpRule: HaccpRule
}

input UpdateIngredientPreparationInput {
  ingredientPreparation: IngredientPreparationInput!
}

type UpdateIngredientPreparationPayload {
  error: Error
  ingredientPreparation: IngredientPreparation
}

# Input type for update an invoice approval rule. Contains fields like vendorID, locationID.
input UpdateInvoiceApprovalRuleInput {
  id: String!
  vendorId: String
  locationId: String
}

# Payload type for the UpdateInvoiceApprovalRule mutation. Contains a field invoiceApprovalRule which is of type InvoiceApprovalRule representing the newly created invoice approval rule.
type UpdateInvoiceApprovalRulePayload {
  invoiceApprovalRule: InvoiceApprovalRule!
}

# Input type for updating an existing invoice. Contains fields like id, shippingAddress, invoiceDate, notes, locationId, extLocationId, city, state, zipCode, and vendorId.
input UpdateInvoiceInput {
  id: String!
  shippingAddress: String
  invoiceDate: String
  notes: String
  locationId: String
  city: String
  state: String
  zipCode: String
  vendorId: String
  totalCostCents: Float
  totalItems: Int
  tax: String
}

# Input type for updating an existing invoice item. Contains fields like id, name, unitCostCents, quantityOrdered, description, sku, priceUnit, purchasingUnit, tax, vendorItemId, unitId, and ignored.
input UpdateInvoiceItemInput {
  id: String!
  name: String
  unitCostCents: Float
  quantityOrdered: Float
  description: String
  sku: String
  priceUnit: String
  purchasingUnit: String
  vendorItemId: String
  unitId: String
  ignored: Boolean
  glCode: String
}

# Payload type for the UpdateInvoiceItem mutation. Contains a field id which represents the updated invoice item's ID.
type UpdateInvoiceItemPayload {
  id: String
}

# Payload type for the UpdateInvoice mutation. Contains a field id which represents the updated invoice's ID.
type UpdateInvoicePayload {
  id: String
}

# The UpdateInvoiceRuleInput is a set of information available to be defined on a invoice rule update.
input UpdateInvoiceRuleInput {
  id: ID!
  action: InvoiceRuleActionEnum!
  locationId: String
  vendorId: String
}

# The UpdateInvoiceRulePayload is the result of a invoice rule update, with an error or the invoice rule updated.
type UpdateInvoiceRulePayload implements InvoiceRulePayload {
  error: Error
  invoiceRule: InvoiceRule
}

# Payload type for the mutations that change invoice status (Draft, Approve, Complete, Archive). Contains fields id (updated invoice's ID) and status (updated status).
type UpdateInvoiceStatusPayload {
  id: String
  status: String
}

input UpdateLocationGroupInput {
  locationGroup: LocationGroupInput!
}

type UpdateLocationGroupPayload {
  error: Error
  locationGroup: LocationGroup
}

input UpdateLocationInput {
  location: UpdateLocationLocationInput!
}

input UpdateLocationLocationInput {
  id: String!
  name: String
  streetAddress: String
  city: String
  state: String
  zipCode: String
  type: String
  externalId: String
  billingTier: String
}

type UpdateLocationPayload {
  location: Location
}

#  UpdateMenuCycleEventGroupInput represents the parameters required to update a MenuCycleEventGroup.
input UpdateMenuCycleEventGroupInput {
  id: ID!
  name: String
}

#  UpdateMenuCycleEventInput represents the parameters required to update a MenuCycleEvent.
input UpdateMenuCycleEventInput {
  id: ID!
  headCount: PositiveInt
}

#  UpdateMenuCycleEventItemInput represents the parameters required to update a MenuCycleEventItem.
input UpdateMenuCycleEventItemInput {
  id: ID!
  unitId: ID
  quantity: PositiveDecimal
  isPerHead: Boolean
}

#  UpdateMenuCycleInput represents the parameters required to update a MenuCycle.
input UpdateMenuCycleInput {
  id: ID!
  name: String
  isPerHead: Boolean
  lengthDays: PositiveInt
  dailyHeadcount: PositiveInt
  budgetCents: PositiveDecimal
}

#  UpdateMenuCycleProductGroupInput represents the parameters required to update a MenuCycleProductGroup.
input UpdateMenuCycleProductGroupInput {
  id: ID!
  name: String
}

input UpdateMenuItemInput {
  menuItem: MenuItemInput!
}

type UpdateMenuItemPayload {
  error: Error
  menuItem: MenuItem
}

#  UpdateMenuPlanEventGroupInput represents the parameters required to update a MenuPlanEventGroup.
input UpdateMenuPlanEventGroupInput {
  id: ID!
  name: String
}

#  UpdateMenuPlanEventInput represents the parameters required to update a MenuPlanEvent.
input UpdateMenuPlanEventInput {
  id: ID!
  headCount: PositiveInt
  name: String
  notes: String
  conceptId: ID
}

#  UpdateMenuPlanEventItemInput represents the parameters required to update a MenuPlanEventItem.
input UpdateMenuPlanEventItemInput {
  id: ID!
  unitId: ID
  quantity: PositiveDecimal
  isPerHead: Boolean
}

#  UpdateMenuPlanInput represents the parameters required to update a MenuPlan.
input UpdateMenuPlanInput {
  id: ID!
  name: String
  isPerHead: Boolean
  lengthDays: PositiveInt
  dailyHeadcount: PositiveInt
  budgetCents: PositiveDecimal
  startDate: Date
}

input UpdateMenuPlanPOCInput {
  id: String!
  name: String
  startDate: Date
  menuTemplateIds: [String!]
}

type UpdateMenuPlanPOCPayload {
  error: Error
  menuPlan: MenuPlanPOC
}

#  UpdateMenuPlanProductGroupInput represents the parameters required to update a MenuPlanProductGroup.
input UpdateMenuPlanProductGroupInput {
  id: ID!
  name: String
}

input UpdateMenuTemplateInput {
  id: String!
  name: String!
}

input UpdateMenuTemplateItemInput {
  id: String!
  name: String!
}

type UpdateMenuTemplateItemPayload {
  error: Error
  menuTemplateItem: MenuTemplateItem
}

type UpdateMenuTemplatePayload {
  error: Error
  menuTemplate: MenuTemplate
}

input UpdateOrderCategoryInput {
  id: String!
  name: String!
  categoryValues: [UpdateOrderCategoryValueInput!]
}

input UpdateOrderCategoryValueInput {
  id: String!
  name: String!
}

input UpdatePolicyDefinition {
  policy: UpdatePolicyDefinitionInput!
}

input UpdatePolicyDefinitionInput {
  id: String!
  name: String!
  statements: [PolicyDefinitionStatementInput!]!
  description: String
  type: PolicyType
}

type UpdatePolicyDefinitionResponse {
  policy: Policy
  error: PolicyDefinitionError
}

input UpdatePurchaseOrderItemInput {
  purchaseOrderItem: PurchaseOrderItemInput!
}

type UpdatePurchaseOrderItemPayload {
  error: Error
  purchaseOrderItem: PurchaseOrderItem
}

input UpdateReceivedItemInput {
  id: String!
  quantity: Float
  unitId: String
  costCents: Float
  costUnitId: String
}

type UpdateReceivedItemPayload {
  error: Error
  receivedItem: ReceivingItem
}

input UpdateRecipeAttributes {
  description: String
  externalName: String
  isDish: Boolean
  name: String
  notes: String
  nutritionalsUnitId: String
  nutritionalsServingsPerContainer: Float
  priceCents: Int
  shelfLifeDays: Float
  prepTime: Int

  # PDCAAS (Protein Digestibility Corrected Amino Acid Score) is used to adjust the Protein DV% of a recipe to account for the quality of the protein
  pdcaas: Float
  shortCode: String
  totalYield: Float
  yieldUnitId: String
  inventoryUnitId: String
}

input UpdateRecipeConceptInput {
  recipeId: String!
  conceptIds: [String]
}

type UpdateRecipeConceptPayload {
  recipe: Recipe
}

input UpdateRecipeHaccpRulesInput {
  recipeId: String!
  haccpRuleIds: [String]
}

type UpdateRecipeHaccpRulesPayload {
  error: Error
  recipe: Recipe
}

input UpdateRecipeInput {
  recipeId: String!
  attrs: UpdateRecipeAttributes!
}

input UpdateRecipeInstructionInput {
  recipeInstruction: RecipeInstructionInput
}

type UpdateRecipeInstructionPayload {
  error: Error
  recipeInstruction: RecipeInstruction
}

input UpdateRecipeItemInput {
  recipeItem: RecipeItemInput
}

type UpdateRecipeItemPayload {
  error: Error
  originalRecipeItem: RecipeItem
}

type UpdateRecipePayload {
  recipe: Recipe
  error: Error
}

input UpdateRecipeShareableViewInput {
  recipeId: String!
  recipeView: UpdateRecipeViewInput!
}

type UpdateRecipeShareableViewPayload {
  recipe: Recipe
  error: Error
}

input UpdateRecipeViewInput {
  id: String!
  name: String!
  settings: SequelizeJSON!
}

input UpdateRecipeYieldPercentInput {
  recipeId: String!
  yieldPercent: Float!
}

type UpdateRecipeYieldPercentPayload {
  recipe: Recipe
  error: Error
}

input UpdateSubLocationAttrs {
  name: String
}

input UpdateSubLocationInput {
  subLocationId: String!
  attrs: UpdateSubLocationAttrs!
}

type UpdateSubLocationPayload {
  subLocation: SubLocation
  error: Error
}

input UpdateTemplateInput {
  id: String!
  name: String
  description: String
}

type UpdateTemplatePayload {
  error: Error
  template: Template
}

input UpdateTransferOrderInput {
  transferOrder: UpdateTransferOrderTransferOrderInput!
}

input UpdateTransferOrderItemInput {
  transferOrderItem: UpdateTransferOrderItemTransferOrderItemInput!
}

type UpdateTransferOrderItemPayload {
  error: Error
  transferOrderItem: TransferOrderItem
}

input UpdateTransferOrderItemTransferOrderItemInput {
  id: String!
  ingredientId: String
  recipeId: String
  quantity: Float
  unitId: String
  notes: String
}

type UpdateTransferOrderPayload {
  error: Error
  transferOrder: TransferOrder
}

input UpdateTransferOrderTransferOrderInput {
  id: String!
  status: String
  destinationLocationId: String
  conceptId: String
  sourceLocationId: String
  menuIds: [String!]
  transferOrderItems: [TransferOrderItemInput!]
  deliveryDate: DateOnly
  notes: String
}

input UpdateTransfersCatalogInput {
  id: String!
  name: String
  sourceLocationId: String!
  leadTimeDays: Int
  externalId: String
  deliveryDows: DeliveryDowInput
}

input UpdateTransfersCatalogItemInput {
  id: String!
  name: String
  leadTimeDays: Int
  priceCents: Float
  externalId: String
  primaryUnitId: String
  barcode: String
  sku: String
}

type UpdateTransfersCatalogItemPayload {
  error: Error
  transfersCatalogItem: TransfersCatalogItemType
}

type UpdateTransfersCatalogPayload {
  error: Error
  transfersCatalog: TransfersCatalogType
}

input UpdateUnitConversionInput {
  unitConversion: UpdateUnitConversionUnitConversionInput!
}

type UpdateUnitConversionPayload {
  error: Error
  unitConversion: UnitConversion
}

input UpdateUnitConversionUnitConversionInput {
  id: String!
  fromQuantity: Float
  toQuantity: Float
  ingredientId: String
  recipeId: String
  vendorItemId: String
  fromUnit: UnitInput
  fromUnitId: String
  toUnit: UnitInput
  toUnitId: String
}

input UpdateVendorGroupInput {
  vendorGroup: VendorGroupInput!
}

type UpdateVendorGroupPayload {
  error: Error
  vendorGroup: VendorGroup
}

input UpdateViewStateInput {
  viewState: ViewStateInput!
}

type UpdateViewStatePayload {
  error: Error
  viewState: ViewState
}

# Upload represents a file upload.
scalar Upload

input UpsertCategoryInput {
  category: CategoryInput!
}

type UpsertCategoryPayload {
  error: Error
  category: Category
}

input UpsertCompanyInput {
  company: CompanyInput!
}

type UpsertCompanyPayload {
  error: Error
  company: Company
}

input UpsertIngredientInput {
  ingredient: IngredientInput
  locationId: String
}

type UpsertIngredientPayload {
  error: Error
  ingredient: Ingredient
}

input UpsertMenuInput {
  id: String
  name: String!
  headCount: Int
  isPerHead: Boolean
  conceptId: String
  locationId: String
  date: DateOnly
  startDate: DateOnly
  endDate: DateOnly
  notes: String
  manualTotalSalesValueCents: Float
  menuPlanId: String
}

type UpsertMenuPayload {
  error: Error
  menu: Menu
}

input UpsertPreparationInput {
  name: String!
  deletedAt: Date
  creatorId: Int
  id: String
}

type UpsertPreparationPayload {
  error: Error
  preparation: Preparation
}

input UpsertPurchaseOrderInput {
  purchaseOrder: PurchaseOrderInput
}

type UpsertPurchaseOrderPayload {
  error: Error
  purchaseOrder: PurchaseOrder
}

input UpsertRecipeInput {
  recipeGlobalId: String
  recipe: RecipeInput
  recipeItems: [RecipeItemInput]
  isFromVersion: Boolean
  versionNumber: Int
}

type UpsertRecipePayload {
  error: Error
  recipe(id: String, locationId: String): Recipe
}

input UpsertRecipeVariationRuleInput {
  recipeVariationRule: RecipeVariationRuleInput
}

type UpsertRecipeVariationRulePayload {
  error: Error
  recipeVariationRule: RecipeVariationRule
}

input UpsertTransfersCatalogItemInput {
  name: String
  recipeId: String
  ingredientId: String
  leadTimeDays: Int
  priceCents: Float
  externalId: String
  barcode: String
  sku: String
}

input UpsertTransfersDestinationLocationInput {
  locationId: String!
}

input UpsertUnitInput {
  unit: UnitInput!
}

type UpsertUnitPayload {
  error: Error
  unit: Unit
}

input UpsertUserInput {
  user: UserInput
}

type UpsertUserPayload {
  error: Error
  user: User
}

input UpsertVendorInput {
  vendor: VendorInput!
}

input UpsertVendorItemInput {
  vendorItem: VendorItemInput!
  vendorId: String!
}

type UpsertVendorItemPayload {
  error: Error
  vendorItem: VendorItem
}

type UpsertVendorPayload {
  error: Error
  vendor: Vendor
}

type UsageQuantityUnit {
  quantity: Float
  unit: Unit
}

enum UsageWarning {
  MissingQuantities
  MissingCost
  IncompatibleQuantities
  IncompatibleCost
}

type User {
  id: ID!
  companyId: String!
  email: String!
  policies: [Policy!]!
  policyDefinitions: [Policy!]!
  roles: [Role!]!
  role: String @deprecated(reason: "Will be replaced by roles")
  permissions: [String]
  firstName: String!
  lastName: String!
  welcomeEmailSentAt: Date
  lmsEmailSentAt: Date
  isApi: Boolean
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  locationId: String
  algoliaSearchApiKey: String!
  name: String!
  company: Company!
  location: Location @deprecated(reason: "Will be replaced by locations")
  locations: [Location!]!
  canAccessAllLocations: Boolean!
}

type UserConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [UserConnectionEdge!]!
}

type UserConnectionEdge {
  index: Int!
  node: User!
}

input UserConnectionFilter {
  name: String
  email: String
}

enum UserConnectionOrderByEnum {
  Name
  Email
}

input UserConnectionPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: UserConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

input UserInput {
  id: String
  firstName: String
  lastName: String
  email: String
  welcomeEmailSentAt: Date
  lmsEmailSentAt: Date
  permissions: SequelizeJSON
  isApi: Boolean
  companyId: String
  locationId: String
  role: String
}

type ValidateBulkUploadMenusError {
  message: String
}

input ValidateBulkUploadMenusInput {
  menus: [InputMenuInput!]!
}

type ValidateBulkUploadMenusPayload {
  isValid: Boolean
  errors: [ValidateBulkUploadMenusError!]!
}

type ValidateBulkUpsertMenusError {
  message: String
}

input ValidateBulkUpsertMenusInput {
  menus: [_BulkUpsertMenuInput!]!
}

type ValidateBulkUpsertMenusPayload {
  isValid: Boolean
  errors: [ValidateBulkUpsertMenusError!]!
}

type ValidationError {
  message: String
  id: String
  name: String
  entityType: String
  errorType: String
}

type Vendor {
  id: ID!
  name: String!
  streetAddress: String
  city: String
  state: String
  zipCode: String
  phoneNumber: String
  email: String
  website: String
  minOrderValueCents: Int
  minOrderQuantity: Int
  openDows: SequelizeJSON
  deliveryDows: SequelizeJSON
  leadTimeDays: Int
  orderCutoffTime: String
  ediVendorItemsShouldBiasCreate: Boolean
  externalId: String
  notes: String
  isGlobal: Boolean!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String
  vendorItems: [VendorItem!]!
  vendorGroups: [VendorGroup!]!
  minOrderUnit: Unit
  serviceScope: ServiceScope!
  locations: [Location!]!
}

type VendorGroup {
  # The ID of an object
  id: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  vendors: [Vendor!]!
  locations: [Location!]!
  locationGroups: [LocationGroup!]!
}

input VendorGroupInput {
  id: String
  name: String!
  companyId: String
}

type VendorGroupVendor {
  # The ID of an object
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  vendorId: String
  vendorGroupId: String
  vendorGroup: VendorGroup
  vendor: Vendor
}

input VendorGroupVendorInput {
  id: String
  vendorId: String!
  vendorGroupId: String!
}

input VendorInput {
  id: String
  name: String
  streetAddress: String
  city: String
  state: String
  zipCode: String
  phoneNumber: String
  email: String
  website: String
  minOrderValueCents: Int
  minOrderQuantity: Int
  openDows: SequelizeJSON
  deliveryDows: SequelizeJSON
  leadTimeDays: Int
  orderCutoffTime: String
  ediVendorItemsShouldBiasCreate: Boolean
  companyId: String
  minOrderUnit: UnitInput
  externalId: String
  notes: String
  isGlobal: Boolean
}

type VendorItem implements MediaEntity & HasNutritionalFieldsAndQuantity {
  id: ID!
  files: Files!
  sku: String
  name: String!
  barcode: String
  ingredientListStr: String
  externalId: String
  brandName: String
  glCode: String
  notes: String
  nutritionalsQuantity: Float
  leadTimeDays: Float
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  vendorId: String!
  companyId: String!
  canonicalIngredientId: String

  # Present when in context of an ingredient
  priority: Int
  vendor: Vendor!

  # costCentsUnits present when in context of an ingredient
  hasPurchaseableUnitConversionPath(ingredientId: String): Boolean!
  ingredient(locationId: String): Ingredient
    @deprecated(reason: "will be replaced with ingredientsLocations")
  ingredientsLocations(ingredientIds: [String!]): [IngredientLocation!]!
  unitConversions: [UnitConversion!]!
  purchasingUnit: Unit
  inventoryUnit: Unit
  units: [Unit!]!
  categoryValues: [CategoryValue!]!
  nutritionalsUnit: Unit
  canonicalIngredient: CanonicalIngredient
  dietaryFlags: [DietaryFlag!]!
  subLocationItems(locationId: String): [SubLocationItem!]!

  # A vendor item's reconciled nutrition value will be equal to the vendor item's manually set nutritional value if it exists. If not, the associated canonical ingredient's nutritional value will be used. If that does not exist, the value will be null.
  #
  # IF({manually set nutritional value}!=0) THEN {manually set nutritional value}
  #
  # ELSE IF({canonical ingredient nutritional value}!=0) THEN {canonical ingredient nutritional value}
  #
  # ELSE null
  reconciledNutritionals: ReconciledNutritionValues!

  # date argument must be ISO Date string. Example: '2022-01-11T15:10:47.175Z'
  costCents(date: DateOnly): Float

  # date argument must be ISO Date string. Example: '2022-01-11T15:10:47.175Z'
  costUnit(date: DateOnly): Unit
  costCentsUnitValues(includeAll: Boolean, date: DateOnly): [UnitValue!]!
  costLastUpdatedAt: Date
  inventoryItems(locationIds: [String!]): [InventoryItem!]!
}

type VendorItemConnection {
  totalCount: Int!
  pageInfo: PageInfoType!
  edges: [VendorItemConnectionEdge!]!
}

type VendorItemConnectionEdge {
  index: Int!
  node: VendorItem!
}

input VendorItemConnectionFilter {
  id: [String]
  name: String
  hasWarnings: Boolean

  # Use query to fuzzy search by various fields like name and sku.
  query: String
}

enum VendorItemConnectionOrderByEnum {
  vendorName
  name
  ingredientName
  sku
  costCents
}

input VendorItemConnectionPaginationOptions {
  startIndex: Int
  first: Int
  orderBy: VendorItemConnectionOrderByEnum
  sortDirection: SortDirectionEnum
}

type VendorItemCost {
  id: String!
  vendorItemId: String!
  costCents: Float!
  costUnit: Unit!
  unitConversions: [UnitConversion]
  startsAt: Date
  endsAt: Date
  reportedAt: Date
  source: String!
  type: CostTypeEnum!
}

input VendorItemInput {
  id: String
  sku: String
  name: String
  barcode: String
  ingredientListStr: String
  externalId: String
  brandName: String
  glCode: String
  notes: String
  leadTimeDays: Float
  vendorId: String
  companyId: String
  units: UnitInput
  purchasingUnit: UnitInput
  inventoryUnit: UnitInput
  nutritionalsQuantity: Float
  nutritionalsUnit: UnitInput
  caloriesKCal: Float
  totalFatG: Float
  saturatedFatG: Float
  transFatG: Float
  cholesterolMg: Float
  sodiumMg: Float
  carbsG: Float
  fiberG: Float
  sugarG: Float
  addedSugarG: Float
  proteinG: Float
  vitaminAMcg: Float
  vitaminB6Mg: Float
  vitaminB12Mcg: Float
  vitaminCMg: Float
  vitaminDMcg: Float
  vitaminEMg: Float
  vitaminKMcg: Float
  calciumMg: Float
  ironMg: Float
  thiaminMg: Float
  riboflavinMg: Float
  niacinMg: Float
  folateMcg: Float
  biotinMcg: Float
  pantothenicAcidMg: Float
  phosphorusMg: Float
  iodineMcg: Float
  magnesiumMg: Float
  zincMg: Float
  seleniumMcg: Float
  copperMg: Float
  manganeseMg: Float
  chromiumMcg: Float
  molybdenumMcg: Float
  chlorideMg: Float
  potassiumMg: Float
  cholineMg: Float
  canonicalIngredientId: String
}

type VendorItemLocation {
  vendorItems: [VendorItem!]!
  location: Location!
}

# FieldParsingPossibilityResponse represents the reponse for set fields.
type VendorItemsUserInteractionResponse {
  jobId: String!
  success: Boolean!
}

type Version {
  # The ID of an object
  id: ID!
  itemType: String!
  itemId: String!
  action: String!
  object: String
  alias: String
  versionNumber: Int!
  createdAt: Date!
  updatedAt: Date!
  companyId: String
  actorId: String
  actor: User!
}

type Viewer {
  parseVendorItemsForImportJob(jobId: String!): ParseVendorItemsForImportJob!
  parseVendorItemsForImportJobConnection(
    paginationOptions: ParseVendorItemsForImportJobsPaginationOptions
  ): ParseVendorItemsForImportJobConnection!
  parseVendorItemsForImportJobFromFilterConnection(
    filter: OrchestratorJobFilter
    paginationOptions: ParseVendorItemsForImportJobsPaginationOptions
  ): ParseVendorItemsForImportJobConnection!
  parseInitialRowsForImportJob(jobId: String!): ParseFileInitialRows!
  userId: String
  catalog(id: String!): Catalog
  catalogItem(id: String!): CatalogItem
  catalogConnection(
    filters: CatalogConnectionFilters
    paginationOptions: CatalogPaginationOptions!
  ): CatalogConnection
  catalogItemConnection(
    filters: CatalogItemConnectionFilters
    paginationOptions: CatalogItemPaginationOptions!
  ): CatalogItemConnection
  collectionConnection(
    filters: CollectionFilter
    paginationOptions: CollectionPaginationOptions
  ): CollectionConnection!

  # The collectionItemConstraint is an interface available to retrieve a constraint for a collection item.
  collectionItemConstraint(id: ID!): CollectionItemConstraint

  # The constraint returns a constraint type filtered by id.
  constraint(id: ID!): Constraint

  # The constraintConnection is an interface available to retrieve a paginated list of constraints filtered by ConstraintConnectionFilter fields.
  constraintConnection(
    filters: ConstraintConnectionFilters
    paginationOptions: ConstraintPaginationOptions
  ): ConstraintConnection!
  draftOrder(id: String!): DraftOrder
  draftOrdersConnection(
    ids: [String!]
    filters: DraftOrdersConnectionFilters
    paginationOptions: DraftOrdersConnectionPaginationOptions
  ): DraftOrdersConnection!
  finishedGood(id: String!): FinishedGood
  finishedGoods(
    locationId: String!
    paginationOptions: FinishedGoodsPaginationOptions!
    filters: FinishedGoodsFilter
  ): FinishedGoods!
  finishedGoodsUsages(
    locationId: String!
    finishedGoodId: String!
    paginationOptions: FinishedGoodsPaginationOptions!
  ): FinishedGoods!
  cycleCount(id: String!): CycleCount
  cycleCounts(
    ids: [String]
    locationIds: [String]
    templateIds: [String]
    statuses: [String]
    cycleCountDate: CycleCountDateFilterInput
    limit: Int
    offset: Int
    order: [[String]]
  ): [CycleCount!]!
  cycleCountTemplate(id: String!): CycleCountTemplate
  cycleCountTemplates(includeEmpty: Boolean = true): [CycleCountTemplate!]!
  receivingItemConnection(
    paginationOptions: ReceivingItemPaginationOptions
    filters: ReceivingItemsFilter
  ): ReceivingItemConnection!
  receivingItem(id: String!): ReceivingItemV2
  receivingItemEvent(id: String!): ReceivingItemEvent
  invoice(id: String!): Invoice
  invoiceConnection(
    paginationOptions: InvoicePaginationOptions
    filters: InvoiceConnectionFilter
  ): InvoiceConnection!
  invoiceChangeConnection(
    paginationOptions: InvoiceChangePaginationOptions
    filters: InvoiceChangeConnectionFilter!
  ): [InvoiceDataChange!]!
  invoiceItem(id: String!): InvoiceItem
  invoiceItemConnection(
    paginationOptions: InvoiceItemPaginationOptions
    filters: InvoiceItemConnectionFilter!
  ): InvoiceItemConnection!
  lotConnection(
    filter: LotConnectionFilter
    paginationOptions: LotPaginationOptions
  ): LotConnection!
  media(id: String!): Media
  menuCycleConnection(
    filters: MenuCycleConnectionFilter
    paginationOptions: MenuCyclePaginationOptions
  ): MenuCycleConnection!
  menuCycle(id: ID!): MenuCycle
  menuCycleEventItems(
    menuCycleId: ID!
    filters: MenuCycleEventItemFilter
  ): [MenuCycleEventItem!]
  highlightMenuCycleEventItems(
    menuCycleId: ID!
    filters: MenuCycleEventItemFilter!
  ): [HighlightMenuCycleEventItemsWeek!]
  menuPlanConnection(
    filters: MenuPlanConnectionFilter
    paginationOptions: MenuPlanPaginationOptions
  ): MenuPlanConnection!
  menuPlan(id: ID!): MenuPlan
  menuPlanEventConnection(
    filters: MenuPlanEventConnectionFilter
    paginationOptions: MenuPlanEventPaginationOptions
  ): MenuPlanEventConnection!
  menuPlanEventItems(
    menuPlanId: ID!
    filters: MenuPlanEventItemFilter
    orderOptions: MenuPlanEventOrderOptions
  ): [MenuPlanEventItem!]
  highlightMenuPlanEventItems(
    menuPlanId: ID!
    filters: MenuPlanEventItemFilter!
  ): [HighlightMenuPlanEventItemsWeek!]
  user(id: String): User
  currentLocation: Location
  company(id: String): Company
  allCompanies: [Company!]!
  concepts(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [Concept!]!
  concept(id: String!): Concept
  dietaryFlag(id: String!): DietaryFlag
  dietaryFlags: [DietaryFlag!]!
  recipes(
    # Max value is 25; default value is 25
    limit: Int
    order: String
    includeUsages: Boolean
    includeCategoryValues: Boolean
    where: SequelizeJSON
    offset: Int
    isUnused: Boolean
    locationId: String
    includeDeleted: Boolean
  ): [Recipe!]! @deprecated(reason: "Use recipeConnection instead")
  recipe(id: String, locationId: String): Recipe
  recipeItem(id: String): RecipeItem
  ingredients(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
    isUnused: Boolean
    isMissingCost: Boolean
  ): [Ingredient!]! @deprecated(reason: "Use ingredientConnection instead")
  ingredientConnection(
    locationId: String
    filters: IngredientConnectionFilter
    paginationOptions: PaginationOptions
  ): IngredientConnection!
  ingredient(id: String): Ingredient
  menus(
    # Max value is 25; default value is 25
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [Menu!]! @deprecated(reason: "Use MenuConnection instead")
  menu(id: String!): Menu
  menuItem(id: String!): MenuItem
  category(id: String!): Category
  categories(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [Category!]!
  categoryValues(
    limit: Int
    offset: Int
    order: [[String]]
    ids: [String!]
  ): [CategoryValue!]!
  vendors(
    limit: Int
    offset: Int
    order: [[String!]!]
    ids: [String!]
    externalIds: [String!]
    locationIds: [String!]
  ): [Vendor!]!
  vendor(id: String!): Vendor
  vendorGroups(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
    locationIds: [String!]
  ): [VendorGroup!]!
  vendorGroup(id: String!): VendorGroup
  vendorItem(id: String!): VendorItem
  vendorItems(ids: [String!]!, vendorId: String): [VendorItem!]!
    @deprecated(reason: "Use VendorItemConnection instead")
  preparations(limit: Int, order: String, offset: Int): [Preparation!]!
  preparation(id: String!): Preparation
  locations(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [Location!]!
  location(id: String!): Location
  locationGroups(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [LocationGroup!]!
  subLocation(id: String!): SubLocation
  locationGroup(id: String!): LocationGroup
  viewStates(
    limit: Int
    order: String
    where: SequelizeJSON
    offset: Int
  ): [ViewState!]!
  haccpRules: [HaccpRule!]!
  haccpRule(id: String!): HaccpRule
  recipeItemConnection(
    paginationOptions: RecipeItemConnectionPaginationOptions
    filters: RecipeItemConnectionFilter
  ): RecipeItemConnection!
  preparationConnection(
    filters: PreparationConnectionFilter
    paginationOptions: PreparationConnectionPaginationOptions
  ): PreparationConnection!
  locationConnection(
    filters: LocationConnectionFilter
    paginationOptions: PaginationOptions
  ): LocationConnection!
  subLocationConnection(
    filters: SubLocationConnectionFilter
    paginationOptions: PaginationOptions
  ): SubLocationConnection!
  userConnection(
    paginationOptions: UserConnectionPaginationOptions
    filters: UserConnectionFilter
  ): UserConnection!
  event(id: String!): Event
  events: [Event!]!
  inventoryItems(locationId: String!): [InventoryItem!]!
  inventoryItem(
    id: String
    inventoryItemIdParts: InventoryItemIdParts
  ): InventoryItem
  receiving(locationId: String!, date: String!, vendorId: String): Receiving!
  recipeConnection(
    filters: RecipeConnectionFilter
    paginationOptions: PaginationOptions
    locationId: String
  ): RecipeConnection!
  menuConnection(
    filters: MenuConnectionFilter
    paginationOptions: PaginationOptions
  ): MenuConnection!
  menuTemplateItemConnection(
    filters: MenuTemplateItemConnectionFilter
    paginationOptions: PaginationOptions
  ): MenuTemplateItemConnection!
    @deprecated(reason: "will be replaced by a different graph")
  menuTemplateConnection(
    filters: MenuTemplateConnectionFilter
    paginationOptions: PaginationOptions
  ): MenuTemplateConnection!
    @deprecated(reason: "will be replaced by a different graph")
  menuPlanPOCTemplateItemConnection(
    filters: MenuPlanPOCTemplateItemConnectionFilter
    paginationOptions: PaginationOptions
  ): MenuPlanPOCTemplateItemConnection!
    @deprecated(reason: "will be replaced by a different graph")
  menuPlanPOCConnection(
    filters: MenuPlanPOCConnectionFilter
    paginationOptions: PaginationOptions
  ): MenuPlanPOCConnection!
    @deprecated(reason: "will be replaced by a different graph")
  vendorItemConnection(
    paginationOptions: VendorItemConnectionPaginationOptions
    filters: VendorItemConnectionFilter
    locationId: String
  ): VendorItemConnection!
  canonicalUnits: [CanonicalUnit!]!
  credits(locationId: String!, date: DateOnly!, vendorId: String): Credits!
  orderCategory(id: String!): OrderCategory
  orderCategoryConnection(
    paginationOptions: OrderCategoryPaginationOptions
    filters: OrderCategoryConnectionFilter
  ): OrderCategoryConnection!
  purchaseOrderItems(
    ids: [String!]
    offset: Int
    limit: Int
  ): [PurchaseOrderItem!]!
  orders: [Order!]!
  orderConnection(
    paginationOptions: OrderPaginationOptions
    filters: OrderConnectionFilter
  ): OrderConnection!
  purchaseOrders(
    limit: Int
    offset: Int
    order: [[String!]!]
    deliveryDate: DeliveryDateFilterInput
    ids: [String!]
    conceptIds: [String!]
    locationIds: [String!]
    vendorIds: [String!]
    statuses: [String!]
    includeDeleted: Boolean
  ): [PurchaseOrder!]!
  purchaseOrder(id: String!): PurchaseOrder
  transferOrder(id: String!): TransferOrder
  productionExecutionConnection(
    paginationOptions: ProductionExecutionPaginationOptions!
    filters: ProductionExecutionConnectionFilter
  ): ProductionExecutionConnection!
  productionTask(id: String!): ProductionTask
  productionTaskDependencies(id: String!): ProductionTaskDependency
  productionTaskCountByState(
    executionIds: [String!]
  ): [ProductionTaskCountByState]
  productionTaskConnection(
    paginationOptions: ProductionTaskPaginationOptions!
    filters: ProductionTaskConnectionFilter
  ): ProductionTaskConnection!
  productionPicklistConnection(
    taskId: String!
    paginationOptions: ProductionPicklistPaginationOptions!
    filters: ProductionPicklistConnectionFilter
  ): ProductionPicklistConnection!
  productionScheduleConnection(
    paginationOptions: ProductionSchedulePaginationOptions!
    filters: ProductionScheduleConnectionFilter
  ): ProductionScheduleConnection!
  productionSchedule(id: String!): ProductionSchedule
  productionScheduleLocationSettings(
    locationId: String!
  ): ProductionScheduleSettings!
  productConnection(
    filters: ProductConnectionFilters
    paginationOptions: ProductConnectionPaginationOptions
  ): ProductConnection!
  template(id: String!): Template
  templates(filters: TemplateFiltersType): [Template]
  procurementSourceItems(
    input: [ProcurementSourceItemInput!]!
  ): [ProcurementSourceItemPayload!]!
  transfersCatalog(id: String!): TransfersCatalogType
  transfersCatalogsConnection(
    paginationOptions: TransfersCatalogPaginationOptions
    filters: TransfersCatalogsConnectionFilter
  ): TransfersCatalogsConnection!
}

type ViewState {
  # The ID of an object
  id: ID!
  name: String!
  viewName: String!
  stateJSON: SequelizeJSON!
  createdAt: Date!
  updatedAt: Date!
  deletedAt: Date
  companyId: String!
  creatorId: String
}

input ViewStateInput {
  id: String
  name: String!
  viewName: String!
  stateJSON: SequelizeJSON!
  companyId: String
  creatorId: String
}

#  WeekSummary.
type WeekSummary {
  week: Int!
  totalCost: Float!
}
